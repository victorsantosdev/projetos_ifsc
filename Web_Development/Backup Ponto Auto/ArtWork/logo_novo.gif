%% Script de Localização de Texto (Block Intensity)
%Este script visa identificar regiões de texto através de operações
%baseadas na intensidade da imagem ou frame de vídeo.
%Regiões de texto possuem um grande número de bordas distribuídas de
%maneira coerente. Estas bordas, ou variações abruptas de intensidade,
%limitam o traço do caractere que são regiões de pouco variação de
%intensidade.
%A forma como vamos identificar é separando a imagem em vários blocos que
%não se interceptam e calcular a faixa dinâmica através das equações:
%
% Considere que a imagem (F) possui I linhas e J colunas.
%
%   M(k,l) = max(F(i,j));
%   m(k,l) = min(F(i,j));
%
%   em que 
%   y*k <= i < y*(k+1)
%   y*l <= j < y*(l+1)
%   y determinará o tamanho do cada bloco na imagem
%
%   Os limites de k e l são
%   k = 0,1,...,(I/y)-1
%   l = 0,1,...,(J/y)-1
%
% A faixa dinâmica d é definida da seguinte forma:
%   d(k,l) = |M(k,l) - m(k,l)|
%
% O conjunto de blocos da imagem F classificada como blocos de texto são
% dadas por:
%
%   T = {(k,l)} = d(k,l) >= t ou
%               = d(k,l) = 0
%   em que t = 45


% Leitura da imagem
s = input('Digite o nome da imagem a ser segmentada: ', 's');
y = input('Digite o valor do tamanho do bloco: ', 's');

%Decompondo em RGB
imagem = imread(s);

%Calculando a imagem intensidade.
imint = rgb2gray(imagem);
y = str2double(y);

%Limiar de variaçao de intensidade dentro de um bloco.
t = 45;

%Calculando as dimensões da imagem
tam = size(imint);

%Criando uma estrutura para guardar os índices dos blocos
registro = struct('blocos',[],'indx',[],'indy',[]);

%Inicializa o contador
contador = 1;

l1 = (floor(tam(2)/(y))-1);
k1 = (floor(tam(1)/(y))-1);
for l=0:l1  %varre colunas
    for k=0:k1   %varre linhas
        i = k*y+1:y*(k+1);
        j = l*y+1:y*(l+1);
        registro(contador).blocos = imint(i,j);
        registro(contador).indx = i;
        registro(contador).indy = j;
        M(contador) = max(max(registro(contador).blocos));
        m(contador) = min(min(registro(contador).blocos));
        d(contador) = abs(M(contador)-m(contador));
        contador = contador+1;
    end
end

ind = find(d>t | d<=2);

%Disponibilizando o resultado inicial
resultado = false(tam);

for k = 1:length(ind)
    resultado([registro(ind(k)).indx],[registro(ind(k)).indy]) = true;
    v = vizinhos(ind(k),k1,l1,4);
    vexist = intersect(v,ind);
    if (numel(vexist) < 2) || (mean(d(vexist))<1.5*t)
        ind(k) = 0;
    end 
end

ind = nonzeros(ind);

resultadof = false(tam);
for s = 1:length(ind)
    resultadof([registro(ind(s)).indx], [registro(ind(s)).indy]) = true;
end


figure, imshow(imint,[]);
figure, imshow(resultado);
figure, imshow(resultadof);



 

