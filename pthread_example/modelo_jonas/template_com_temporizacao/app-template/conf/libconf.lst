In archive libconf.a:

conf.o:     file format elf32-i386

SYMBOL TABLE:
00000aea l     F .text	000001d1 write_section
00000000 l     O .rodata	00000005 STUB_STRING
00000000 g     F .text	00000006 bin64_get
00000006 g     F .text	00000006 oct32_get
0000000c g     F .text	00000027 ratio_set
00000000         *UND*	00000000 malloc
00000033 g     F .text	00000027 cymk_set
0000005a g     F .text	00000027 rgbi_set
00000081 g     F .text	00000027 rgb_set
000000a8 g     F .text	00000027 oct64_set
000000cf g     F .text	00000027 oct32_set
000000f6 g     F .text	00000027 oct16_set
0000011d g     F .text	00000027 oct8_set
00000144 g     F .text	00000027 bin64_set
0000016b g     F .text	00000027 bin32_set
00000192 g     F .text	00000027 bin16_set
000001b9 g     F .text	00000027 bin8_set
000001e0 g     F .text	0000004b void_get
00000000         *UND*	00000000 __sprintf_chk
0000022b g     F .text	0000004d int_get
00000278 g     F .text	0000004d uint_get
000002c5 g     F .text	0000004d float_get
00000312 g     F .text	0000004b string_get
0000035d g     F .text	0000002e bool_get
0000038b g     F .text	0000004e char_get
000003d9 g     F .text	0000004e hex8_get
00000427 g     F .text	0000004d hex16_get
00000474 g     F .text	0000004d hex32_get
000004c1 g     F .text	00000056 hex64_get
00000517 g     F .text	0000001e bin8_get
00000535 g     F .text	0000001e bin16_get
00000553 g     F .text	0000001e bin32_get
00000571 g     F .text	0000001e oct8_get
0000058f g     F .text	0000001e oct16_get
000005ad g     F .text	0000001e oct64_get
000005cb g     F .text	0000001e rgb_get
000005e9 g     F .text	0000001e rgbi_get
00000607 g     F .text	0000001e cymk_get
00000625 g     F .text	0000001e ratio_get
00000643 g     F .text	00000042 hex64_set
00000000         *UND*	00000000 __isoc99_sscanf
00000685 g     F .text	00000042 hex32_set
000006c7 g     F .text	00000042 hex16_set
00000709 g     F .text	00000042 hex8_set
0000074b g     F .text	00000042 float_set
0000078d g     F .text	0000002b void_set
000007b8 g     F .text	00000061 char_set
00000000         *UND*	00000000 __ctype_b_loc
00000819 g     F .text	0000014d bool_set
00000000         *UND*	00000000 strncasecmp
00000966 g     F .text	000000f4 string_set
00000000         *UND*	00000000 strchr
00000000         *UND*	00000000 stderr
00000000         *UND*	00000000 fwrite
00000000         *UND*	00000000 strncpy
00000a5a g     F .text	00000048 uint_set
00000000         *UND*	00000000 strtoul
00000aa2 g     F .text	00000048 int_set
00000000         *UND*	00000000 strtol
00000000 g     O .data	000001a0 conf_type_tab
00000000         *UND*	00000000 __fprintf_chk
00000000         *UND*	00000000 fputc
00000000         *UND*	00000000 __strcpy_chk
00000000         *UND*	00000000 __stack_chk_fail
00000cbb g     F .text	0000005b var_lookup
00000000         *UND*	00000000 strcmp
00000d16 g     F .text	00000048 var_set
00000d5e g     F .text	00000060 var_get
00000dbe g     F .text	00000466 conf_load
00000000         *UND*	00000000 fopen
00000000         *UND*	00000000 fgets
00000000         *UND*	00000000 fclose
00001224 g     F .text	00000052 conf_save
00001276 g     F .text	0000001a conf_dump
00000000         *UND*	00000000 stdout
00001290 g     F .text	00000006 ipaddr_get
00001296 g     F .text	00000027 ipaddr_set
000012bd g     F .text	00000006 ipport_get
000012c3 g     F .text	00000027 ipport_set



Disassembly of section .text:

00000000 <bin64_get>:
int bin64_get(struct conf_var *var, char *s)
{
	s = "";

	return 0;
}
       0:	b8 00 00 00 00       	mov    $0x0,%eax
       5:	c3                   	ret    

00000006 <oct32_get>:
int oct32_get(struct conf_var *var, char *s)
{
	s = "";

	return 0;
}
       6:	b8 00 00 00 00       	mov    $0x0,%eax
       b:	c3                   	ret    

0000000c <ratio_set>:

	return 0;
}

int ratio_set(struct conf_var *var, const char *s)
{
       c:	53                   	push   %ebx
       d:	83 ec 18             	sub    $0x18,%esp
      10:	8b 5c 24 20          	mov    0x20(%esp),%ebx
	if (var->p == NULL) {
      14:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
      18:	75 0f                	jne    29 <ratio_set+0x1d>
		var->p = malloc(2 * sizeof(int));
      1a:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
      21:	e8 fc ff ff ff       	call   22 <ratio_set+0x16>	22: R_386_PC32	malloc
      26:	89 43 08             	mov    %eax,0x8(%ebx)
	}

	return 0;
}
      29:	b8 00 00 00 00       	mov    $0x0,%eax
      2e:	83 c4 18             	add    $0x18,%esp
      31:	5b                   	pop    %ebx
      32:	c3                   	ret    

00000033 <cymk_set>:

	return 0;
}

int cymk_set(struct conf_var *var, const char *s)
{
      33:	53                   	push   %ebx
      34:	83 ec 18             	sub    $0x18,%esp
      37:	8b 5c 24 20          	mov    0x20(%esp),%ebx
	if (var->p == NULL) {
      3b:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
      3f:	75 0f                	jne    50 <cymk_set+0x1d>
		var->p = malloc(sizeof(unsigned int));
      41:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
      48:	e8 fc ff ff ff       	call   49 <cymk_set+0x16>	49: R_386_PC32	malloc
      4d:	89 43 08             	mov    %eax,0x8(%ebx)
	}

	return 0;
}
      50:	b8 00 00 00 00       	mov    $0x0,%eax
      55:	83 c4 18             	add    $0x18,%esp
      58:	5b                   	pop    %ebx
      59:	c3                   	ret    

0000005a <rgbi_set>:

	return 0;
}

int rgbi_set(struct conf_var *var, const char *s)
{
      5a:	53                   	push   %ebx
      5b:	83 ec 18             	sub    $0x18,%esp
      5e:	8b 5c 24 20          	mov    0x20(%esp),%ebx
	if (var->p == NULL) {
      62:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
      66:	75 0f                	jne    77 <rgbi_set+0x1d>
		var->p = malloc(sizeof(unsigned int));
      68:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
      6f:	e8 fc ff ff ff       	call   70 <rgbi_set+0x16>	70: R_386_PC32	malloc
      74:	89 43 08             	mov    %eax,0x8(%ebx)
	}

	return 0;
}
      77:	b8 00 00 00 00       	mov    $0x0,%eax
      7c:	83 c4 18             	add    $0x18,%esp
      7f:	5b                   	pop    %ebx
      80:	c3                   	ret    

00000081 <rgb_set>:

	return 0;
}

int rgb_set(struct conf_var *var, const char *s)
{
      81:	53                   	push   %ebx
      82:	83 ec 18             	sub    $0x18,%esp
      85:	8b 5c 24 20          	mov    0x20(%esp),%ebx
	if (var->p == NULL) {
      89:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
      8d:	75 0f                	jne    9e <rgb_set+0x1d>
		var->p = malloc(sizeof(unsigned int));
      8f:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
      96:	e8 fc ff ff ff       	call   97 <rgb_set+0x16>	97: R_386_PC32	malloc
      9b:	89 43 08             	mov    %eax,0x8(%ebx)
	}

	return 0;
}
      9e:	b8 00 00 00 00       	mov    $0x0,%eax
      a3:	83 c4 18             	add    $0x18,%esp
      a6:	5b                   	pop    %ebx
      a7:	c3                   	ret    

000000a8 <oct64_set>:

	return 0;
}

int oct64_set(struct conf_var *var, const char *s)
{
      a8:	53                   	push   %ebx
      a9:	83 ec 18             	sub    $0x18,%esp
      ac:	8b 5c 24 20          	mov    0x20(%esp),%ebx
	if (var->p == NULL) {
      b0:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
      b4:	75 0f                	jne    c5 <oct64_set+0x1d>
		var->p = malloc(sizeof(long long int));
      b6:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
      bd:	e8 fc ff ff ff       	call   be <oct64_set+0x16>	be: R_386_PC32	malloc
      c2:	89 43 08             	mov    %eax,0x8(%ebx)
	}

	return 0;
}
      c5:	b8 00 00 00 00       	mov    $0x0,%eax
      ca:	83 c4 18             	add    $0x18,%esp
      cd:	5b                   	pop    %ebx
      ce:	c3                   	ret    

000000cf <oct32_set>:

	return 0;
}

int oct32_set(struct conf_var *var, const char *s)
{
      cf:	53                   	push   %ebx
      d0:	83 ec 18             	sub    $0x18,%esp
      d3:	8b 5c 24 20          	mov    0x20(%esp),%ebx
	if (var->p == NULL) {
      d7:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
      db:	75 0f                	jne    ec <oct32_set+0x1d>
		var->p = malloc(sizeof(unsigned int));
      dd:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
      e4:	e8 fc ff ff ff       	call   e5 <oct32_set+0x16>	e5: R_386_PC32	malloc
      e9:	89 43 08             	mov    %eax,0x8(%ebx)
	}

	return 0;
}
      ec:	b8 00 00 00 00       	mov    $0x0,%eax
      f1:	83 c4 18             	add    $0x18,%esp
      f4:	5b                   	pop    %ebx
      f5:	c3                   	ret    

000000f6 <oct16_set>:

	return 0;
}

int oct16_set(struct conf_var *var, const char *s)
{
      f6:	53                   	push   %ebx
      f7:	83 ec 18             	sub    $0x18,%esp
      fa:	8b 5c 24 20          	mov    0x20(%esp),%ebx
	if (var->p == NULL) {
      fe:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
     102:	75 0f                	jne    113 <oct16_set+0x1d>
		var->p = malloc(sizeof(short int));
     104:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
     10b:	e8 fc ff ff ff       	call   10c <oct16_set+0x16>	10c: R_386_PC32	malloc
     110:	89 43 08             	mov    %eax,0x8(%ebx)
	}

	return 0;
}
     113:	b8 00 00 00 00       	mov    $0x0,%eax
     118:	83 c4 18             	add    $0x18,%esp
     11b:	5b                   	pop    %ebx
     11c:	c3                   	ret    

0000011d <oct8_set>:

	return 0;
}

int oct8_set(struct conf_var *var, const char *s)
{
     11d:	53                   	push   %ebx
     11e:	83 ec 18             	sub    $0x18,%esp
     121:	8b 5c 24 20          	mov    0x20(%esp),%ebx
	if (var->p == NULL) {
     125:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
     129:	75 0f                	jne    13a <oct8_set+0x1d>
		var->p = malloc(sizeof(unsigned char));
     12b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
     132:	e8 fc ff ff ff       	call   133 <oct8_set+0x16>	133: R_386_PC32	malloc
     137:	89 43 08             	mov    %eax,0x8(%ebx)
	}

	return 0;
}
     13a:	b8 00 00 00 00       	mov    $0x0,%eax
     13f:	83 c4 18             	add    $0x18,%esp
     142:	5b                   	pop    %ebx
     143:	c3                   	ret    

00000144 <bin64_set>:

	return 0;
}

int bin64_set(struct conf_var *var, const char *s)
{
     144:	53                   	push   %ebx
     145:	83 ec 18             	sub    $0x18,%esp
     148:	8b 5c 24 20          	mov    0x20(%esp),%ebx
	if (var->p == NULL) {
     14c:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
     150:	75 0f                	jne    161 <bin64_set+0x1d>
		var->p = malloc(sizeof(long long int));
     152:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
     159:	e8 fc ff ff ff       	call   15a <bin64_set+0x16>	15a: R_386_PC32	malloc
     15e:	89 43 08             	mov    %eax,0x8(%ebx)
	}

	return 0;
}
     161:	b8 00 00 00 00       	mov    $0x0,%eax
     166:	83 c4 18             	add    $0x18,%esp
     169:	5b                   	pop    %ebx
     16a:	c3                   	ret    

0000016b <bin32_set>:

	return 0;
}

int bin32_set(struct conf_var *var, const char *s)
{
     16b:	53                   	push   %ebx
     16c:	83 ec 18             	sub    $0x18,%esp
     16f:	8b 5c 24 20          	mov    0x20(%esp),%ebx
	if (var->p == NULL) {
     173:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
     177:	75 0f                	jne    188 <bin32_set+0x1d>
		var->p = malloc(sizeof(unsigned long));
     179:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
     180:	e8 fc ff ff ff       	call   181 <bin32_set+0x16>	181: R_386_PC32	malloc
     185:	89 43 08             	mov    %eax,0x8(%ebx)
	}
	return 0;
}
     188:	b8 00 00 00 00       	mov    $0x0,%eax
     18d:	83 c4 18             	add    $0x18,%esp
     190:	5b                   	pop    %ebx
     191:	c3                   	ret    

00000192 <bin16_set>:

	return 0;
}

int bin16_set(struct conf_var *var, const char *s)
{
     192:	53                   	push   %ebx
     193:	83 ec 18             	sub    $0x18,%esp
     196:	8b 5c 24 20          	mov    0x20(%esp),%ebx
	if (var->p == NULL) {
     19a:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
     19e:	75 0f                	jne    1af <bin16_set+0x1d>
		var->p = malloc(sizeof(short int));
     1a0:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
     1a7:	e8 fc ff ff ff       	call   1a8 <bin16_set+0x16>	1a8: R_386_PC32	malloc
     1ac:	89 43 08             	mov    %eax,0x8(%ebx)
	}

	return 0;
}
     1af:	b8 00 00 00 00       	mov    $0x0,%eax
     1b4:	83 c4 18             	add    $0x18,%esp
     1b7:	5b                   	pop    %ebx
     1b8:	c3                   	ret    

000001b9 <bin8_set>:

	return 0;
}

int bin8_set(struct conf_var *var, const char *s)
{
     1b9:	53                   	push   %ebx
     1ba:	83 ec 18             	sub    $0x18,%esp
     1bd:	8b 5c 24 20          	mov    0x20(%esp),%ebx
	if (var->p == NULL) {
     1c1:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
     1c5:	75 0f                	jne    1d6 <bin8_set+0x1d>
		var->p = malloc(sizeof(unsigned char));
     1c7:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
     1ce:	e8 fc ff ff ff       	call   1cf <bin8_set+0x16>	1cf: R_386_PC32	malloc
     1d3:	89 43 08             	mov    %eax,0x8(%ebx)
	}

	return 0;
}
     1d6:	b8 00 00 00 00       	mov    $0x0,%eax
     1db:	83 c4 18             	add    $0x18,%esp
     1de:	5b                   	pop    %ebx
     1df:	c3                   	ret    

000001e0 <void_get>:
{
	return write_section(stdout, root, NULL);
}

int void_get(struct conf_var *var, char *s)
{
     1e0:	83 ec 2c             	sub    $0x2c,%esp
     1e3:	8b 54 24 34          	mov    0x34(%esp),%edx
	if (var->p == NULL) {
     1e7:	8b 44 24 30          	mov    0x30(%esp),%eax
     1eb:	8b 40 08             	mov    0x8(%eax),%eax
     1ee:	85 c0                	test   %eax,%eax
     1f0:	75 0c                	jne    1fe <void_get+0x1e>

#ifdef __va_arg_pack
__extern_always_inline int
__NTH (sprintf (char *__restrict __s, __const char *__restrict __fmt, ...))
{
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
     1f2:	c7 02 4e 55 4c 4c    	movl   $0x4c4c554e,(%edx)
     1f8:	c6 42 04 00          	movb   $0x0,0x4(%edx)
		sprintf(s, "NULL");
		return 0;
     1fc:	eb 29                	jmp    227 <void_get+0x47>
     1fe:	89 44 24 10          	mov    %eax,0x10(%esp)
     202:	c7 44 24 0c 00 00 00 00 	movl   $0x0,0xc(%esp)	206: R_386_32	.rodata.str1.1
     20a:	c7 44 24 08 ff ff ff ff 	movl   $0xffffffff,0x8(%esp)
     212:	c7 44 24 04 01 00 00 00 	movl   $0x1,0x4(%esp)
     21a:	89 14 24             	mov    %edx,(%esp)
     21d:	e8 fc ff ff ff       	call   21e <void_get+0x3e>	21e: R_386_PC32	__sprintf_chk
	}

	sprintf(s, "%p", var->p);
	return 1;
     222:	b8 01 00 00 00       	mov    $0x1,%eax
}
     227:	83 c4 2c             	add    $0x2c,%esp
     22a:	c3                   	ret    

0000022b <int_get>:
	sscanf(s, "%p", &(var->p));
	return 1;
}

int int_get(struct conf_var *var, char *s)
{
     22b:	83 ec 2c             	sub    $0x2c,%esp
     22e:	8b 54 24 34          	mov    0x34(%esp),%edx
	if (var->p == NULL) {
     232:	8b 44 24 30          	mov    0x30(%esp),%eax
     236:	8b 40 08             	mov    0x8(%eax),%eax
     239:	85 c0                	test   %eax,%eax
     23b:	75 0c                	jne    249 <int_get+0x1e>
     23d:	c7 02 4e 55 4c 4c    	movl   $0x4c4c554e,(%edx)
     243:	c6 42 04 00          	movb   $0x0,0x4(%edx)
		sprintf(s, "NULL");
		return 0;
     247:	eb 2b                	jmp    274 <int_get+0x49>
     249:	8b 00                	mov    (%eax),%eax
     24b:	89 44 24 10          	mov    %eax,0x10(%esp)
     24f:	c7 44 24 0c 03 00 00 00 	movl   $0x3,0xc(%esp)	253: R_386_32	.rodata.str1.1
     257:	c7 44 24 08 ff ff ff ff 	movl   $0xffffffff,0x8(%esp)
     25f:	c7 44 24 04 01 00 00 00 	movl   $0x1,0x4(%esp)
     267:	89 14 24             	mov    %edx,(%esp)
     26a:	e8 fc ff ff ff       	call   26b <int_get+0x40>	26b: R_386_PC32	__sprintf_chk
	}

	sprintf(s, "%i", *(int *) (var->p));
	return 1;
     26f:	b8 01 00 00 00       	mov    $0x1,%eax
}
     274:	83 c4 2c             	add    $0x2c,%esp
     277:	c3                   	ret    

00000278 <uint_get>:

	return 1;
}

int uint_get(struct conf_var *var, char *s)
{
     278:	83 ec 2c             	sub    $0x2c,%esp
     27b:	8b 54 24 34          	mov    0x34(%esp),%edx
	if (var->p == NULL) {
     27f:	8b 44 24 30          	mov    0x30(%esp),%eax
     283:	8b 40 08             	mov    0x8(%eax),%eax
     286:	85 c0                	test   %eax,%eax
     288:	75 0c                	jne    296 <uint_get+0x1e>
     28a:	c7 02 4e 55 4c 4c    	movl   $0x4c4c554e,(%edx)
     290:	c6 42 04 00          	movb   $0x0,0x4(%edx)
		sprintf(s, "NULL");
		return 0;
     294:	eb 2b                	jmp    2c1 <uint_get+0x49>
     296:	8b 00                	mov    (%eax),%eax
     298:	89 44 24 10          	mov    %eax,0x10(%esp)
     29c:	c7 44 24 0c 06 00 00 00 	movl   $0x6,0xc(%esp)	2a0: R_386_32	.rodata.str1.1
     2a4:	c7 44 24 08 ff ff ff ff 	movl   $0xffffffff,0x8(%esp)
     2ac:	c7 44 24 04 01 00 00 00 	movl   $0x1,0x4(%esp)
     2b4:	89 14 24             	mov    %edx,(%esp)
     2b7:	e8 fc ff ff ff       	call   2b8 <uint_get+0x40>	2b8: R_386_PC32	__sprintf_chk
	}

	sprintf(s, "%u", *(unsigned int *) (var->p));
	return 1;
     2bc:	b8 01 00 00 00       	mov    $0x1,%eax
}
     2c1:	83 c4 2c             	add    $0x2c,%esp
     2c4:	c3                   	ret    

000002c5 <float_get>:

	return 1;
}

int float_get(struct conf_var *var, char *s)
{
     2c5:	83 ec 2c             	sub    $0x2c,%esp
     2c8:	8b 54 24 34          	mov    0x34(%esp),%edx
	if (var->p == NULL) {
     2cc:	8b 44 24 30          	mov    0x30(%esp),%eax
     2d0:	8b 40 08             	mov    0x8(%eax),%eax
     2d3:	85 c0                	test   %eax,%eax
     2d5:	75 0c                	jne    2e3 <float_get+0x1e>
     2d7:	c7 02 4e 55 4c 4c    	movl   $0x4c4c554e,(%edx)
     2dd:	c6 42 04 00          	movb   $0x0,0x4(%edx)
		sprintf(s, "NULL");
		return 0;
     2e1:	eb 2b                	jmp    30e <float_get+0x49>
     2e3:	dd 00                	fldl   (%eax)
     2e5:	dd 5c 24 10          	fstpl  0x10(%esp)
     2e9:	c7 44 24 0c 09 00 00 00 	movl   $0x9,0xc(%esp)	2ed: R_386_32	.rodata.str1.1
     2f1:	c7 44 24 08 ff ff ff ff 	movl   $0xffffffff,0x8(%esp)
     2f9:	c7 44 24 04 01 00 00 00 	movl   $0x1,0x4(%esp)
     301:	89 14 24             	mov    %edx,(%esp)
     304:	e8 fc ff ff ff       	call   305 <float_get+0x40>	305: R_386_PC32	__sprintf_chk
	}

	sprintf(s, "%f", *(double *) (var->p));
	return 1;
     309:	b8 01 00 00 00       	mov    $0x1,%eax
}
     30e:	83 c4 2c             	add    $0x2c,%esp
     311:	c3                   	ret    

00000312 <string_get>:
	sscanf(s, "%lf", (double *) (var->p));
	return 1;
}

int string_get(struct conf_var *var, char *s)
{
     312:	83 ec 2c             	sub    $0x2c,%esp
     315:	8b 54 24 34          	mov    0x34(%esp),%edx
	char * cp;			/* source */

	if (var->p == NULL) {
     319:	8b 44 24 30          	mov    0x30(%esp),%eax
     31d:	8b 40 08             	mov    0x8(%eax),%eax
     320:	85 c0                	test   %eax,%eax
     322:	75 0c                	jne    330 <string_get+0x1e>
     324:	c7 02 4e 55 4c 4c    	movl   $0x4c4c554e,(%edx)
     32a:	c6 42 04 00          	movb   $0x0,0x4(%edx)
		sprintf(s, "NULL");
		return 0;
     32e:	eb 29                	jmp    359 <string_get+0x47>
     330:	89 44 24 10          	mov    %eax,0x10(%esp)
     334:	c7 44 24 0c 0c 00 00 00 	movl   $0xc,0xc(%esp)	338: R_386_32	.rodata.str1.1
     33c:	c7 44 24 08 ff ff ff ff 	movl   $0xffffffff,0x8(%esp)
     344:	c7 44 24 04 01 00 00 00 	movl   $0x1,0x4(%esp)
     34c:	89 14 24             	mov    %edx,(%esp)
     34f:	e8 fc ff ff ff       	call   350 <string_get+0x3e>	350: R_386_PC32	__sprintf_chk
	}

	cp = (char *)(var->p);
	sprintf(s, "\"%s\"", cp);

	return 1;
     354:	b8 01 00 00 00       	mov    $0x1,%eax
}
     359:	83 c4 2c             	add    $0x2c,%esp
     35c:	c3                   	ret    

0000035d <bool_get>:

	return 1;
}

int bool_get(struct conf_var *var, char *s)
{
     35d:	8b 44 24 08          	mov    0x8(%esp),%eax
	if ((*(int *) (var->p)) == 0)
     361:	8b 54 24 04          	mov    0x4(%esp),%edx
     365:	8b 52 08             	mov    0x8(%edx),%edx
     368:	83 3a 00             	cmpl   $0x0,(%edx)
     36b:	75 0e                	jne    37b <bool_get+0x1e>
     36d:	c7 00 46 61 6c 73    	movl   $0x736c6146,(%eax)
     373:	66 c7 40 04 65 00    	movw   $0x65,0x4(%eax)
     379:	eb 0a                	jmp    385 <bool_get+0x28>
     37b:	c7 00 54 72 75 65    	movl   $0x65757254,(%eax)
     381:	c6 40 04 00          	movb   $0x0,0x4(%eax)
		sprintf(s, "False");
	else
		sprintf(s, "True");
	return 1;
}
     385:	b8 01 00 00 00       	mov    $0x1,%eax
     38a:	c3                   	ret    

0000038b <char_get>:

	return 0;
}

int char_get(struct conf_var *var, char *s)
{
     38b:	83 ec 2c             	sub    $0x2c,%esp
     38e:	8b 54 24 34          	mov    0x34(%esp),%edx
	if (var->p == NULL) {
     392:	8b 44 24 30          	mov    0x30(%esp),%eax
     396:	8b 40 08             	mov    0x8(%eax),%eax
     399:	85 c0                	test   %eax,%eax
     39b:	75 0c                	jne    3a9 <char_get+0x1e>
     39d:	c7 02 4e 55 4c 4c    	movl   $0x4c4c554e,(%edx)
     3a3:	c6 42 04 00          	movb   $0x0,0x4(%edx)
		sprintf(s, "NULL");
		return 0;
     3a7:	eb 2c                	jmp    3d5 <char_get+0x4a>
	}

	//printf("*** %s: var '%s' = '%c'\n", __FUNCTION__, var->name, *(char *)(var->p));

	sprintf(s, "%c", *(char *) (var->p));
     3a9:	0f be 00             	movsbl (%eax),%eax
     3ac:	89 44 24 10          	mov    %eax,0x10(%esp)
     3b0:	c7 44 24 0c 11 00 00 00 	movl   $0x11,0xc(%esp)	3b4: R_386_32	.rodata.str1.1
     3b8:	c7 44 24 08 ff ff ff ff 	movl   $0xffffffff,0x8(%esp)
     3c0:	c7 44 24 04 01 00 00 00 	movl   $0x1,0x4(%esp)
     3c8:	89 14 24             	mov    %edx,(%esp)
     3cb:	e8 fc ff ff ff       	call   3cc <char_get+0x41>	3cc: R_386_PC32	__sprintf_chk
	return 1;
     3d0:	b8 01 00 00 00       	mov    $0x1,%eax
}
     3d5:	83 c4 2c             	add    $0x2c,%esp
     3d8:	c3                   	ret    

000003d9 <hex8_get>:
	sscanf(cp, "%c", (char *) (var->p));
	return 1;
}

int hex8_get(struct conf_var *var, char *s)
{
     3d9:	83 ec 2c             	sub    $0x2c,%esp
     3dc:	8b 54 24 34          	mov    0x34(%esp),%edx
	if (var->p == NULL) {
     3e0:	8b 44 24 30          	mov    0x30(%esp),%eax
     3e4:	8b 40 08             	mov    0x8(%eax),%eax
     3e7:	85 c0                	test   %eax,%eax
     3e9:	75 0c                	jne    3f7 <hex8_get+0x1e>
     3eb:	c7 02 4e 55 4c 4c    	movl   $0x4c4c554e,(%edx)
     3f1:	c6 42 04 00          	movb   $0x0,0x4(%edx)
		sprintf(s, "NULL");
		return 0;
     3f5:	eb 2c                	jmp    423 <hex8_get+0x4a>
	}

	sprintf(s, "0x%02X", *(unsigned char *) (var->p));
     3f7:	0f b6 00             	movzbl (%eax),%eax
     3fa:	89 44 24 10          	mov    %eax,0x10(%esp)
     3fe:	c7 44 24 0c 14 00 00 00 	movl   $0x14,0xc(%esp)	402: R_386_32	.rodata.str1.1
     406:	c7 44 24 08 ff ff ff ff 	movl   $0xffffffff,0x8(%esp)
     40e:	c7 44 24 04 01 00 00 00 	movl   $0x1,0x4(%esp)
     416:	89 14 24             	mov    %edx,(%esp)
     419:	e8 fc ff ff ff       	call   41a <hex8_get+0x41>	41a: R_386_PC32	__sprintf_chk
	return 1;
     41e:	b8 01 00 00 00       	mov    $0x1,%eax
}
     423:	83 c4 2c             	add    $0x2c,%esp
     426:	c3                   	ret    

00000427 <hex16_get>:
	sscanf(s, "%X", (unsigned int *) (var->p));
	return 1;
}

int hex16_get(struct conf_var *var, char *s)
{
     427:	83 ec 2c             	sub    $0x2c,%esp
     42a:	8b 54 24 34          	mov    0x34(%esp),%edx
	if (var->p == NULL) {
     42e:	8b 44 24 30          	mov    0x30(%esp),%eax
     432:	8b 40 08             	mov    0x8(%eax),%eax
     435:	85 c0                	test   %eax,%eax
     437:	75 0c                	jne    445 <hex16_get+0x1e>
     439:	c7 02 4e 55 4c 4c    	movl   $0x4c4c554e,(%edx)
     43f:	c6 42 04 00          	movb   $0x0,0x4(%edx)
		sprintf(s, "NULL");
		return 0;
     443:	eb 2b                	jmp    470 <hex16_get+0x49>
     445:	8b 00                	mov    (%eax),%eax
     447:	89 44 24 10          	mov    %eax,0x10(%esp)
     44b:	c7 44 24 0c 1b 00 00 00 	movl   $0x1b,0xc(%esp)	44f: R_386_32	.rodata.str1.1
     453:	c7 44 24 08 ff ff ff ff 	movl   $0xffffffff,0x8(%esp)
     45b:	c7 44 24 04 01 00 00 00 	movl   $0x1,0x4(%esp)
     463:	89 14 24             	mov    %edx,(%esp)
     466:	e8 fc ff ff ff       	call   467 <hex16_get+0x40>	467: R_386_PC32	__sprintf_chk
	}

	sprintf(s, "0x%04X", *(unsigned int *) (var->p));
	return 1;
     46b:	b8 01 00 00 00       	mov    $0x1,%eax
}
     470:	83 c4 2c             	add    $0x2c,%esp
     473:	c3                   	ret    

00000474 <hex32_get>:
	sscanf(s, "%X", (unsigned int *) (var->p));
	return 1;
}

int hex32_get(struct conf_var *var, char *s)
{
     474:	83 ec 2c             	sub    $0x2c,%esp
     477:	8b 54 24 34          	mov    0x34(%esp),%edx
	if (var->p == NULL) {
     47b:	8b 44 24 30          	mov    0x30(%esp),%eax
     47f:	8b 40 08             	mov    0x8(%eax),%eax
     482:	85 c0                	test   %eax,%eax
     484:	75 0c                	jne    492 <hex32_get+0x1e>
     486:	c7 02 4e 55 4c 4c    	movl   $0x4c4c554e,(%edx)
     48c:	c6 42 04 00          	movb   $0x0,0x4(%edx)
		sprintf(s, "NULL");
		return 0;
     490:	eb 2b                	jmp    4bd <hex32_get+0x49>
     492:	8b 00                	mov    (%eax),%eax
     494:	89 44 24 10          	mov    %eax,0x10(%esp)
     498:	c7 44 24 0c 22 00 00 00 	movl   $0x22,0xc(%esp)	49c: R_386_32	.rodata.str1.1
     4a0:	c7 44 24 08 ff ff ff ff 	movl   $0xffffffff,0x8(%esp)
     4a8:	c7 44 24 04 01 00 00 00 	movl   $0x1,0x4(%esp)
     4b0:	89 14 24             	mov    %edx,(%esp)
     4b3:	e8 fc ff ff ff       	call   4b4 <hex32_get+0x40>	4b4: R_386_PC32	__sprintf_chk
	}

	sprintf(s, "0x%08X", *(unsigned int *) (var->p));
	return 1;
     4b8:	b8 01 00 00 00       	mov    $0x1,%eax
}
     4bd:	83 c4 2c             	add    $0x2c,%esp
     4c0:	c3                   	ret    

000004c1 <hex64_get>:
	sscanf(s, "%X", (unsigned int *) (var->p));
	return 1;
}

int hex64_get(struct conf_var *var, char *s)
{
     4c1:	53                   	push   %ebx
     4c2:	83 ec 28             	sub    $0x28,%esp
     4c5:	8b 54 24 34          	mov    0x34(%esp),%edx
	if (var->p == NULL) {
     4c9:	8b 44 24 30          	mov    0x30(%esp),%eax
     4cd:	8b 40 08             	mov    0x8(%eax),%eax
     4d0:	85 c0                	test   %eax,%eax
     4d2:	75 0c                	jne    4e0 <hex64_get+0x1f>
     4d4:	c7 02 4e 55 4c 4c    	movl   $0x4c4c554e,(%edx)
     4da:	c6 42 04 00          	movb   $0x0,0x4(%edx)
		sprintf(s, "NULL");
		return 0;
     4de:	eb 32                	jmp    512 <hex64_get+0x51>
     4e0:	8b 08                	mov    (%eax),%ecx
     4e2:	8b 58 04             	mov    0x4(%eax),%ebx
     4e5:	89 4c 24 10          	mov    %ecx,0x10(%esp)
     4e9:	89 5c 24 14          	mov    %ebx,0x14(%esp)
     4ed:	c7 44 24 0c 29 00 00 00 	movl   $0x29,0xc(%esp)	4f1: R_386_32	.rodata.str1.1
     4f5:	c7 44 24 08 ff ff ff ff 	movl   $0xffffffff,0x8(%esp)
     4fd:	c7 44 24 04 01 00 00 00 	movl   $0x1,0x4(%esp)
     505:	89 14 24             	mov    %edx,(%esp)
     508:	e8 fc ff ff ff       	call   509 <hex64_get+0x48>	509: R_386_PC32	__sprintf_chk
	}

	sprintf(s, "0x%016llX", *(unsigned long long int *) (var->p));

	return 1;
     50d:	b8 01 00 00 00       	mov    $0x1,%eax
}
     512:	83 c4 28             	add    $0x28,%esp
     515:	5b                   	pop    %ebx
     516:	c3                   	ret    

00000517 <bin8_get>:

	return 1;
}

int bin8_get(struct conf_var *var, char *s)
{
     517:	8b 54 24 08          	mov    0x8(%esp),%edx
	if (var->p == NULL) {
     51b:	8b 44 24 04          	mov    0x4(%esp),%eax
     51f:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
     523:	75 0a                	jne    52f <bin8_get+0x18>
     525:	c7 02 4e 55 4c 4c    	movl   $0x4c4c554e,(%edx)
     52b:	c6 42 04 00          	movb   $0x0,0x4(%edx)
		return 0;
	}
	s = "";

	return 0;
}
     52f:	b8 00 00 00 00       	mov    $0x0,%eax
     534:	c3                   	ret    

00000535 <bin16_get>:

	return 0;
}

int bin16_get(struct conf_var *var, char *s)
{
     535:	8b 54 24 08          	mov    0x8(%esp),%edx
	if (var->p == NULL) {
     539:	8b 44 24 04          	mov    0x4(%esp),%eax
     53d:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
     541:	75 0a                	jne    54d <bin16_get+0x18>
     543:	c7 02 4e 55 4c 4c    	movl   $0x4c4c554e,(%edx)
     549:	c6 42 04 00          	movb   $0x0,0x4(%edx)
		return 0;
	}
	s = "";

	return 0;
}
     54d:	b8 00 00 00 00       	mov    $0x0,%eax
     552:	c3                   	ret    

00000553 <bin32_get>:

	return 0;
}

int bin32_get(struct conf_var *var, char *s)
{
     553:	8b 54 24 08          	mov    0x8(%esp),%edx
	if (var->p == NULL) {
     557:	8b 44 24 04          	mov    0x4(%esp),%eax
     55b:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
     55f:	75 0a                	jne    56b <bin32_get+0x18>
     561:	c7 02 4e 55 4c 4c    	movl   $0x4c4c554e,(%edx)
     567:	c6 42 04 00          	movb   $0x0,0x4(%edx)
		return 0;
	}
	s = "";

	return 0;
}
     56b:	b8 00 00 00 00       	mov    $0x0,%eax
     570:	c3                   	ret    

00000571 <oct8_get>:

	return 0;
}

int oct8_get(struct conf_var *var, char *s)
{
     571:	8b 54 24 08          	mov    0x8(%esp),%edx
	if (var->p == NULL) {
     575:	8b 44 24 04          	mov    0x4(%esp),%eax
     579:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
     57d:	75 0a                	jne    589 <oct8_get+0x18>
     57f:	c7 02 4e 55 4c 4c    	movl   $0x4c4c554e,(%edx)
     585:	c6 42 04 00          	movb   $0x0,0x4(%edx)
		return 0;
	}
	s = "";

	return 0;
}
     589:	b8 00 00 00 00       	mov    $0x0,%eax
     58e:	c3                   	ret    

0000058f <oct16_get>:

	return 0;
}

int oct16_get(struct conf_var *var, char *s)
{
     58f:	8b 54 24 08          	mov    0x8(%esp),%edx
	if (var->p == NULL) {
     593:	8b 44 24 04          	mov    0x4(%esp),%eax
     597:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
     59b:	75 0a                	jne    5a7 <oct16_get+0x18>
     59d:	c7 02 4e 55 4c 4c    	movl   $0x4c4c554e,(%edx)
     5a3:	c6 42 04 00          	movb   $0x0,0x4(%edx)
		return 0;
	}
	s = "";

	return 0;
}
     5a7:	b8 00 00 00 00       	mov    $0x0,%eax
     5ac:	c3                   	ret    

000005ad <oct64_get>:

	return 0;
}

int oct64_get(struct conf_var *var, char *s)
{
     5ad:	8b 54 24 08          	mov    0x8(%esp),%edx
	if (var->p == NULL) {
     5b1:	8b 44 24 04          	mov    0x4(%esp),%eax
     5b5:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
     5b9:	75 0a                	jne    5c5 <oct64_get+0x18>
     5bb:	c7 02 4e 55 4c 4c    	movl   $0x4c4c554e,(%edx)
     5c1:	c6 42 04 00          	movb   $0x0,0x4(%edx)
		return 0;
	}
	s = "";

	return 0;
}
     5c5:	b8 00 00 00 00       	mov    $0x0,%eax
     5ca:	c3                   	ret    

000005cb <rgb_get>:

	return 0;
}

int rgb_get(struct conf_var *var, char *s)
{
     5cb:	8b 54 24 08          	mov    0x8(%esp),%edx
	if (var->p == NULL) {
     5cf:	8b 44 24 04          	mov    0x4(%esp),%eax
     5d3:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
     5d7:	75 0a                	jne    5e3 <rgb_get+0x18>
     5d9:	c7 02 4e 55 4c 4c    	movl   $0x4c4c554e,(%edx)
     5df:	c6 42 04 00          	movb   $0x0,0x4(%edx)
		return 0;
	}
	s = "";

	return 0;
}
     5e3:	b8 00 00 00 00       	mov    $0x0,%eax
     5e8:	c3                   	ret    

000005e9 <rgbi_get>:

	return 0;
}

int rgbi_get(struct conf_var *var, char *s)
{
     5e9:	8b 54 24 08          	mov    0x8(%esp),%edx
	if (var->p == NULL) {
     5ed:	8b 44 24 04          	mov    0x4(%esp),%eax
     5f1:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
     5f5:	75 0a                	jne    601 <rgbi_get+0x18>
     5f7:	c7 02 4e 55 4c 4c    	movl   $0x4c4c554e,(%edx)
     5fd:	c6 42 04 00          	movb   $0x0,0x4(%edx)
		return 0;
	}
	s = "";

	return 0;
}
     601:	b8 00 00 00 00       	mov    $0x0,%eax
     606:	c3                   	ret    

00000607 <cymk_get>:

	return 0;
}

int cymk_get(struct conf_var *var, char *s)
{
     607:	8b 54 24 08          	mov    0x8(%esp),%edx
	if (var->p == NULL) {
     60b:	8b 44 24 04          	mov    0x4(%esp),%eax
     60f:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
     613:	75 0a                	jne    61f <cymk_get+0x18>
     615:	c7 02 4e 55 4c 4c    	movl   $0x4c4c554e,(%edx)
     61b:	c6 42 04 00          	movb   $0x0,0x4(%edx)
		return 0;
	}
	s = "";

	return 0;
}
     61f:	b8 00 00 00 00       	mov    $0x0,%eax
     624:	c3                   	ret    

00000625 <ratio_get>:

	return 0;
}

int ratio_get(struct conf_var *var, char *s)
{
     625:	8b 54 24 08          	mov    0x8(%esp),%edx
	if (var->p == NULL) {
     629:	8b 44 24 04          	mov    0x4(%esp),%eax
     62d:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
     631:	75 0a                	jne    63d <ratio_get+0x18>
     633:	c7 02 4e 55 4c 4c    	movl   $0x4c4c554e,(%edx)
     639:	c6 42 04 00          	movb   $0x0,0x4(%edx)
		return 0;
	}
	s = "";

	return 0;
}
     63d:	b8 00 00 00 00       	mov    $0x0,%eax
     642:	c3                   	ret    

00000643 <hex64_set>:

	return 1;
}

int hex64_set(struct conf_var *var, const char *s)
{
     643:	53                   	push   %ebx
     644:	83 ec 18             	sub    $0x18,%esp
     647:	8b 5c 24 20          	mov    0x20(%esp),%ebx
	if (var->p == NULL) {
     64b:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
     64f:	75 0f                	jne    660 <hex64_set+0x1d>
		var->p = malloc(sizeof(unsigned long long int));
     651:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
     658:	e8 fc ff ff ff       	call   659 <hex64_set+0x16>	659: R_386_PC32	malloc
     65d:	89 43 08             	mov    %eax,0x8(%ebx)
	}

	sscanf(s, "%llX", (unsigned long long int *) (var->p));
     660:	8b 43 08             	mov    0x8(%ebx),%eax
     663:	89 44 24 08          	mov    %eax,0x8(%esp)
     667:	c7 44 24 04 33 00 00 00 	movl   $0x33,0x4(%esp)	66b: R_386_32	.rodata.str1.1
     66f:	8b 44 24 24          	mov    0x24(%esp),%eax
     673:	89 04 24             	mov    %eax,(%esp)
     676:	e8 fc ff ff ff       	call   677 <hex64_set+0x34>	677: R_386_PC32	__isoc99_sscanf

	return 1;
}
     67b:	b8 01 00 00 00       	mov    $0x1,%eax
     680:	83 c4 18             	add    $0x18,%esp
     683:	5b                   	pop    %ebx
     684:	c3                   	ret    

00000685 <hex32_set>:
	sprintf(s, "0x%08X", *(unsigned int *) (var->p));
	return 1;
}

int hex32_set(struct conf_var *var, const char *s)
{
     685:	53                   	push   %ebx
     686:	83 ec 18             	sub    $0x18,%esp
     689:	8b 5c 24 20          	mov    0x20(%esp),%ebx
	if (var->p == NULL) {
     68d:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
     691:	75 0f                	jne    6a2 <hex32_set+0x1d>
		var->p = malloc(sizeof(unsigned int));
     693:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
     69a:	e8 fc ff ff ff       	call   69b <hex32_set+0x16>	69b: R_386_PC32	malloc
     69f:	89 43 08             	mov    %eax,0x8(%ebx)
	}

	sscanf(s, "%X", (unsigned int *) (var->p));
     6a2:	8b 43 08             	mov    0x8(%ebx),%eax
     6a5:	89 44 24 08          	mov    %eax,0x8(%esp)
     6a9:	c7 44 24 04 38 00 00 00 	movl   $0x38,0x4(%esp)	6ad: R_386_32	.rodata.str1.1
     6b1:	8b 44 24 24          	mov    0x24(%esp),%eax
     6b5:	89 04 24             	mov    %eax,(%esp)
     6b8:	e8 fc ff ff ff       	call   6b9 <hex32_set+0x34>	6b9: R_386_PC32	__isoc99_sscanf
	return 1;
}
     6bd:	b8 01 00 00 00       	mov    $0x1,%eax
     6c2:	83 c4 18             	add    $0x18,%esp
     6c5:	5b                   	pop    %ebx
     6c6:	c3                   	ret    

000006c7 <hex16_set>:
	sprintf(s, "0x%04X", *(unsigned int *) (var->p));
	return 1;
}

int hex16_set(struct conf_var *var, const char *s)
{
     6c7:	53                   	push   %ebx
     6c8:	83 ec 18             	sub    $0x18,%esp
     6cb:	8b 5c 24 20          	mov    0x20(%esp),%ebx
	if (var->p == NULL) {
     6cf:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
     6d3:	75 0f                	jne    6e4 <hex16_set+0x1d>
		var->p = malloc(sizeof(unsigned int));
     6d5:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
     6dc:	e8 fc ff ff ff       	call   6dd <hex16_set+0x16>	6dd: R_386_PC32	malloc
     6e1:	89 43 08             	mov    %eax,0x8(%ebx)
	}
	sscanf(s, "%X", (unsigned int *) (var->p));
     6e4:	8b 43 08             	mov    0x8(%ebx),%eax
     6e7:	89 44 24 08          	mov    %eax,0x8(%esp)
     6eb:	c7 44 24 04 38 00 00 00 	movl   $0x38,0x4(%esp)	6ef: R_386_32	.rodata.str1.1
     6f3:	8b 44 24 24          	mov    0x24(%esp),%eax
     6f7:	89 04 24             	mov    %eax,(%esp)
     6fa:	e8 fc ff ff ff       	call   6fb <hex16_set+0x34>	6fb: R_386_PC32	__isoc99_sscanf
	return 1;
}
     6ff:	b8 01 00 00 00       	mov    $0x1,%eax
     704:	83 c4 18             	add    $0x18,%esp
     707:	5b                   	pop    %ebx
     708:	c3                   	ret    

00000709 <hex8_set>:
	sprintf(s, "0x%02X", *(unsigned char *) (var->p));
	return 1;
}

int hex8_set(struct conf_var *var, const char *s)
{
     709:	53                   	push   %ebx
     70a:	83 ec 18             	sub    $0x18,%esp
     70d:	8b 5c 24 20          	mov    0x20(%esp),%ebx
	if (var->p == NULL) {
     711:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
     715:	75 0f                	jne    726 <hex8_set+0x1d>
		var->p = malloc(sizeof(unsigned int));
     717:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
     71e:	e8 fc ff ff ff       	call   71f <hex8_set+0x16>	71f: R_386_PC32	malloc
     723:	89 43 08             	mov    %eax,0x8(%ebx)
	}
	sscanf(s, "%X", (unsigned int *) (var->p));
     726:	8b 43 08             	mov    0x8(%ebx),%eax
     729:	89 44 24 08          	mov    %eax,0x8(%esp)
     72d:	c7 44 24 04 38 00 00 00 	movl   $0x38,0x4(%esp)	731: R_386_32	.rodata.str1.1
     735:	8b 44 24 24          	mov    0x24(%esp),%eax
     739:	89 04 24             	mov    %eax,(%esp)
     73c:	e8 fc ff ff ff       	call   73d <hex8_set+0x34>	73d: R_386_PC32	__isoc99_sscanf
	return 1;
}
     741:	b8 01 00 00 00       	mov    $0x1,%eax
     746:	83 c4 18             	add    $0x18,%esp
     749:	5b                   	pop    %ebx
     74a:	c3                   	ret    

0000074b <float_set>:
	sprintf(s, "%f", *(double *) (var->p));
	return 1;
}

int float_set(struct conf_var *var, const char *s)
{
     74b:	53                   	push   %ebx
     74c:	83 ec 18             	sub    $0x18,%esp
     74f:	8b 5c 24 20          	mov    0x20(%esp),%ebx
	if (var->p == NULL) {
     753:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
     757:	75 0f                	jne    768 <float_set+0x1d>
		var->p = malloc(sizeof(double));
     759:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
     760:	e8 fc ff ff ff       	call   761 <float_set+0x16>	761: R_386_PC32	malloc
     765:	89 43 08             	mov    %eax,0x8(%ebx)
	}
	sscanf(s, "%lf", (double *) (var->p));
     768:	8b 43 08             	mov    0x8(%ebx),%eax
     76b:	89 44 24 08          	mov    %eax,0x8(%esp)
     76f:	c7 44 24 04 3b 00 00 00 	movl   $0x3b,0x4(%esp)	773: R_386_32	.rodata.str1.1
     777:	8b 44 24 24          	mov    0x24(%esp),%eax
     77b:	89 04 24             	mov    %eax,(%esp)
     77e:	e8 fc ff ff ff       	call   77f <float_set+0x34>	77f: R_386_PC32	__isoc99_sscanf
	return 1;
}
     783:	b8 01 00 00 00       	mov    $0x1,%eax
     788:	83 c4 18             	add    $0x18,%esp
     78b:	5b                   	pop    %ebx
     78c:	c3                   	ret    

0000078d <void_set>:
	sprintf(s, "%p", var->p);
	return 1;
}

int void_set(struct conf_var *var, const char *s)
{
     78d:	83 ec 1c             	sub    $0x1c,%esp
	sscanf(s, "%p", &(var->p));
     790:	8b 44 24 20          	mov    0x20(%esp),%eax
     794:	83 c0 08             	add    $0x8,%eax
     797:	89 44 24 08          	mov    %eax,0x8(%esp)
     79b:	c7 44 24 04 00 00 00 00 	movl   $0x0,0x4(%esp)	79f: R_386_32	.rodata.str1.1
     7a3:	8b 44 24 24          	mov    0x24(%esp),%eax
     7a7:	89 04 24             	mov    %eax,(%esp)
     7aa:	e8 fc ff ff ff       	call   7ab <void_set+0x1e>	7ab: R_386_PC32	__isoc99_sscanf
	return 1;
}
     7af:	b8 01 00 00 00       	mov    $0x1,%eax
     7b4:	83 c4 1c             	add    $0x1c,%esp
     7b7:	c3                   	ret    

000007b8 <char_set>:
	sprintf(s, "%c", *(char *) (var->p));
	return 1;
}

int char_set(struct conf_var *var, const char *s)
{
     7b8:	56                   	push   %esi
     7b9:	53                   	push   %ebx
     7ba:	83 ec 14             	sub    $0x14,%esp
     7bd:	8b 5c 24 20          	mov    0x20(%esp),%ebx
	char *cp;			/* source */

	if (var->p == NULL) {
     7c1:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
     7c5:	75 0f                	jne    7d6 <char_set+0x1e>
		var->p = malloc(sizeof(char));
     7c7:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
     7ce:	e8 fc ff ff ff       	call   7cf <char_set+0x17>	7cf: R_386_PC32	malloc
     7d3:	89 43 08             	mov    %eax,0x8(%ebx)
	}

	cp = (char *) s;
	LTRIM(cp);
     7d6:	e8 fc ff ff ff       	call   7d7 <char_set+0x1f>	7d7: R_386_PC32	__ctype_b_loc
     7db:	8b 30                	mov    (%eax),%esi
     7dd:	8b 44 24 24          	mov    0x24(%esp),%eax
     7e1:	eb 03                	jmp    7e6 <char_set+0x2e>
     7e3:	83 c0 01             	add    $0x1,%eax
     7e6:	0f b6 10             	movzbl (%eax),%edx
     7e9:	0f be ca             	movsbl %dl,%ecx
     7ec:	f6 44 4e 01 20       	testb  $0x20,0x1(%esi,%ecx,2)
     7f1:	74 04                	je     7f7 <char_set+0x3f>
     7f3:	84 d2                	test   %dl,%dl
     7f5:	75 ec                	jne    7e3 <char_set+0x2b>

	//printf("*** %s: var '%s' source='%s'\n", __FUNCTION__, var->name, cp);

	sscanf(cp, "%c", (char *) (var->p));
     7f7:	8b 53 08             	mov    0x8(%ebx),%edx
     7fa:	89 54 24 08          	mov    %edx,0x8(%esp)
     7fe:	c7 44 24 04 11 00 00 00 	movl   $0x11,0x4(%esp)	802: R_386_32	.rodata.str1.1
     806:	89 04 24             	mov    %eax,(%esp)
     809:	e8 fc ff ff ff       	call   80a <char_set+0x52>	80a: R_386_PC32	__isoc99_sscanf
	return 1;
}
     80e:	b8 01 00 00 00       	mov    $0x1,%eax
     813:	83 c4 14             	add    $0x14,%esp
     816:	5b                   	pop    %ebx
     817:	5e                   	pop    %esi
     818:	c3                   	ret    

00000819 <bool_set>:
		sprintf(s, "True");
	return 1;
}

int bool_set(struct conf_var *var, const char *s)
{
     819:	56                   	push   %esi
     81a:	53                   	push   %ebx
     81b:	83 ec 14             	sub    $0x14,%esp
     81e:	8b 74 24 20          	mov    0x20(%esp),%esi
	char *cp;			/* source */

	if (var->p == NULL) {
     822:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
     826:	75 0f                	jne    837 <bool_set+0x1e>
		var->p = malloc(sizeof(int));
     828:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
     82f:	e8 fc ff ff ff       	call   830 <bool_set+0x17>	830: R_386_PC32	malloc
     834:	89 46 08             	mov    %eax,0x8(%esi)
	}

	cp = (char *) s;
	LTRIM(cp);
     837:	e8 fc ff ff ff       	call   838 <bool_set+0x1f>	838: R_386_PC32	__ctype_b_loc
     83c:	8b 08                	mov    (%eax),%ecx
     83e:	8b 5c 24 24          	mov    0x24(%esp),%ebx
     842:	eb 03                	jmp    847 <bool_set+0x2e>
     844:	83 c3 01             	add    $0x1,%ebx
     847:	0f b6 03             	movzbl (%ebx),%eax
     84a:	0f be d0             	movsbl %al,%edx
     84d:	f6 44 51 01 20       	testb  $0x20,0x1(%ecx,%edx,2)
     852:	74 04                	je     858 <bool_set+0x3f>
     854:	84 c0                	test   %al,%al
     856:	75 ec                	jne    844 <bool_set+0x2b>

	if (!strncasecmp(cp, "TRUE", 4) ||
     858:	c7 44 24 08 04 00 00 00 	movl   $0x4,0x8(%esp)
     860:	c7 44 24 04 3f 00 00 00 	movl   $0x3f,0x4(%esp)	864: R_386_32	.rodata.str1.1
     868:	89 1c 24             	mov    %ebx,(%esp)
     86b:	e8 fc ff ff ff       	call   86c <bool_set+0x53>	86c: R_386_PC32	strncasecmp
     870:	85 c0                	test   %eax,%eax
     872:	74 54                	je     8c8 <bool_set+0xaf>
		!strncasecmp(cp, "YES", 3) ||
     874:	c7 44 24 08 03 00 00 00 	movl   $0x3,0x8(%esp)
     87c:	c7 44 24 04 44 00 00 00 	movl   $0x44,0x4(%esp)	880: R_386_32	.rodata.str1.1
     884:	89 1c 24             	mov    %ebx,(%esp)
     887:	e8 fc ff ff ff       	call   888 <bool_set+0x6f>	888: R_386_PC32	strncasecmp
	}

	cp = (char *) s;
	LTRIM(cp);

	if (!strncasecmp(cp, "TRUE", 4) ||
     88c:	85 c0                	test   %eax,%eax
     88e:	74 38                	je     8c8 <bool_set+0xaf>
		!strncasecmp(cp, "YES", 3) ||
		!strncasecmp(cp, "ON", 2) || !strncasecmp(cp, "1", 1)) {
     890:	c7 44 24 08 02 00 00 00 	movl   $0x2,0x8(%esp)
     898:	c7 44 24 04 48 00 00 00 	movl   $0x48,0x4(%esp)	89c: R_386_32	.rodata.str1.1
     8a0:	89 1c 24             	mov    %ebx,(%esp)
     8a3:	e8 fc ff ff ff       	call   8a4 <bool_set+0x8b>	8a4: R_386_PC32	strncasecmp

	cp = (char *) s;
	LTRIM(cp);

	if (!strncasecmp(cp, "TRUE", 4) ||
		!strncasecmp(cp, "YES", 3) ||
     8a8:	85 c0                	test   %eax,%eax
     8aa:	74 1c                	je     8c8 <bool_set+0xaf>
		!strncasecmp(cp, "ON", 2) || !strncasecmp(cp, "1", 1)) {
     8ac:	c7 44 24 08 01 00 00 00 	movl   $0x1,0x8(%esp)
     8b4:	c7 44 24 04 4b 00 00 00 	movl   $0x4b,0x4(%esp)	8b8: R_386_32	.rodata.str1.1
     8bc:	89 1c 24             	mov    %ebx,(%esp)
     8bf:	e8 fc ff ff ff       	call   8c0 <bool_set+0xa7>	8c0: R_386_PC32	strncasecmp
     8c4:	85 c0                	test   %eax,%eax
     8c6:	75 13                	jne    8db <bool_set+0xc2>

		*((int *) var->p) = 1;
     8c8:	8b 46 08             	mov    0x8(%esi),%eax
     8cb:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		return 1;
     8d1:	b8 01 00 00 00       	mov    $0x1,%eax
     8d6:	e9 85 00 00 00       	jmp    960 <bool_set+0x147>
	}

	if (!strncasecmp(cp, "FALSE", 5) ||
     8db:	c7 44 24 08 05 00 00 00 	movl   $0x5,0x8(%esp)
     8e3:	c7 44 24 04 4d 00 00 00 	movl   $0x4d,0x4(%esp)	8e7: R_386_32	.rodata.str1.1
     8eb:	89 1c 24             	mov    %ebx,(%esp)
     8ee:	e8 fc ff ff ff       	call   8ef <bool_set+0xd6>	8ef: R_386_PC32	strncasecmp
     8f3:	85 c0                	test   %eax,%eax
     8f5:	74 5b                	je     952 <bool_set+0x139>
		!strncasecmp(cp, "NO", 2) ||
     8f7:	c7 44 24 08 02 00 00 00 	movl   $0x2,0x8(%esp)
     8ff:	c7 44 24 04 53 00 00 00 	movl   $0x53,0x4(%esp)	903: R_386_32	.rodata.str1.1
     907:	89 1c 24             	mov    %ebx,(%esp)
     90a:	e8 fc ff ff ff       	call   90b <bool_set+0xf2>	90b: R_386_PC32	strncasecmp

		*((int *) var->p) = 1;
		return 1;
	}

	if (!strncasecmp(cp, "FALSE", 5) ||
     90f:	85 c0                	test   %eax,%eax
     911:	74 3f                	je     952 <bool_set+0x139>
		!strncasecmp(cp, "NO", 2) ||
		!strncasecmp(cp, "OFF", 3) || !strncasecmp(cp, "0", 1)) {
     913:	c7 44 24 08 03 00 00 00 	movl   $0x3,0x8(%esp)
     91b:	c7 44 24 04 56 00 00 00 	movl   $0x56,0x4(%esp)	91f: R_386_32	.rodata.str1.1
     923:	89 1c 24             	mov    %ebx,(%esp)
     926:	e8 fc ff ff ff       	call   927 <bool_set+0x10e>	927: R_386_PC32	strncasecmp
		*((int *) var->p) = 1;
		return 1;
	}

	if (!strncasecmp(cp, "FALSE", 5) ||
		!strncasecmp(cp, "NO", 2) ||
     92b:	85 c0                	test   %eax,%eax
     92d:	74 23                	je     952 <bool_set+0x139>
		!strncasecmp(cp, "OFF", 3) || !strncasecmp(cp, "0", 1)) {
     92f:	c7 44 24 08 01 00 00 00 	movl   $0x1,0x8(%esp)
     937:	c7 44 24 04 5a 00 00 00 	movl   $0x5a,0x4(%esp)	93b: R_386_32	.rodata.str1.1
     93f:	89 1c 24             	mov    %ebx,(%esp)
     942:	e8 fc ff ff ff       	call   943 <bool_set+0x12a>	943: R_386_PC32	strncasecmp
     947:	89 c2                	mov    %eax,%edx

		*((int *) var->p) = 0;
		return 1;
	}

	return 0;
     949:	b8 00 00 00 00       	mov    $0x0,%eax
		return 1;
	}

	if (!strncasecmp(cp, "FALSE", 5) ||
		!strncasecmp(cp, "NO", 2) ||
		!strncasecmp(cp, "OFF", 3) || !strncasecmp(cp, "0", 1)) {
     94e:	85 d2                	test   %edx,%edx
     950:	75 0e                	jne    960 <bool_set+0x147>

		*((int *) var->p) = 0;
     952:	8b 46 08             	mov    0x8(%esi),%eax
     955:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return 1;
     95b:	b8 01 00 00 00       	mov    $0x1,%eax
	}

	return 0;
}
     960:	83 c4 14             	add    $0x14,%esp
     963:	5b                   	pop    %ebx
     964:	5e                   	pop    %esi
     965:	c3                   	ret    

00000966 <string_set>:

	return 1;
}

int string_set(struct conf_var *var, const char *s)
{
     966:	57                   	push   %edi
     967:	56                   	push   %esi
     968:	53                   	push   %ebx
     969:	83 ec 10             	sub    $0x10,%esp
     96c:	8b 5c 24 20          	mov    0x20(%esp),%ebx
     970:	8b 7c 24 24          	mov    0x24(%esp),%edi
	char *cp;			/* source */
	int len;
	char quote;
	char *ep;

	if ((!s) || (!var))
     974:	85 ff                	test   %edi,%edi
     976:	0f 84 d2 00 00 00    	je     a4e <string_set+0xe8>
     97c:	85 db                	test   %ebx,%ebx
     97e:	0f 84 ca 00 00 00    	je     a4e <string_set+0xe8>
		return 0;

	cp = (char *) s;
	LTRIM(cp);
     984:	e8 fc ff ff ff       	call   985 <string_set+0x1f>	985: R_386_PC32	__ctype_b_loc
     989:	8b 30                	mov    (%eax),%esi
     98b:	89 fa                	mov    %edi,%edx
     98d:	eb 03                	jmp    992 <string_set+0x2c>
     98f:	83 c2 01             	add    $0x1,%edx
     992:	0f b6 02             	movzbl (%edx),%eax
     995:	0f be c8             	movsbl %al,%ecx
     998:	f6 44 4e 01 20       	testb  $0x20,0x1(%esi,%ecx,2)
     99d:	74 08                	je     9a7 <string_set+0x41>
     99f:	84 c0                	test   %al,%al
     9a1:	75 ec                	jne    98f <string_set+0x29>
     9a3:	89 d7                	mov    %edx,%edi
     9a5:	eb 53                	jmp    9fa <string_set+0x94>
     9a7:	89 d6                	mov    %edx,%esi
	if ((*cp == '"') || (*cp == '\'')) {
     9a9:	3c 22                	cmp    $0x22,%al
     9ab:	74 05                	je     9b2 <string_set+0x4c>
     9ad:	3c 27                	cmp    $0x27,%al
     9af:	90                   	nop
     9b0:	75 46                	jne    9f8 <string_set+0x92>
		quote = *cp;
		cp++;
     9b2:	83 c6 01             	add    $0x1,%esi
		if ((ep = strchr(cp, quote)) != NULL)
     9b5:	0f be c0             	movsbl %al,%eax
     9b8:	89 44 24 04          	mov    %eax,0x4(%esp)
     9bc:	89 34 24             	mov    %esi,(%esp)
     9bf:	e8 fc ff ff ff       	call   9c0 <string_set+0x5a>	9c0: R_386_PC32	strchr
			len = ep - cp;
     9c4:	89 c7                	mov    %eax,%edi
     9c6:	29 f7                	sub    %esi,%edi
	cp = (char *) s;
	LTRIM(cp);
	if ((*cp == '"') || (*cp == '\'')) {
		quote = *cp;
		cp++;
		if ((ep = strchr(cp, quote)) != NULL)
     9c8:	85 c0                	test   %eax,%eax
     9ca:	75 41                	jne    a0d <string_set+0xa7>

# ifdef __va_arg_pack
__extern_always_inline int
fprintf (FILE *__restrict __stream, __const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
     9cc:	a1 00 00 00 00       	mov    0x0,%eax	9cd: R_386_32	stderr
     9d1:	89 44 24 0c          	mov    %eax,0xc(%esp)
     9d5:	c7 44 24 08 15 00 00 00 	movl   $0x15,0x8(%esp)
     9dd:	c7 44 24 04 01 00 00 00 	movl   $0x1,0x4(%esp)
     9e5:	c7 04 24 5c 00 00 00 	movl   $0x5c,(%esp)	9e8: R_386_32	.rodata.str1.1
     9ec:	e8 fc ff ff ff       	call   9ed <string_set+0x87>	9ed: R_386_PC32	fwrite
			len = ep - cp;
		else {
#ifdef DEBUG
			fprintf(stderr, "Unterminated string.\n");
#endif
			len = 0;
     9f1:	bf 00 00 00 00       	mov    $0x0,%edi
     9f6:	eb 15                	jmp    a0d <string_set+0xa7>
	if ((!s) || (!var))
		return 0;

	cp = (char *) s;
	LTRIM(cp);
	if ((*cp == '"') || (*cp == '\'')) {
     9f8:	89 d7                	mov    %edx,%edi
#endif
			len = 0;
		}

	} else {
		len = strlen(cp);
     9fa:	b8 00 00 00 00       	mov    $0x0,%eax
     9ff:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
     a04:	f2 ae                	repnz scas %es:(%edi),%al
     a06:	f7 d1                	not    %ecx
     a08:	8d 79 ff             	lea    -0x1(%ecx),%edi
     a0b:	89 d6                	mov    %edx,%esi
	}

	if (var->p == NULL) {
     a0d:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
     a11:	75 0e                	jne    a21 <string_set+0xbb>
		var->p = malloc(len + 1);
     a13:	8d 47 01             	lea    0x1(%edi),%eax
     a16:	89 04 24             	mov    %eax,(%esp)
     a19:	e8 fc ff ff ff       	call   a1a <string_set+0xb4>	a1a: R_386_PC32	malloc
     a1e:	89 43 08             	mov    %eax,0x8(%ebx)
	}

	if (var->len > 0)
     a21:	8b 43 0c             	mov    0xc(%ebx),%eax
     a24:	85 c0                	test   %eax,%eax
     a26:	7e 05                	jle    a2d <string_set+0xc7>
		len = MIN(len, var->len);
     a28:	39 c7                	cmp    %eax,%edi
     a2a:	0f 4f f8             	cmovg  %eax,%edi

__extern_always_inline char *
__NTH (strncpy (char *__restrict __dest, __const char *__restrict __src,
		size_t __len))
{
  return __builtin___strncpy_chk (__dest, __src, __len, __bos (__dest));
     a2d:	89 7c 24 08          	mov    %edi,0x8(%esp)
     a31:	89 74 24 04          	mov    %esi,0x4(%esp)
     a35:	8b 43 08             	mov    0x8(%ebx),%eax
     a38:	89 04 24             	mov    %eax,(%esp)
     a3b:	e8 fc ff ff ff       	call   a3c <string_set+0xd6>	a3c: R_386_PC32	strncpy

	strncpy((char *) (var->p), cp, len);
	cp = (char *)(var->p);
	cp[len] = '\0';
     a40:	8b 43 08             	mov    0x8(%ebx),%eax
     a43:	c6 04 38 00          	movb   $0x0,(%eax,%edi,1)

	return 1;
     a47:	b8 01 00 00 00       	mov    $0x1,%eax
     a4c:	eb 05                	jmp    a53 <string_set+0xed>
	int len;
	char quote;
	char *ep;

	if ((!s) || (!var))
		return 0;
     a4e:	b8 00 00 00 00       	mov    $0x0,%eax
	strncpy((char *) (var->p), cp, len);
	cp = (char *)(var->p);
	cp[len] = '\0';

	return 1;
}
     a53:	83 c4 10             	add    $0x10,%esp
     a56:	5b                   	pop    %ebx
     a57:	5e                   	pop    %esi
     a58:	5f                   	pop    %edi
     a59:	c3                   	ret    

00000a5a <uint_set>:
	sprintf(s, "%u", *(unsigned int *) (var->p));
	return 1;
}

int uint_set(struct conf_var *var, const char *s)
{
     a5a:	53                   	push   %ebx
     a5b:	83 ec 18             	sub    $0x18,%esp
     a5e:	8b 5c 24 20          	mov    0x20(%esp),%ebx
	unsigned int *p;

	if (var->p == NULL) {
     a62:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
     a66:	75 0f                	jne    a77 <uint_set+0x1d>
		var->p = malloc(sizeof(unsigned int));
     a68:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
     a6f:	e8 fc ff ff ff       	call   a70 <uint_set+0x16>	a70: R_386_PC32	malloc
     a74:	89 43 08             	mov    %eax,0x8(%ebx)
	}

	p = (unsigned int *) var->p;
     a77:	8b 5b 08             	mov    0x8(%ebx),%ebx

	*p = strtoul(s, NULL, 0);
     a7a:	c7 44 24 08 00 00 00 00 	movl   $0x0,0x8(%esp)
     a82:	c7 44 24 04 00 00 00 00 	movl   $0x0,0x4(%esp)
     a8a:	8b 44 24 24          	mov    0x24(%esp),%eax
     a8e:	89 04 24             	mov    %eax,(%esp)
     a91:	e8 fc ff ff ff       	call   a92 <uint_set+0x38>	a92: R_386_PC32	strtoul
     a96:	89 03                	mov    %eax,(%ebx)

	return 1;
}
     a98:	b8 01 00 00 00       	mov    $0x1,%eax
     a9d:	83 c4 18             	add    $0x18,%esp
     aa0:	5b                   	pop    %ebx
     aa1:	c3                   	ret    

00000aa2 <int_set>:
	sprintf(s, "%i", *(int *) (var->p));
	return 1;
}

int int_set(struct conf_var *var, const char *s)
{
     aa2:	53                   	push   %ebx
     aa3:	83 ec 18             	sub    $0x18,%esp
     aa6:	8b 5c 24 20          	mov    0x20(%esp),%ebx
	int *p;

	if (var->p == NULL) {
     aaa:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
     aae:	75 0f                	jne    abf <int_set+0x1d>
		var->p = malloc(sizeof(int));
     ab0:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
     ab7:	e8 fc ff ff ff       	call   ab8 <int_set+0x16>	ab8: R_386_PC32	malloc
     abc:	89 43 08             	mov    %eax,0x8(%ebx)
	}

	p = (int *) var->p;
     abf:	8b 5b 08             	mov    0x8(%ebx),%ebx

	*p = strtol(s, NULL, 0);
     ac2:	c7 44 24 08 00 00 00 00 	movl   $0x0,0x8(%esp)
     aca:	c7 44 24 04 00 00 00 00 	movl   $0x0,0x4(%esp)
     ad2:	8b 44 24 24          	mov    0x24(%esp),%eax
     ad6:	89 04 24             	mov    %eax,(%esp)
     ad9:	e8 fc ff ff ff       	call   ada <int_set+0x38>	ada: R_386_PC32	strtol
     ade:	89 03                	mov    %eax,(%ebx)

	return 1;
}
     ae0:	b8 01 00 00 00       	mov    $0x1,%eax
     ae5:	83 c4 18             	add    $0x18,%esp
     ae8:	5b                   	pop    %ebx
     ae9:	c3                   	ret    

00000aea <write_section>:
/*
* Recursive writes a section into a stream
*
*/
static int write_section(FILE * f, struct conf_var *section, char *branch)
{
     aea:	55                   	push   %ebp
     aeb:	57                   	push   %edi
     aec:	56                   	push   %esi
     aed:	53                   	push   %ebx
     aee:	81 ec 4c 18 00 00    	sub    $0x184c,%esp
     af4:	89 44 24 20          	mov    %eax,0x20(%esp)
     af8:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
     afe:	89 84 24 3c 18 00 00 	mov    %eax,0x183c(%esp)
     b05:	31 c0                	xor    %eax,%eax
	struct conf_var *queue[1024];
	int head = 0;
	int tail = 0;

	if (section == NULL)
		return 0;
     b07:	c7 44 24 24 00 00 00 00 	movl   $0x0,0x24(%esp)
	/* define a queue for sections */
	struct conf_var *queue[1024];
	int head = 0;
	int tail = 0;

	if (section == NULL)
     b0f:	85 d2                	test   %edx,%edx
     b11:	0f 84 69 01 00 00    	je     c80 <write_section+0x196>
		return 0;

	entry = section;
	while (entry->name != NULL) {
     b17:	83 3a 00             	cmpl   $0x0,(%edx)
     b1a:	0f 84 60 01 00 00    	je     c80 <write_section+0x196>
     b20:	89 d3                	mov    %edx,%ebx
     b22:	c7 44 24 28 00 00 00 00 	movl   $0x0,0x28(%esp)

		if (entry->type == CONF_TYPE(CONF_SECTION)) {
			queue[tail++] = (struct conf_var *) entry;
		} else {
			if (entry->type->t_get(entry, buf)) {
     b2a:	8d b4 24 3c 10 00 00 	lea    0x103c(%esp),%esi
     b31:	bf 00 00 00 00       	mov    $0x0,%edi
     b36:	89 4c 24 2c          	mov    %ecx,0x2c(%esp)
     b3a:	bd 00 00 00 00       	mov    $0x0,%ebp
		return 0;

	entry = section;
	while (entry->name != NULL) {

		if (entry->type == CONF_TYPE(CONF_SECTION)) {
     b3f:	8b 43 04             	mov    0x4(%ebx),%eax
     b42:	3d 10 00 00 00       	cmp    $0x10,%eax	b43: R_386_32	conf_type_tab
     b47:	75 09                	jne    b52 <write_section+0x68>
			queue[tail++] = (struct conf_var *) entry;
     b49:	89 5c ac 3c          	mov    %ebx,0x3c(%esp,%ebp,4)
     b4d:	83 c5 01             	add    $0x1,%ebp
     b50:	eb 63                	jmp    bb5 <write_section+0xcb>
		} else {
			if (entry->type->t_get(entry, buf)) {
     b52:	89 74 24 04          	mov    %esi,0x4(%esp)
     b56:	89 1c 24             	mov    %ebx,(%esp)
     b59:	ff 50 08             	call   *0x8(%eax)
     b5c:	85 c0                	test   %eax,%eax
     b5e:	74 28                	je     b88 <write_section+0x9e>
				fprintf(f, "%s = %s\n", entry->name, buf);
     b60:	89 74 24 10          	mov    %esi,0x10(%esp)
     b64:	8b 03                	mov    (%ebx),%eax
     b66:	89 44 24 0c          	mov    %eax,0xc(%esp)
     b6a:	c7 44 24 08 72 00 00 00 	movl   $0x72,0x8(%esp)	b6e: R_386_32	.rodata.str1.1
     b72:	c7 44 24 04 01 00 00 00 	movl   $0x1,0x4(%esp)
     b7a:	8b 44 24 20          	mov    0x20(%esp),%eax
     b7e:	89 04 24             	mov    %eax,(%esp)
     b81:	e8 fc ff ff ff       	call   b82 <write_section+0x98>	b82: R_386_PC32	__fprintf_chk
     b86:	eb 2a                	jmp    bb2 <write_section+0xc8>
     b88:	c7 44 24 10 00 00 00 00 	movl   $0x0,0x10(%esp)	b8c: R_386_32	.rodata
     b90:	8b 03                	mov    (%ebx),%eax
     b92:	89 44 24 0c          	mov    %eax,0xc(%esp)
     b96:	c7 44 24 08 72 00 00 00 	movl   $0x72,0x8(%esp)	b9a: R_386_32	.rodata.str1.1
     b9e:	c7 44 24 04 01 00 00 00 	movl   $0x1,0x4(%esp)
     ba6:	8b 44 24 20          	mov    0x20(%esp),%eax
     baa:	89 04 24             	mov    %eax,(%esp)
     bad:	e8 fc ff ff ff       	call   bae <write_section+0xc4>	bae: R_386_PC32	__fprintf_chk
			} else {
				/* Assuming the above failure means configuration stub. */
				fprintf(f, "%s = %s\n", entry->name, STUB_STRING);
			}
			count++;
     bb2:	83 c7 01             	add    $0x1,%edi
		}
		entry++;
     bb5:	83 c3 10             	add    $0x10,%ebx

	if (section == NULL)
		return 0;

	entry = section;
	while (entry->name != NULL) {
     bb8:	83 3b 00             	cmpl   $0x0,(%ebx)
     bbb:	75 82                	jne    b3f <write_section+0x55>
     bbd:	89 7c 24 24          	mov    %edi,0x24(%esp)
     bc1:	89 6c 24 28          	mov    %ebp,0x28(%esp)
     bc5:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
			count++;
		}
		entry++;
	}

	for (head = 0; head < tail; head++) {
     bc9:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
     bce:	0f 8f c2 00 00 00    	jg     c96 <write_section+0x1ac>
     bd4:	e9 a7 00 00 00       	jmp    c80 <write_section+0x196>
		entry = queue[head];
     bd9:	8b 74 9c 3c          	mov    0x3c(%esp,%ebx,4),%esi
		if (head != 0)
     bdd:	85 db                	test   %ebx,%ebx
     bdf:	74 14                	je     bf5 <write_section+0x10b>
     be1:	8b 44 24 20          	mov    0x20(%esp),%eax
     be5:	89 44 24 04          	mov    %eax,0x4(%esp)
     be9:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
     bf0:	e8 fc ff ff ff       	call   bf1 <write_section+0x107>	bf1: R_386_PC32	fputc
			fprintf(f, "\n");
		if ((branch != NULL) && (*branch != '\0'))
     bf5:	85 ed                	test   %ebp,%ebp
     bf7:	74 32                	je     c2b <write_section+0x141>
     bf9:	80 7d 00 00          	cmpb   $0x0,0x0(%ebp)
     bfd:	74 2c                	je     c2b <write_section+0x141>

#ifdef __va_arg_pack
__extern_always_inline int
__NTH (sprintf (char *__restrict __s, __const char *__restrict __fmt, ...))
{
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
     bff:	8b 06                	mov    (%esi),%eax
     c01:	89 44 24 14          	mov    %eax,0x14(%esp)
     c05:	89 6c 24 10          	mov    %ebp,0x10(%esp)
     c09:	c7 44 24 0c 7b 00 00 00 	movl   $0x7b,0xc(%esp)	c0d: R_386_32	.rodata.str1.1
     c11:	c7 44 24 08 00 08 00 00 	movl   $0x800,0x8(%esp)
     c19:	c7 44 24 04 01 00 00 00 	movl   $0x1,0x4(%esp)
			sprintf(buf, "%s/%s", branch, entry->name);
     c21:	89 3c 24             	mov    %edi,(%esp)
     c24:	e8 fc ff ff ff       	call   c25 <write_section+0x13b>	c25: R_386_PC32	__sprintf_chk
     c29:	eb 16                	jmp    c41 <write_section+0x157>
#endif

__extern_always_inline char *
__NTH (strcpy (char *__restrict __dest, __const char *__restrict __src))
{
  return __builtin___strcpy_chk (__dest, __src, __bos (__dest));
     c2b:	c7 44 24 08 00 08 00 00 	movl   $0x800,0x8(%esp)
     c33:	8b 06                	mov    (%esi),%eax
     c35:	89 44 24 04          	mov    %eax,0x4(%esp)
		else
			strcpy(buf, entry->name);
     c39:	89 3c 24             	mov    %edi,(%esp)
     c3c:	e8 fc ff ff ff       	call   c3d <write_section+0x153>	c3d: R_386_PC32	__strcpy_chk
		fprintf(f, "[%s]\n", buf);
     c41:	89 7c 24 0c          	mov    %edi,0xc(%esp)

# ifdef __va_arg_pack
__extern_always_inline int
fprintf (FILE *__restrict __stream, __const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
     c45:	c7 44 24 08 81 00 00 00 	movl   $0x81,0x8(%esp)	c49: R_386_32	.rodata.str1.1
     c4d:	c7 44 24 04 01 00 00 00 	movl   $0x1,0x4(%esp)
     c55:	8b 44 24 20          	mov    0x20(%esp),%eax
     c59:	89 04 24             	mov    %eax,(%esp)
     c5c:	e8 fc ff ff ff       	call   c5d <write_section+0x173>	c5d: R_386_PC32	__fprintf_chk
		count += write_section(f, (struct conf_var *) entry->p, buf);
     c61:	8b 56 08             	mov    0x8(%esi),%edx
     c64:	89 f9                	mov    %edi,%ecx
     c66:	8b 44 24 20          	mov    0x20(%esp),%eax
     c6a:	e8 7b fe ff ff       	call   aea <write_section>
     c6f:	01 44 24 24          	add    %eax,0x24(%esp)
			count++;
		}
		entry++;
	}

	for (head = 0; head < tail; head++) {
     c73:	83 c3 01             	add    $0x1,%ebx
     c76:	3b 5c 24 28          	cmp    0x28(%esp),%ebx
     c7a:	0f 85 59 ff ff ff    	jne    bd9 <write_section+0xef>
		fprintf(f, "[%s]\n", buf);
		count += write_section(f, (struct conf_var *) entry->p, buf);
	}

	return count;
}
     c80:	8b 44 24 24          	mov    0x24(%esp),%eax
     c84:	8b 94 24 3c 18 00 00 	mov    0x183c(%esp),%edx
     c8b:	65 33 15 14 00 00 00 	xor    %gs:0x14,%edx
     c92:	74 1c                	je     cb0 <write_section+0x1c6>
     c94:	eb 15                	jmp    cab <write_section+0x1c1>
		}
		entry++;
	}

	for (head = 0; head < tail; head++) {
		entry = queue[head];
     c96:	8b 74 24 3c          	mov    0x3c(%esp),%esi
     c9a:	bb 00 00 00 00       	mov    $0x0,%ebx
		if (head != 0)
			fprintf(f, "\n");
		if ((branch != NULL) && (*branch != '\0'))
			sprintf(buf, "%s/%s", branch, entry->name);
     c9f:	8d bc 24 3c 10 00 00 	lea    0x103c(%esp),%edi
     ca6:	e9 4a ff ff ff       	jmp    bf5 <write_section+0x10b>
		fprintf(f, "[%s]\n", buf);
		count += write_section(f, (struct conf_var *) entry->p, buf);
	}

	return count;
}
     cab:	e8 fc ff ff ff       	call   cac <write_section+0x1c2>	cac: R_386_PC32	__stack_chk_fail
     cb0:	81 c4 4c 18 00 00    	add    $0x184c,%esp
     cb6:	5b                   	pop    %ebx
     cb7:	5e                   	pop    %esi
     cb8:	5f                   	pop    %edi
     cb9:	5d                   	pop    %ebp
     cba:	c3                   	ret    

00000cbb <var_lookup>:
	/* {CONF_IPPORT, "ip_port", ipport_get, ipport_set} */
	{CONF_IPPORT, "ip_port", string_get, string_set}
};

struct conf_var *var_lookup(struct conf_var *section, const char *name)
{
     cbb:	56                   	push   %esi
     cbc:	53                   	push   %ebx
     cbd:	83 ec 14             	sub    $0x14,%esp
     cc0:	8b 54 24 20          	mov    0x20(%esp),%edx
     cc4:	8b 74 24 24          	mov    0x24(%esp),%esi
	struct conf_var *entry;

	if ((name == NULL) || (*name == '\0')) {
     cc8:	85 f6                	test   %esi,%esi
     cca:	74 36                	je     d02 <var_lookup+0x47>
		//      fprintf(stderr, "name invalid\n");
		return NULL;
     ccc:	bb 00 00 00 00       	mov    $0x0,%ebx

struct conf_var *var_lookup(struct conf_var *section, const char *name)
{
	struct conf_var *entry;

	if ((name == NULL) || (*name == '\0')) {
     cd1:	80 3e 00             	cmpb   $0x0,(%esi)
     cd4:	74 38                	je     d0e <var_lookup+0x53>
		//      fprintf(stderr, "name invalid\n");
		return NULL;
	}

	if ((entry = section) == NULL) {
     cd6:	85 d2                	test   %edx,%edx
     cd8:	74 2f                	je     d09 <var_lookup+0x4e>
		//      fprintf(stderr, "section invalid\n");
		return NULL;
	}

	while (entry->name != NULL) {
     cda:	8b 02                	mov    (%edx),%eax
     cdc:	85 c0                	test   %eax,%eax
     cde:	74 2e                	je     d0e <var_lookup+0x53>
     ce0:	89 d3                	mov    %edx,%ebx
		if (strcmp(entry->name, name) == 0)
     ce2:	89 74 24 04          	mov    %esi,0x4(%esp)
     ce6:	89 04 24             	mov    %eax,(%esp)
     ce9:	e8 fc ff ff ff       	call   cea <var_lookup+0x2f>	cea: R_386_PC32	strcmp
     cee:	85 c0                	test   %eax,%eax
     cf0:	74 1c                	je     d0e <var_lookup+0x53>
			return entry;
		entry++;
     cf2:	83 c3 10             	add    $0x10,%ebx
	if ((entry = section) == NULL) {
		//      fprintf(stderr, "section invalid\n");
		return NULL;
	}

	while (entry->name != NULL) {
     cf5:	8b 03                	mov    (%ebx),%eax
     cf7:	85 c0                	test   %eax,%eax
     cf9:	75 e7                	jne    ce2 <var_lookup+0x27>
			return entry;
		entry++;
	}

//      fprintf(stderr, "name not found\n");
	return NULL;
     cfb:	bb 00 00 00 00       	mov    $0x0,%ebx
     d00:	eb 0c                	jmp    d0e <var_lookup+0x53>
{
	struct conf_var *entry;

	if ((name == NULL) || (*name == '\0')) {
		//      fprintf(stderr, "name invalid\n");
		return NULL;
     d02:	bb 00 00 00 00       	mov    $0x0,%ebx
     d07:	eb 05                	jmp    d0e <var_lookup+0x53>
	}

	if ((entry = section) == NULL) {
		//      fprintf(stderr, "section invalid\n");
		return NULL;
     d09:	bb 00 00 00 00       	mov    $0x0,%ebx
		entry++;
	}

//      fprintf(stderr, "name not found\n");
	return NULL;
}
     d0e:	89 d8                	mov    %ebx,%eax
     d10:	83 c4 14             	add    $0x14,%esp
     d13:	5b                   	pop    %ebx
     d14:	5e                   	pop    %esi
     d15:	c3                   	ret    

00000d16 <var_set>:

int var_set(struct conf_var *section, const char *name, const char *value)
{
     d16:	53                   	push   %ebx
     d17:	83 ec 18             	sub    $0x18,%esp
     d1a:	8b 5c 24 28          	mov    0x28(%esp),%ebx
	struct conf_var *entry;

	entry = var_lookup(section, name);
     d1e:	8b 44 24 24          	mov    0x24(%esp),%eax
     d22:	89 44 24 04          	mov    %eax,0x4(%esp)
     d26:	8b 44 24 20          	mov    0x20(%esp),%eax
     d2a:	89 04 24             	mov    %eax,(%esp)
     d2d:	e8 fc ff ff ff       	call   d2e <var_set+0x18>	d2e: R_386_PC32	var_lookup
	if (entry == NULL)
     d32:	85 c0                	test   %eax,%eax
     d34:	74 1e                	je     d54 <var_set+0x3e>
		return -1;

	/* Assuming NULL set as a stub configuration. */
	if (value == NULL)
		value = STUB_STRING;
     d36:	85 db                	test   %ebx,%ebx
     d38:	ba 00 00 00 00       	mov    $0x0,%edx	d39: R_386_32	.rodata
     d3d:	0f 44 da             	cmove  %edx,%ebx
	
	if (entry->type->t_set(entry, value))
     d40:	8b 50 04             	mov    0x4(%eax),%edx
     d43:	89 5c 24 04          	mov    %ebx,0x4(%esp)
     d47:	89 04 24             	mov    %eax,(%esp)
     d4a:	ff 52 0c             	call   *0xc(%edx)
		return 0;
     d4d:	83 f8 01             	cmp    $0x1,%eax
     d50:	19 c0                	sbb    %eax,%eax
     d52:	eb 05                	jmp    d59 <var_set+0x43>
{
	struct conf_var *entry;

	entry = var_lookup(section, name);
	if (entry == NULL)
		return -1;
     d54:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	
	if (entry->type->t_set(entry, value))
		return 0;

	return -1;
}
     d59:	83 c4 18             	add    $0x18,%esp
     d5c:	5b                   	pop    %ebx
     d5d:	c3                   	ret    

00000d5e <var_get>:

int var_get(struct conf_var *section, const char *name, char *value)
{
     d5e:	53                   	push   %ebx
     d5f:	83 ec 18             	sub    $0x18,%esp
     d62:	8b 5c 24 28          	mov    0x28(%esp),%ebx
	struct conf_var *entry;

	if (value == NULL)
     d66:	85 db                	test   %ebx,%ebx
     d68:	74 41                	je     dab <var_get+0x4d>
		return -1;

	entry = var_lookup(section, name);
     d6a:	8b 44 24 24          	mov    0x24(%esp),%eax
     d6e:	89 44 24 04          	mov    %eax,0x4(%esp)
     d72:	8b 44 24 20          	mov    0x20(%esp),%eax
     d76:	89 04 24             	mov    %eax,(%esp)
     d79:	e8 fc ff ff ff       	call   d7a <var_get+0x1c>	d7a: R_386_PC32	var_lookup
	if (entry == NULL)
     d7e:	85 c0                	test   %eax,%eax
     d80:	74 30                	je     db2 <var_get+0x54>
		return -1;

	if (entry->type->t_get(entry, value))
     d82:	8b 50 04             	mov    0x4(%eax),%edx
     d85:	89 5c 24 04          	mov    %ebx,0x4(%esp)
     d89:	89 04 24             	mov    %eax,(%esp)
     d8c:	ff 52 08             	call   *0x8(%edx)
		return 0;
     d8f:	ba 00 00 00 00       	mov    $0x0,%edx

	entry = var_lookup(section, name);
	if (entry == NULL)
		return -1;

	if (entry->type->t_get(entry, value))
     d94:	85 c0                	test   %eax,%eax
     d96:	75 1f                	jne    db7 <var_get+0x59>
     d98:	a1 00 00 00 00       	mov    0x0,%eax	d99: R_386_32	.rodata
     d9d:	89 03                	mov    %eax,(%ebx)
     d9f:	0f b6 05 04 00 00 00 	movzbl 0x4,%eax	da2: R_386_32	.rodata
     da6:	88 43 04             	mov    %al,0x4(%ebx)
		return 0;
	else {
		strcpy(value, STUB_STRING);
		return 0;
     da9:	eb 0c                	jmp    db7 <var_get+0x59>
int var_get(struct conf_var *section, const char *name, char *value)
{
	struct conf_var *entry;

	if (value == NULL)
		return -1;
     dab:	ba ff ff ff ff       	mov    $0xffffffff,%edx
     db0:	eb 05                	jmp    db7 <var_get+0x59>

	entry = var_lookup(section, name);
	if (entry == NULL)
		return -1;
     db2:	ba ff ff ff ff       	mov    $0xffffffff,%edx
		strcpy(value, STUB_STRING);
		return 0;
	}

	return -1;
}
     db7:	89 d0                	mov    %edx,%eax
     db9:	83 c4 18             	add    $0x18,%esp
     dbc:	5b                   	pop    %ebx
     dbd:	c3                   	ret    

00000dbe <conf_load>:

int conf_load(const char *path, struct conf_var *root)
{
     dbe:	55                   	push   %ebp
     dbf:	57                   	push   %edi
     dc0:	56                   	push   %esi
     dc1:	53                   	push   %ebx
     dc2:	81 ec 5c 08 00 00    	sub    $0x85c,%esp
     dc8:	8b 84 24 70 08 00 00 	mov    0x870(%esp),%eax
     dcf:	89 44 24 30          	mov    %eax,0x30(%esp)
     dd3:	8b 94 24 74 08 00 00 	mov    0x874(%esp),%edx
     dda:	89 54 24 38          	mov    %edx,0x38(%esp)
     dde:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
     de4:	89 84 24 4c 08 00 00 	mov    %eax,0x84c(%esp)
     deb:	31 c0                	xor    %eax,%eax
			"int load_conf(const char *path, struct conf_var *root)\n"
			"path = %p \"%s\",\nroot = %p\n{\n",
			path, path, root);
	#endif

	if (!(f = fopen(path, "r"))) {
     ded:	c7 44 24 04 87 00 00 00 	movl   $0x87,0x4(%esp)	df1: R_386_32	.rodata.str1.1
     df5:	8b 54 24 30          	mov    0x30(%esp),%edx
     df9:	89 14 24             	mov    %edx,(%esp)
     dfc:	e8 fc ff ff ff       	call   dfd <conf_load+0x3f>	dfd: R_386_PC32	fopen
     e01:	89 44 24 28          	mov    %eax,0x28(%esp)
     e05:	85 c0                	test   %eax,%eax
     e07:	0f 84 eb 03 00 00    	je     11f8 <conf_load+0x43a>
     e0d:	8b 44 24 38          	mov    0x38(%esp),%eax
     e11:	89 44 24 3c          	mov    %eax,0x3c(%esp)
     e15:	c7 44 24 2c 00 00 00 00 	movl   $0x0,0x2c(%esp)
     e1d:	c7 44 24 20 00 00 00 00 	movl   $0x0,0x20(%esp)
     e25:	c7 44 24 34 00 00 00 00 	movl   $0x0,0x34(%esp)
     e2d:	e9 94 03 00 00       	jmp    11c6 <conf_load+0x408>
			"\tif (!(f = fopen(path, \"r\"))) {\n\t\treturn -1;\n\t};\n"
			"\tsection = root;\n\twhile (fgets(buf, 1024, f)) {\n");
	#endif
	
	while (fgets(buf, 1024, f)) {
		line++;
     e32:	83 44 24 20 01       	addl   $0x1,0x20(%esp)
		
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tcp = buf;\t(buf: %p)\n", buf);
		#endif

		LTRIM(cp);
     e37:	e8 fc ff ff ff       	call   e38 <conf_load+0x7a>	e38: R_386_PC32	__ctype_b_loc
     e3c:	89 44 24 24          	mov    %eax,0x24(%esp)
     e40:	8b 18                	mov    (%eax),%ebx
		line++;
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tline++\t(interaction#: %i)\n", line);
		#endif

		cp = buf;
     e42:	8d 54 24 4c          	lea    0x4c(%esp),%edx
		
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tcp = buf;\t(buf: %p)\n", buf);
		#endif

		LTRIM(cp);
     e46:	eb 03                	jmp    e4b <conf_load+0x8d>
     e48:	83 c2 01             	add    $0x1,%edx
     e4b:	0f b6 02             	movzbl (%edx),%eax
     e4e:	0f be c8             	movsbl %al,%ecx
     e51:	f6 44 4b 01 20       	testb  $0x20,0x1(%ebx,%ecx,2)
     e56:	74 08                	je     e60 <conf_load+0xa2>
     e58:	84 c0                	test   %al,%al
     e5a:	75 ec                	jne    e48 <conf_load+0x8a>
     e5c:	89 d6                	mov    %edx,%esi
     e5e:	eb 02                	jmp    e62 <conf_load+0xa4>
     e60:	89 d6                	mov    %edx,%esi
		RTRIM(cp);
     e62:	89 f7                	mov    %esi,%edi
     e64:	b8 00 00 00 00       	mov    $0x0,%eax
     e69:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
     e6e:	f2 ae                	repnz scas %es:(%edi),%al
     e70:	f7 d1                	not    %ecx
     e72:	8d 44 0e fe          	lea    -0x2(%esi,%ecx,1),%eax
     e76:	39 c6                	cmp    %eax,%esi
     e78:	74 1b                	je     e95 <conf_load+0xd7>
     e7a:	0f be 08             	movsbl (%eax),%ecx
     e7d:	f6 44 4b 01 20       	testb  $0x20,0x1(%ebx,%ecx,2)
     e82:	74 11                	je     e95 <conf_load+0xd7>
     e84:	83 e8 01             	sub    $0x1,%eax
     e87:	39 c6                	cmp    %eax,%esi
     e89:	74 0a                	je     e95 <conf_load+0xd7>
     e8b:	0f be 08             	movsbl (%eax),%ecx
     e8e:	f6 44 4b 01 20       	testb  $0x20,0x1(%ebx,%ecx,2)
     e93:	75 ef                	jne    e84 <conf_load+0xc6>
     e95:	c6 40 01 00          	movb   $0x0,0x1(%eax)
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tLTRIM(cp);\n\t\tRTRIM(cp);\t(cp: %p,", cp);
		fprintf(stderr," *cp: %c)\n", *cp);
		#endif

		if ((*cp == '\0') || (*cp == '#') || (*cp == ';') || (*cp == '\n'))
     e99:	0f b6 06             	movzbl (%esi),%eax
     e9c:	84 c0                	test   %al,%al
     e9e:	0f 84 22 03 00 00    	je     11c6 <conf_load+0x408>
     ea4:	3c 23                	cmp    $0x23,%al
     ea6:	0f 84 1a 03 00 00    	je     11c6 <conf_load+0x408>
     eac:	3c 3b                	cmp    $0x3b,%al
     eae:	0f 84 12 03 00 00    	je     11c6 <conf_load+0x408>
     eb4:	3c 0a                	cmp    $0xa,%al
     eb6:	0f 84 0a 03 00 00    	je     11c6 <conf_load+0x408>
			continue;

		if (*cp == '[') {
     ebc:	3c 5b                	cmp    $0x5b,%al
     ebe:	66 90                	xchg   %ax,%ax
     ec0:	0f 85 5c 01 00 00    	jne    1022 <conf_load+0x264>

			cp++;
			LTRIM(cp);
     ec6:	8d 6e 01             	lea    0x1(%esi),%ebp
     ec9:	0f b6 46 01          	movzbl 0x1(%esi),%eax
     ecd:	0f be d0             	movsbl %al,%edx
     ed0:	f6 44 53 01 20       	testb  $0x20,0x1(%ebx,%edx,2)
     ed5:	74 19                	je     ef0 <conf_load+0x132>
     ed7:	84 c0                	test   %al,%al
     ed9:	74 15                	je     ef0 <conf_load+0x132>
     edb:	83 c5 01             	add    $0x1,%ebp
     ede:	0f b6 45 00          	movzbl 0x0(%ebp),%eax
     ee2:	0f be d0             	movsbl %al,%edx
     ee5:	f6 44 53 01 20       	testb  $0x20,0x1(%ebx,%edx,2)
     eea:	74 04                	je     ef0 <conf_load+0x132>
     eec:	84 c0                	test   %al,%al
     eee:	75 eb                	jne    edb <conf_load+0x11d>

			if ((ep = strchr(cp, ']')) != NULL)
     ef0:	c7 44 24 04 5d 00 00 00 	movl   $0x5d,0x4(%esp)
     ef8:	89 2c 24             	mov    %ebp,(%esp)
     efb:	e8 fc ff ff ff       	call   efc <conf_load+0x13e>	efc: R_386_PC32	strchr
     f00:	85 c0                	test   %eax,%eax
     f02:	74 2d                	je     f31 <conf_load+0x173>
				*ep = '\0';
     f04:	c6 00 00             	movb   $0x0,(%eax)
			else {
				fprintf(stderr, "%s:%d: parse error.\n", path, line);
				ignore = 1;
				continue;
			}
			RTRIM(cp);
     f07:	89 ef                	mov    %ebp,%edi
     f09:	b8 00 00 00 00       	mov    $0x0,%eax
     f0e:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
     f13:	f2 ae                	repnz scas %es:(%edi),%al
     f15:	f7 d1                	not    %ecx
     f17:	8d 44 0d fe          	lea    -0x2(%ebp,%ecx,1),%eax
     f1b:	39 e8                	cmp    %ebp,%eax
     f1d:	74 5d                	je     f7c <conf_load+0x1be>
     f1f:	8b 54 24 24          	mov    0x24(%esp),%edx
     f23:	8b 0a                	mov    (%edx),%ecx
     f25:	0f be 10             	movsbl (%eax),%edx
     f28:	f6 44 51 01 20       	testb  $0x20,0x1(%ecx,%edx,2)
     f2d:	75 3c                	jne    f6b <conf_load+0x1ad>
     f2f:	eb 4b                	jmp    f7c <conf_load+0x1be>
     f31:	8b 44 24 20          	mov    0x20(%esp),%eax
     f35:	89 44 24 10          	mov    %eax,0x10(%esp)
     f39:	8b 54 24 30          	mov    0x30(%esp),%edx
     f3d:	89 54 24 0c          	mov    %edx,0xc(%esp)
     f41:	c7 44 24 08 89 00 00 00 	movl   $0x89,0x8(%esp)	f45: R_386_32	.rodata.str1.1
     f49:	c7 44 24 04 01 00 00 00 	movl   $0x1,0x4(%esp)
     f51:	a1 00 00 00 00       	mov    0x0,%eax	f52: R_386_32	stderr
     f56:	89 04 24             	mov    %eax,(%esp)
     f59:	e8 fc ff ff ff       	call   f5a <conf_load+0x19c>	f5a: R_386_PC32	__fprintf_chk

			if ((ep = strchr(cp, ']')) != NULL)
				*ep = '\0';
			else {
				fprintf(stderr, "%s:%d: parse error.\n", path, line);
				ignore = 1;
     f5e:	c7 44 24 2c 01 00 00 00 	movl   $0x1,0x2c(%esp)
				continue;
     f66:	e9 5b 02 00 00       	jmp    11c6 <conf_load+0x408>
			}
			RTRIM(cp);
     f6b:	83 e8 01             	sub    $0x1,%eax
     f6e:	39 e8                	cmp    %ebp,%eax
     f70:	74 0a                	je     f7c <conf_load+0x1be>
     f72:	0f be 10             	movsbl (%eax),%edx
     f75:	f6 44 51 01 20       	testb  $0x20,0x1(%ecx,%edx,2)
     f7a:	75 ef                	jne    f6b <conf_load+0x1ad>
     f7c:	c6 40 01 00          	movb   $0x0,0x1(%eax)

			/* search for a valid section entry, in the root section */
			entry = var_lookup(root, cp);
     f80:	89 6c 24 04          	mov    %ebp,0x4(%esp)
     f84:	8b 44 24 38          	mov    0x38(%esp),%eax
     f88:	89 04 24             	mov    %eax,(%esp)
     f8b:	e8 fc ff ff ff       	call   f8c <conf_load+0x1ce>	f8c: R_386_PC32	var_lookup
     f90:	89 c3                	mov    %eax,%ebx
			if (entry == NULL) {
     f92:	85 c0                	test   %eax,%eax
     f94:	75 3e                	jne    fd4 <conf_load+0x216>
     f96:	89 6c 24 14          	mov    %ebp,0x14(%esp)
     f9a:	8b 54 24 20          	mov    0x20(%esp),%edx
     f9e:	89 54 24 10          	mov    %edx,0x10(%esp)
     fa2:	8b 44 24 30          	mov    0x30(%esp),%eax
     fa6:	89 44 24 0c          	mov    %eax,0xc(%esp)
     faa:	c7 44 24 08 9e 00 00 00 	movl   $0x9e,0x8(%esp)	fae: R_386_32	.rodata.str1.1
     fb2:	c7 44 24 04 01 00 00 00 	movl   $0x1,0x4(%esp)
     fba:	a1 00 00 00 00       	mov    0x0,%eax	fbb: R_386_32	stderr
     fbf:	89 04 24             	mov    %eax,(%esp)
     fc2:	e8 fc ff ff ff       	call   fc3 <conf_load+0x205>	fc3: R_386_PC32	__fprintf_chk
				/* section not found */
				fprintf(stderr, "%s:%d: section unknown '%s'\n",
						path, line, cp);
				ignore = 1;
     fc7:	c7 44 24 2c 01 00 00 00 	movl   $0x1,0x2c(%esp)
				continue;
     fcf:	e9 f2 01 00 00       	jmp    11c6 <conf_load+0x408>
			}
			if (entry->type != CONF_TYPE(CONF_SECTION)) {
     fd4:	81 78 04 10 00 00 00 	cmpl   $0x10,0x4(%eax)	fd7: R_386_32	conf_type_tab
     fdb:	74 31                	je     100e <conf_load+0x250>
     fdd:	89 6c 24 14          	mov    %ebp,0x14(%esp)
     fe1:	8b 54 24 20          	mov    0x20(%esp),%edx
     fe5:	89 54 24 10          	mov    %edx,0x10(%esp)
     fe9:	8b 44 24 30          	mov    0x30(%esp),%eax
     fed:	89 44 24 0c          	mov    %eax,0xc(%esp)
     ff1:	c7 44 24 08 bb 00 00 00 	movl   $0xbb,0x8(%esp)	ff5: R_386_32	.rodata.str1.1
     ff9:	c7 44 24 04 01 00 00 00 	movl   $0x1,0x4(%esp)
    1001:	a1 00 00 00 00       	mov    0x0,%eax	1002: R_386_32	stderr
    1006:	89 04 24             	mov    %eax,(%esp)
    1009:	e8 fc ff ff ff       	call   100a <conf_load+0x24c>	100a: R_386_PC32	__fprintf_chk
				fprintf(stderr, "%s:%d: not a section '%s'\n", path, line,
						cp);
				ignore = 1;
			}

			section = (struct conf_var *) entry->p;
    100e:	8b 5b 08             	mov    0x8(%ebx),%ebx
    1011:	89 5c 24 3c          	mov    %ebx,0x3c(%esp)
			ignore = 0;
    1015:	c7 44 24 2c 00 00 00 00 	movl   $0x0,0x2c(%esp)
			continue;
    101d:	e9 a4 01 00 00       	jmp    11c6 <conf_load+0x408>
		}

		if (ignore)
    1022:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
    1027:	0f 85 99 01 00 00    	jne    11c6 <conf_load+0x408>

		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tfor (ap = cp; (*cp != '\\0') && (*cp != '='); cp++);"
				"\t(*cp: %c, conf.c, 255)", *cp);
		#endif
		for (ap = cp; (*cp != '\0') && (*cp != '='); cp++);
    102d:	84 c0                	test   %al,%al
    102f:	74 17                	je     1048 <conf_load+0x28a>
    1031:	3c 3d                	cmp    $0x3d,%al
    1033:	74 13                	je     1048 <conf_load+0x28a>
    1035:	89 d5                	mov    %edx,%ebp
    1037:	83 c5 01             	add    $0x1,%ebp
    103a:	0f b6 45 00          	movzbl 0x0(%ebp),%eax
    103e:	84 c0                	test   %al,%al
    1040:	74 08                	je     104a <conf_load+0x28c>
    1042:	3c 3d                	cmp    $0x3d,%al
    1044:	75 f1                	jne    1037 <conf_load+0x279>
    1046:	eb 02                	jmp    104a <conf_load+0x28c>
    1048:	89 d5                	mov    %edx,%ebp

		#ifdef _CONF_DEBUG
		fprintf(stderr,"\n\t\tif (*cp == '\\0') {...}\t(cp: %p, *cp: %c)",cp,*cp);
		#endif
		if (*cp == '\0') {
    104a:	84 c0                	test   %al,%al
    104c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    1050:	75 32                	jne    1084 <conf_load+0x2c6>
    1052:	8b 54 24 20          	mov    0x20(%esp),%edx
    1056:	89 54 24 10          	mov    %edx,0x10(%esp)
    105a:	8b 44 24 30          	mov    0x30(%esp),%eax
    105e:	89 44 24 0c          	mov    %eax,0xc(%esp)
    1062:	c7 44 24 08 89 00 00 00 	movl   $0x89,0x8(%esp)	1066: R_386_32	.rodata.str1.1
    106a:	c7 44 24 04 01 00 00 00 	movl   $0x1,0x4(%esp)
    1072:	a1 00 00 00 00       	mov    0x0,%eax	1073: R_386_32	stderr
    1077:	89 04 24             	mov    %eax,(%esp)
    107a:	e8 fc ff ff ff       	call   107b <conf_load+0x2bd>	107b: R_386_PC32	__fprintf_chk
			fprintf(stderr, "%s:%d: parse error.\n", path, line);
			continue;
    107f:	e9 42 01 00 00       	jmp    11c6 <conf_load+0x408>

		cp--;
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\n\t\tcp--\t(cp: %p)\n\t*cp = '\\0';", cp);
		#endif
		*cp = '\0';
    1084:	c6 45 ff 00          	movb   $0x0,-0x1(%ebp)
		cp++;
		cp++;
    1088:	83 c5 01             	add    $0x1,%ebp
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\n\t\tcp++;\n\tcp++;\t(cp: %p)\n", cp);
		#endif


		LTRIM(ap);
    108b:	0f b6 0e             	movzbl (%esi),%ecx
    108e:	0f be f1             	movsbl %cl,%esi
    1091:	89 d0                	mov    %edx,%eax
    1093:	f6 44 73 01 20       	testb  $0x20,0x1(%ebx,%esi,2)
    1098:	74 18                	je     10b2 <conf_load+0x2f4>
    109a:	84 c9                	test   %cl,%cl
    109c:	74 14                	je     10b2 <conf_load+0x2f4>
    109e:	83 c0 01             	add    $0x1,%eax
    10a1:	0f b6 10             	movzbl (%eax),%edx
    10a4:	0f be ca             	movsbl %dl,%ecx
    10a7:	f6 44 4b 01 20       	testb  $0x20,0x1(%ebx,%ecx,2)
    10ac:	74 04                	je     10b2 <conf_load+0x2f4>
    10ae:	84 d2                	test   %dl,%dl
    10b0:	75 ec                	jne    109e <conf_load+0x2e0>
    10b2:	c7 44 24 08 00 02 00 00 	movl   $0x200,0x8(%esp)
    10ba:	89 44 24 04          	mov    %eax,0x4(%esp)
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tLTRIM(ap);\t(ap: %p, *ap: %c)\n", ap, *ap);
		#endif
		strcpy(name, ap);
    10be:	8d 94 24 4c 04 00 00 	lea    0x44c(%esp),%edx
    10c5:	89 14 24             	mov    %edx,(%esp)
    10c8:	e8 fc ff ff ff       	call   10c9 <conf_load+0x30b>	10c9: R_386_PC32	__strcpy_chk
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tstrcpy(name, ap);\t(ap[]: %s\n", ap);
		#endif

		RTRIM(cp);
    10cd:	89 ef                	mov    %ebp,%edi
    10cf:	b8 00 00 00 00       	mov    $0x0,%eax
    10d4:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
    10d9:	f2 ae                	repnz scas %es:(%edi),%al
    10db:	f7 d1                	not    %ecx
    10dd:	8d 44 0d fe          	lea    -0x2(%ebp,%ecx,1),%eax
    10e1:	39 c5                	cmp    %eax,%ebp
    10e3:	74 21                	je     1106 <conf_load+0x348>
    10e5:	8b 54 24 24          	mov    0x24(%esp),%edx
    10e9:	8b 0a                	mov    (%edx),%ecx
    10eb:	0f be 10             	movsbl (%eax),%edx
    10ee:	f6 44 51 01 20       	testb  $0x20,0x1(%ecx,%edx,2)
    10f3:	74 11                	je     1106 <conf_load+0x348>
    10f5:	83 e8 01             	sub    $0x1,%eax
    10f8:	39 c5                	cmp    %eax,%ebp
    10fa:	74 0a                	je     1106 <conf_load+0x348>
    10fc:	0f be 10             	movsbl (%eax),%edx
    10ff:	f6 44 51 01 20       	testb  $0x20,0x1(%ecx,%edx,2)
    1104:	75 ef                	jne    10f5 <conf_load+0x337>
    1106:	c6 40 01 00          	movb   $0x0,0x1(%eax)
    110a:	c7 44 24 08 00 02 00 00 	movl   $0x200,0x8(%esp)
    1112:	89 6c 24 04          	mov    %ebp,0x4(%esp)
		strcpy(value, cp);
    1116:	8d 84 24 4c 06 00 00 	lea    0x64c(%esp),%eax
    111d:	89 04 24             	mov    %eax,(%esp)
    1120:	e8 fc ff ff ff       	call   1121 <conf_load+0x363>	1121: R_386_PC32	__strcpy_chk
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tRTRIM(cp);\n\t\tstrcpy(value, cp);\t(cp[]: %s)\n",cp);
		#endif

		entry = var_lookup(section, name);
    1125:	8d 84 24 4c 04 00 00 	lea    0x44c(%esp),%eax
    112c:	89 44 24 04          	mov    %eax,0x4(%esp)
    1130:	8b 54 24 3c          	mov    0x3c(%esp),%edx
    1134:	89 14 24             	mov    %edx,(%esp)
    1137:	e8 fc ff ff ff       	call   1138 <conf_load+0x37a>	1138: R_386_PC32	var_lookup
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tentry = var_lookup(section, name);\n");
		#endif

		if (entry == NULL) {
    113c:	85 c0                	test   %eax,%eax
    113e:	75 3a                	jne    117a <conf_load+0x3bc>
			fprintf(stderr, "%s:%d: symbol unknown '%s'\n", path, line, name);
    1140:	8d 84 24 4c 04 00 00 	lea    0x44c(%esp),%eax
    1147:	89 44 24 14          	mov    %eax,0x14(%esp)
    114b:	8b 54 24 20          	mov    0x20(%esp),%edx
    114f:	89 54 24 10          	mov    %edx,0x10(%esp)
    1153:	8b 44 24 30          	mov    0x30(%esp),%eax
    1157:	89 44 24 0c          	mov    %eax,0xc(%esp)
    115b:	c7 44 24 08 d6 00 00 00 	movl   $0xd6,0x8(%esp)	115f: R_386_32	.rodata.str1.1
    1163:	c7 44 24 04 01 00 00 00 	movl   $0x1,0x4(%esp)
    116b:	a1 00 00 00 00       	mov    0x0,%eax	116c: R_386_32	stderr
    1170:	89 04 24             	mov    %eax,(%esp)
    1173:	e8 fc ff ff ff       	call   1174 <conf_load+0x3b6>	1174: R_386_PC32	__fprintf_chk
			continue;
    1178:	eb 4c                	jmp    11c6 <conf_load+0x408>
		fprintf(stderr,"(entry: %p, entry->type: %p, entry->type->t_set: %p,"
				" value[]: %s)\n", entry, entry->type, entry->type->t_set, value);
		#endif

		/* set the variable */
		if (entry->type->t_set(entry, value))
    117a:	8b 50 04             	mov    0x4(%eax),%edx
    117d:	8d 8c 24 4c 06 00 00 	lea    0x64c(%esp),%ecx
    1184:	89 4c 24 04          	mov    %ecx,0x4(%esp)
    1188:	89 04 24             	mov    %eax,(%esp)
    118b:	ff 52 0c             	call   *0xc(%edx)
    118e:	85 c0                	test   %eax,%eax
    1190:	74 07                	je     1199 <conf_load+0x3db>
			count++;
    1192:	83 44 24 34 01       	addl   $0x1,0x34(%esp)
    1197:	eb 2d                	jmp    11c6 <conf_load+0x408>
    1199:	8b 54 24 20          	mov    0x20(%esp),%edx
    119d:	89 54 24 10          	mov    %edx,0x10(%esp)
    11a1:	8b 44 24 30          	mov    0x30(%esp),%eax
    11a5:	89 44 24 0c          	mov    %eax,0xc(%esp)
    11a9:	c7 44 24 08 89 00 00 00 	movl   $0x89,0x8(%esp)	11ad: R_386_32	.rodata.str1.1
    11b1:	c7 44 24 04 01 00 00 00 	movl   $0x1,0x4(%esp)
    11b9:	a1 00 00 00 00       	mov    0x0,%eax	11ba: R_386_32	stderr
    11be:	89 04 24             	mov    %eax,(%esp)
    11c1:	e8 fc ff ff ff       	call   11c2 <conf_load+0x404>	11c2: R_386_PC32	__fprintf_chk
	return __fgets_chk (__s, __bos (__s), __n, __stream);

      if ((size_t) __n > __bos (__s))
	return __fgets_chk_warn (__s, __bos (__s), __n, __stream);
    }
  return __fgets_alias (__s, __n, __stream);
    11c6:	8b 44 24 28          	mov    0x28(%esp),%eax
    11ca:	89 44 24 08          	mov    %eax,0x8(%esp)
    11ce:	c7 44 24 04 00 04 00 00 	movl   $0x400,0x4(%esp)
	fprintf(stderr,
			"\tif (!(f = fopen(path, \"r\"))) {\n\t\treturn -1;\n\t};\n"
			"\tsection = root;\n\twhile (fgets(buf, 1024, f)) {\n");
	#endif
	
	while (fgets(buf, 1024, f)) {
    11d6:	8d 54 24 4c          	lea    0x4c(%esp),%edx
    11da:	89 14 24             	mov    %edx,(%esp)
    11dd:	e8 fc ff ff ff       	call   11de <conf_load+0x420>	11de: R_386_PC32	fgets
    11e2:	85 c0                	test   %eax,%eax
    11e4:	0f 85 48 fc ff ff    	jne    e32 <conf_load+0x74>
			fprintf(stderr, "%s:%d: parse error.\n", path, line);
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tif (entry->type->t_set(entry, value))\n");
		#endif
	}
	fclose(f);
    11ea:	8b 44 24 28          	mov    0x28(%esp),%eax
    11ee:	89 04 24             	mov    %eax,(%esp)
    11f1:	e8 fc ff ff ff       	call   11f2 <conf_load+0x434>	11f2: R_386_PC32	fclose

	return count;
    11f6:	eb 08                	jmp    1200 <conf_load+0x442>
			"path = %p \"%s\",\nroot = %p\n{\n",
			path, path, root);
	#endif

	if (!(f = fopen(path, "r"))) {
		return -1;
    11f8:	c7 44 24 34 ff ff ff ff 	movl   $0xffffffff,0x34(%esp)
		#endif
	}
	fclose(f);

	return count;
}
    1200:	8b 44 24 34          	mov    0x34(%esp),%eax
    1204:	8b 94 24 4c 08 00 00 	mov    0x84c(%esp),%edx
    120b:	65 33 15 14 00 00 00 	xor    %gs:0x14,%edx
    1212:	74 05                	je     1219 <conf_load+0x45b>
    1214:	e8 fc ff ff ff       	call   1215 <conf_load+0x457>	1215: R_386_PC32	__stack_chk_fail
    1219:	81 c4 5c 08 00 00    	add    $0x85c,%esp
    121f:	5b                   	pop    %ebx
    1220:	5e                   	pop    %esi
    1221:	5f                   	pop    %edi
    1222:	5d                   	pop    %ebp
    1223:	c3                   	ret    

00001224 <conf_save>:

	return count;
}

int conf_save(const char *path, struct conf_var *root)
{
    1224:	83 ec 1c             	sub    $0x1c,%esp
    1227:	89 5c 24 14          	mov    %ebx,0x14(%esp)
    122b:	89 74 24 18          	mov    %esi,0x18(%esp)
	FILE *f;
	int count;

	if (!(f = fopen(path, "w+"))) {
    122f:	c7 44 24 04 f2 00 00 00 	movl   $0xf2,0x4(%esp)	1233: R_386_32	.rodata.str1.1
    1237:	8b 44 24 20          	mov    0x20(%esp),%eax
    123b:	89 04 24             	mov    %eax,(%esp)
    123e:	e8 fc ff ff ff       	call   123f <conf_save+0x1b>	123f: R_386_PC32	fopen
    1243:	89 c3                	mov    %eax,%ebx
    1245:	85 c0                	test   %eax,%eax
    1247:	74 1a                	je     1263 <conf_save+0x3f>
		return -1;
	};

	count = write_section(f, root, NULL);
    1249:	b9 00 00 00 00       	mov    $0x0,%ecx
    124e:	8b 54 24 24          	mov    0x24(%esp),%edx
    1252:	e8 93 f8 ff ff       	call   aea <write_section>
    1257:	89 c6                	mov    %eax,%esi

	fclose(f);
    1259:	89 1c 24             	mov    %ebx,(%esp)
    125c:	e8 fc ff ff ff       	call   125d <conf_save+0x39>	125d: R_386_PC32	fclose

	return count;
    1261:	eb 05                	jmp    1268 <conf_save+0x44>
{
	FILE *f;
	int count;

	if (!(f = fopen(path, "w+"))) {
		return -1;
    1263:	be ff ff ff ff       	mov    $0xffffffff,%esi
	count = write_section(f, root, NULL);

	fclose(f);

	return count;
}
    1268:	89 f0                	mov    %esi,%eax
    126a:	8b 5c 24 14          	mov    0x14(%esp),%ebx
    126e:	8b 74 24 18          	mov    0x18(%esp),%esi
    1272:	83 c4 1c             	add    $0x1c,%esp
    1275:	c3                   	ret    

00001276 <conf_dump>:

int conf_dump(struct conf_var *root)
{
    1276:	83 ec 0c             	sub    $0xc,%esp
	return write_section(stdout, root, NULL);
    1279:	b9 00 00 00 00       	mov    $0x0,%ecx
    127e:	8b 54 24 10          	mov    0x10(%esp),%edx
    1282:	a1 00 00 00 00       	mov    0x0,%eax	1283: R_386_32	stdout
    1287:	e8 5e f8 ff ff       	call   aea <write_section>
}
    128c:	83 c4 0c             	add    $0xc,%esp
    128f:	c3                   	ret    

00001290 <ipaddr_get>:
int ipaddr_get(struct conf_var *var, char *s)
{
	s = "";

	return 0;
}
    1290:	b8 00 00 00 00       	mov    $0x0,%eax
    1295:	c3                   	ret    

00001296 <ipaddr_set>:

int ipaddr_set(struct conf_var *var, const char *s)
{
    1296:	53                   	push   %ebx
    1297:	83 ec 18             	sub    $0x18,%esp
    129a:	8b 5c 24 20          	mov    0x20(%esp),%ebx
	if (var->p == NULL) {
    129e:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
    12a2:	75 0f                	jne    12b3 <ipaddr_set+0x1d>
		var->p = malloc(sizeof(unsigned int));
    12a4:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
    12ab:	e8 fc ff ff ff       	call   12ac <ipaddr_set+0x16>	12ac: R_386_PC32	malloc
    12b0:	89 43 08             	mov    %eax,0x8(%ebx)
	}

	return 0;
}
    12b3:	b8 00 00 00 00       	mov    $0x0,%eax
    12b8:	83 c4 18             	add    $0x18,%esp
    12bb:	5b                   	pop    %ebx
    12bc:	c3                   	ret    

000012bd <ipport_get>:
int ipport_get(struct conf_var *var, char *s)
{
	s = "";

	return 0;
}
    12bd:	b8 00 00 00 00       	mov    $0x0,%eax
    12c2:	c3                   	ret    

000012c3 <ipport_set>:

int ipport_set(struct conf_var *var, const char *s)
{
    12c3:	53                   	push   %ebx
    12c4:	83 ec 18             	sub    $0x18,%esp
    12c7:	8b 5c 24 20          	mov    0x20(%esp),%ebx
	if (var->p == NULL) {
    12cb:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
    12cf:	75 0f                	jne    12e0 <ipport_set+0x1d>
		var->p = malloc(sizeof(unsigned int));
    12d1:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
    12d8:	e8 fc ff ff ff       	call   12d9 <ipport_set+0x16>	12d9: R_386_PC32	malloc
    12dd:	89 43 08             	mov    %eax,0x8(%ebx)
	}

	return 0;
}
    12e0:	b8 00 00 00 00       	mov    $0x0,%eax
    12e5:	83 c4 18             	add    $0x18,%esp
    12e8:	5b                   	pop    %ebx
    12e9:	c3                   	ret    

Disassembly of section .data:

00000000 <conf_type_tab>:
   0:	00 00                	add    %al,(%eax)
   2:	00 00                	add    %al,(%eax)
   4:	f5                   	cmc    	4: R_386_32	.rodata.str1.1
   5:	00 00                	add    %al,(%eax)
   7:	00 00                	add    %al,(%eax)	8: R_386_32	void_get
   9:	00 00                	add    %al,(%eax)
   b:	00 00                	add    %al,(%eax)	c: R_386_32	void_set
   d:	00 00                	add    %al,(%eax)
   f:	00 01                	add    %al,(%ecx)
  11:	00 00                	add    %al,(%eax)
  13:	00 fa                	add    %bh,%dl	14: R_386_32	.rodata.str1.1
  15:	00 00                	add    %al,(%eax)
  17:	00 00                	add    %al,(%eax)	18: R_386_32	void_get
  19:	00 00                	add    %al,(%eax)
  1b:	00 00                	add    %al,(%eax)	1c: R_386_32	void_set
  1d:	00 00                	add    %al,(%eax)
  1f:	00 02                	add    %al,(%edx)
  21:	00 00                	add    %al,(%eax)
  23:	00 02                	add    %al,(%edx)	24: R_386_32	.rodata.str1.1
  25:	01 00                	add    %eax,(%eax)
  27:	00 00                	add    %al,(%eax)	28: R_386_32	int_get
  29:	00 00                	add    %al,(%eax)
  2b:	00 00                	add    %al,(%eax)	2c: R_386_32	int_set
  2d:	00 00                	add    %al,(%eax)
  2f:	00 03                	add    %al,(%ebx)
  31:	00 00                	add    %al,(%eax)
  33:	00 0a                	add    %cl,(%edx)	34: R_386_32	.rodata.str1.1
  35:	01 00                	add    %eax,(%eax)
  37:	00 00                	add    %al,(%eax)	38: R_386_32	uint_get
  39:	00 00                	add    %al,(%eax)
  3b:	00 00                	add    %al,(%eax)	3c: R_386_32	uint_set
  3d:	00 00                	add    %al,(%eax)
  3f:	00 04 00             	add    %al,(%eax,%eax,1)
  42:	00 00                	add    %al,(%eax)
  44:	13 01                	adc    (%ecx),%eax	44: R_386_32	.rodata.str1.1
  46:	00 00                	add    %al,(%eax)
  48:	00 00                	add    %al,(%eax)	48: R_386_32	float_get
  4a:	00 00                	add    %al,(%eax)
  4c:	00 00                	add    %al,(%eax)	4c: R_386_32	float_set
  4e:	00 00                	add    %al,(%eax)
  50:	05 00 00 00 19       	add    $0x19000000,%eax	54: R_386_32	.rodata.str1.1
  55:	01 00                	add    %eax,(%eax)
  57:	00 00                	add    %al,(%eax)	58: R_386_32	string_get
  59:	00 00                	add    %al,(%eax)
  5b:	00 00                	add    %al,(%eax)	5c: R_386_32	string_set
  5d:	00 00                	add    %al,(%eax)
  5f:	00 06                	add    %al,(%esi)
  61:	00 00                	add    %al,(%eax)
  63:	00 20                	add    %ah,(%eax)	64: R_386_32	.rodata.str1.1
  65:	01 00                	add    %eax,(%eax)
  67:	00 00                	add    %al,(%eax)	68: R_386_32	bool_get
  69:	00 00                	add    %al,(%eax)
  6b:	00 00                	add    %al,(%eax)	6c: R_386_32	bool_set
  6d:	00 00                	add    %al,(%eax)
  6f:	00 07                	add    %al,(%edi)
  71:	00 00                	add    %al,(%eax)
  73:	00 28                	add    %ch,(%eax)	74: R_386_32	.rodata.str1.1
  75:	01 00                	add    %eax,(%eax)
  77:	00 00                	add    %al,(%eax)	78: R_386_32	char_get
  79:	00 00                	add    %al,(%eax)
  7b:	00 00                	add    %al,(%eax)	7c: R_386_32	char_set
  7d:	00 00                	add    %al,(%eax)
  7f:	00 08                	add    %cl,(%eax)
  81:	00 00                	add    %al,(%eax)
  83:	00 2d 01 00 00 00    	add    %ch,0x1	84: R_386_32	.rodata.str1.1
	88: R_386_32	hex8_get
  89:	00 00                	add    %al,(%eax)
  8b:	00 00                	add    %al,(%eax)	8c: R_386_32	hex8_set
  8d:	00 00                	add    %al,(%eax)
  8f:	00 09                	add    %cl,(%ecx)
  91:	00 00                	add    %al,(%eax)
  93:	00 33                	add    %dh,(%ebx)	94: R_386_32	.rodata.str1.1
  95:	01 00                	add    %eax,(%eax)
  97:	00 00                	add    %al,(%eax)	98: R_386_32	hex16_get
  99:	00 00                	add    %al,(%eax)
  9b:	00 00                	add    %al,(%eax)	9c: R_386_32	hex16_set
  9d:	00 00                	add    %al,(%eax)
  9f:	00 0a                	add    %cl,(%edx)
  a1:	00 00                	add    %al,(%eax)
  a3:	00 3a                	add    %bh,(%edx)	a4: R_386_32	.rodata.str1.1
  a5:	01 00                	add    %eax,(%eax)
  a7:	00 00                	add    %al,(%eax)	a8: R_386_32	hex32_get
  a9:	00 00                	add    %al,(%eax)
  ab:	00 00                	add    %al,(%eax)	ac: R_386_32	hex32_set
  ad:	00 00                	add    %al,(%eax)
  af:	00 0b                	add    %cl,(%ebx)
  b1:	00 00                	add    %al,(%eax)
  b3:	00 41 01             	add    %al,0x1(%ecx)	b4: R_386_32	.rodata.str1.1
  b6:	00 00                	add    %al,(%eax)
  b8:	00 00                	add    %al,(%eax)	b8: R_386_32	hex64_get
  ba:	00 00                	add    %al,(%eax)
  bc:	00 00                	add    %al,(%eax)	bc: R_386_32	hex64_set
  be:	00 00                	add    %al,(%eax)
  c0:	0c 00                	or     $0x0,%al
  c2:	00 00                	add    %al,(%eax)
  c4:	48                   	dec    %eax	c4: R_386_32	.rodata.str1.1
  c5:	01 00                	add    %eax,(%eax)
  c7:	00 00                	add    %al,(%eax)	c8: R_386_32	bin8_get
  c9:	00 00                	add    %al,(%eax)
  cb:	00 00                	add    %al,(%eax)	cc: R_386_32	bin8_set
  cd:	00 00                	add    %al,(%eax)
  cf:	00 0d 00 00 00 51    	add    %cl,0x51000000	d4: R_386_32	.rodata.str1.1
  d5:	01 00                	add    %eax,(%eax)
  d7:	00 00                	add    %al,(%eax)	d8: R_386_32	bin16_get
  d9:	00 00                	add    %al,(%eax)
  db:	00 00                	add    %al,(%eax)	dc: R_386_32	bin16_set
  dd:	00 00                	add    %al,(%eax)
  df:	00 0e                	add    %cl,(%esi)
  e1:	00 00                	add    %al,(%eax)
  e3:	00 5b 01             	add    %bl,0x1(%ebx)	e4: R_386_32	.rodata.str1.1
  e6:	00 00                	add    %al,(%eax)
  e8:	00 00                	add    %al,(%eax)	e8: R_386_32	bin32_get
  ea:	00 00                	add    %al,(%eax)
  ec:	00 00                	add    %al,(%eax)	ec: R_386_32	bin32_set
  ee:	00 00                	add    %al,(%eax)
  f0:	0f 00 00             	sldt   (%eax)
  f3:	00 65 01             	add    %ah,0x1(%ebp)	f4: R_386_32	.rodata.str1.1
  f6:	00 00                	add    %al,(%eax)
  f8:	00 00                	add    %al,(%eax)	f8: R_386_32	bin64_get
  fa:	00 00                	add    %al,(%eax)
  fc:	00 00                	add    %al,(%eax)	fc: R_386_32	bin64_set
  fe:	00 00                	add    %al,(%eax)
 100:	10 00                	adc    %al,(%eax)
 102:	00 00                	add    %al,(%eax)
 104:	6f                   	outsl  %ds:(%esi),(%dx)	104: R_386_32	.rodata.str1.1
 105:	01 00                	add    %eax,(%eax)
 107:	00 00                	add    %al,(%eax)	108: R_386_32	oct8_get
 109:	00 00                	add    %al,(%eax)
 10b:	00 00                	add    %al,(%eax)	10c: R_386_32	oct8_set
 10d:	00 00                	add    %al,(%eax)
 10f:	00 11                	add    %dl,(%ecx)
 111:	00 00                	add    %al,(%eax)
 113:	00 77 01             	add    %dh,0x1(%edi)	114: R_386_32	.rodata.str1.1
 116:	00 00                	add    %al,(%eax)
 118:	00 00                	add    %al,(%eax)	118: R_386_32	oct16_get
 11a:	00 00                	add    %al,(%eax)
 11c:	00 00                	add    %al,(%eax)	11c: R_386_32	oct16_set
 11e:	00 00                	add    %al,(%eax)
 120:	12 00                	adc    (%eax),%al
 122:	00 00                	add    %al,(%eax)
 124:	80 01 00             	addb   $0x0,(%ecx)	124: R_386_32	.rodata.str1.1
 127:	00 00                	add    %al,(%eax)	128: R_386_32	oct32_get
 129:	00 00                	add    %al,(%eax)
 12b:	00 00                	add    %al,(%eax)	12c: R_386_32	oct32_set
 12d:	00 00                	add    %al,(%eax)
 12f:	00 13                	add    %dl,(%ebx)
 131:	00 00                	add    %al,(%eax)
 133:	00 89 01 00 00 00    	add    %cl,0x1(%ecx)	134: R_386_32	.rodata.str1.1
	138: R_386_32	oct64_get
 139:	00 00                	add    %al,(%eax)
 13b:	00 00                	add    %al,(%eax)	13c: R_386_32	oct64_set
 13d:	00 00                	add    %al,(%eax)
 13f:	00 14 00             	add    %dl,(%eax,%eax,1)
 142:	00 00                	add    %al,(%eax)
 144:	92                   	xchg   %eax,%edx	144: R_386_32	.rodata.str1.1
 145:	01 00                	add    %eax,(%eax)
 147:	00 00                	add    %al,(%eax)	148: R_386_32	string_get
 149:	00 00                	add    %al,(%eax)
 14b:	00 00                	add    %al,(%eax)	14c: R_386_32	string_set
 14d:	00 00                	add    %al,(%eax)
 14f:	00 15 00 00 00 9d    	add    %dl,0x9d000000	154: R_386_32	.rodata.str1.1
 155:	01 00                	add    %eax,(%eax)
 157:	00 00                	add    %al,(%eax)	158: R_386_32	rgb_get
 159:	00 00                	add    %al,(%eax)
 15b:	00 00                	add    %al,(%eax)	15c: R_386_32	rgb_set
 15d:	00 00                	add    %al,(%eax)
 15f:	00 16                	add    %dl,(%esi)
 161:	00 00                	add    %al,(%eax)
 163:	00 a1 01 00 00 00    	add    %ah,0x1(%ecx)	164: R_386_32	.rodata.str1.1
	168: R_386_32	rgbi_get
 169:	00 00                	add    %al,(%eax)
 16b:	00 00                	add    %al,(%eax)	16c: R_386_32	rgbi_set
 16d:	00 00                	add    %al,(%eax)
 16f:	00 17                	add    %dl,(%edi)
 171:	00 00                	add    %al,(%eax)
 173:	00 a6 01 00 00 00    	add    %ah,0x1(%esi)	174: R_386_32	.rodata.str1.1
	178: R_386_32	cymk_get
 179:	00 00                	add    %al,(%eax)
 17b:	00 00                	add    %al,(%eax)	17c: R_386_32	cymk_set
 17d:	00 00                	add    %al,(%eax)
 17f:	00 18                	add    %bl,(%eax)
 181:	00 00                	add    %al,(%eax)
 183:	00 ab 01 00 00 00    	add    %ch,0x1(%ebx)	184: R_386_32	.rodata.str1.1
	188: R_386_32	ratio_get
 189:	00 00                	add    %al,(%eax)
 18b:	00 00                	add    %al,(%eax)	18c: R_386_32	ratio_set
 18d:	00 00                	add    %al,(%eax)
 18f:	00 1a                	add    %bl,(%edx)
 191:	00 00                	add    %al,(%eax)
 193:	00 b1 01 00 00 00    	add    %dh,0x1(%ecx)	194: R_386_32	.rodata.str1.1
	198: R_386_32	string_get
 199:	00 00                	add    %al,(%eax)
 19b:	00 00                	add    %al,(%eax)	19c: R_386_32	string_set
 19d:	00 00                	add    %al,(%eax)
 19f:	00                   	.byte 0x0

Disassembly of section .rodata.str1.1:

00000000 <.rodata.str1.1>:
   0:	25 70 00 25 69       	and    $0x69250070,%eax
   5:	00 25 75 00 25 66    	add    %ah,0x66250075
   b:	00 22                	add    %ah,(%edx)
   d:	25 73 22 00 25       	and    $0x25002273,%eax
  12:	63 00                	arpl   %ax,(%eax)
  14:	30 78 25             	xor    %bh,0x25(%eax)
  17:	30 32                	xor    %dh,(%edx)
  19:	58                   	pop    %eax
  1a:	00 30                	add    %dh,(%eax)
  1c:	78 25                	js     43 <.rodata.str1.1+0x43>
  1e:	30 34 58             	xor    %dh,(%eax,%ebx,2)
  21:	00 30                	add    %dh,(%eax)
  23:	78 25                	js     4a <.rodata.str1.1+0x4a>
  25:	30 38                	xor    %bh,(%eax)
  27:	58                   	pop    %eax
  28:	00 30                	add    %dh,(%eax)
  2a:	78 25                	js     51 <.rodata.str1.1+0x51>
  2c:	30 31                	xor    %dh,(%ecx)
  2e:	36                   	ss
  2f:	6c                   	insb   (%dx),%es:(%edi)
  30:	6c                   	insb   (%dx),%es:(%edi)
  31:	58                   	pop    %eax
  32:	00 25 6c 6c 58 00    	add    %ah,0x586c6c
  38:	25 58 00 25 6c       	and    $0x6c250058,%eax
  3d:	66                   	data16
  3e:	00 54 52 55          	add    %dl,0x55(%edx,%edx,2)
  42:	45                   	inc    %ebp
  43:	00 59 45             	add    %bl,0x45(%ecx)
  46:	53                   	push   %ebx
  47:	00 4f 4e             	add    %cl,0x4e(%edi)
  4a:	00 31                	add    %dh,(%ecx)
  4c:	00 46 41             	add    %al,0x41(%esi)
  4f:	4c                   	dec    %esp
  50:	53                   	push   %ebx
  51:	45                   	inc    %ebp
  52:	00 4e 4f             	add    %cl,0x4f(%esi)
  55:	00 4f 46             	add    %cl,0x46(%edi)
  58:	46                   	inc    %esi
  59:	00 30                	add    %dh,(%eax)
  5b:	00 55 6e             	add    %dl,0x6e(%ebp)
  5e:	74 65                	je     c5 <.rodata.str1.1+0xc5>
  60:	72 6d                	jb     cf <.rodata.str1.1+0xcf>
  62:	69 6e 61 74 65 64 20 	imul   $0x20646574,0x61(%esi),%ebp
  69:	73 74                	jae    df <.rodata.str1.1+0xdf>
  6b:	72 69                	jb     d6 <.rodata.str1.1+0xd6>
  6d:	6e                   	outsb  %ds:(%esi),(%dx)
  6e:	67 2e 0a 00          	or     %cs:(%bx,%si),%al
  72:	25 73 20 3d 20       	and    $0x203d2073,%eax
  77:	25 73 0a 00 25       	and    $0x25000a73,%eax
  7c:	73 2f                	jae    ad <.rodata.str1.1+0xad>
  7e:	25 73 00 5b 25       	and    $0x255b0073,%eax
  83:	73 5d                	jae    e2 <.rodata.str1.1+0xe2>
  85:	0a 00                	or     (%eax),%al
  87:	72 00                	jb     89 <.rodata.str1.1+0x89>
  89:	25 73 3a 25 64       	and    $0x64253a73,%eax
  8e:	3a 20                	cmp    (%eax),%ah
  90:	70 61                	jo     f3 <.rodata.str1.1+0xf3>
  92:	72 73                	jb     107 <.rodata.str1.1+0x107>
  94:	65 20 65 72          	and    %ah,%gs:0x72(%ebp)
  98:	72 6f                	jb     109 <.rodata.str1.1+0x109>
  9a:	72 2e                	jb     ca <.rodata.str1.1+0xca>
  9c:	0a 00                	or     (%eax),%al
  9e:	25 73 3a 25 64       	and    $0x64253a73,%eax
  a3:	3a 20                	cmp    (%eax),%ah
  a5:	73 65                	jae    10c <.rodata.str1.1+0x10c>
  a7:	63 74 69 6f          	arpl   %si,0x6f(%ecx,%ebp,2)
  ab:	6e                   	outsb  %ds:(%esi),(%dx)
  ac:	20 75 6e             	and    %dh,0x6e(%ebp)
  af:	6b 6e 6f 77          	imul   $0x77,0x6f(%esi),%ebp
  b3:	6e                   	outsb  %ds:(%esi),(%dx)
  b4:	20 27                	and    %ah,(%edi)
  b6:	25 73 27 0a 00       	and    $0xa2773,%eax
  bb:	25 73 3a 25 64       	and    $0x64253a73,%eax
  c0:	3a 20                	cmp    (%eax),%ah
  c2:	6e                   	outsb  %ds:(%esi),(%dx)
  c3:	6f                   	outsl  %ds:(%esi),(%dx)
  c4:	74 20                	je     e6 <.rodata.str1.1+0xe6>
  c6:	61                   	popa   
  c7:	20 73 65             	and    %dh,0x65(%ebx)
  ca:	63 74 69 6f          	arpl   %si,0x6f(%ecx,%ebp,2)
  ce:	6e                   	outsb  %ds:(%esi),(%dx)
  cf:	20 27                	and    %ah,(%edi)
  d1:	25 73 27 0a 00       	and    $0xa2773,%eax
  d6:	25 73 3a 25 64       	and    $0x64253a73,%eax
  db:	3a 20                	cmp    (%eax),%ah
  dd:	73 79                	jae    158 <.rodata.str1.1+0x158>
  df:	6d                   	insl   (%dx),%es:(%edi)
  e0:	62 6f 6c             	bound  %ebp,0x6c(%edi)
  e3:	20 75 6e             	and    %dh,0x6e(%ebp)
  e6:	6b 6e 6f 77          	imul   $0x77,0x6f(%esi),%ebp
  ea:	6e                   	outsb  %ds:(%esi),(%dx)
  eb:	20 27                	and    %ah,(%edi)
  ed:	25 73 27 0a 00       	and    $0xa2773,%eax
  f2:	77 2b                	ja     11f <.rodata.str1.1+0x11f>
  f4:	00 76 6f             	add    %dh,0x6f(%esi)
  f7:	69 64 00 73 65 63 74 69 	imul   $0x69746365,0x73(%eax,%eax,1),%esp
  ff:	6f                   	outsl  %ds:(%esi),(%dx)
 100:	6e                   	outsb  %ds:(%esi),(%dx)
 101:	00 69 6e             	add    %ch,0x6e(%ecx)
 104:	74 65                	je     16b <.rodata.str1.1+0x16b>
 106:	67                   	addr16
 107:	65                   	gs
 108:	72 00                	jb     10a <.rodata.str1.1+0x10a>
 10a:	75 6e                	jne    17a <.rodata.str1.1+0x17a>
 10c:	73 69                	jae    177 <.rodata.str1.1+0x177>
 10e:	67 6e                	outsb  %ds:(%si),(%dx)
 110:	65 64 00 66 6c       	gs add %ah,%fs:%gs:0x6c(%esi)
 115:	6f                   	outsl  %ds:(%esi),(%dx)
 116:	61                   	popa   
 117:	74 00                	je     119 <.rodata.str1.1+0x119>
 119:	73 74                	jae    18f <.rodata.str1.1+0x18f>
 11b:	72 69                	jb     186 <.rodata.str1.1+0x186>
 11d:	6e                   	outsb  %ds:(%esi),(%dx)
 11e:	67 00 62 6f          	add    %ah,0x6f(%bp,%si)
 122:	6f                   	outsl  %ds:(%esi),(%dx)
 123:	6c                   	insb   (%dx),%es:(%edi)
 124:	65                   	gs
 125:	61                   	popa   
 126:	6e                   	outsb  %ds:(%esi),(%dx)
 127:	00 63 68             	add    %ah,0x68(%ebx)
 12a:	61                   	popa   
 12b:	72 00                	jb     12d <.rodata.str1.1+0x12d>
 12d:	68 65 78 5f 38       	push   $0x385f7865
 132:	00 68 65             	add    %ch,0x65(%eax)
 135:	78 5f                	js     196 <.rodata.str1.1+0x196>
 137:	31 36                	xor    %esi,(%esi)
 139:	00 68 65             	add    %ch,0x65(%eax)
 13c:	78 5f                	js     19d <.rodata.str1.1+0x19d>
 13e:	33 32                	xor    (%edx),%esi
 140:	00 68 65             	add    %ch,0x65(%eax)
 143:	78 5f                	js     1a4 <.rodata.str1.1+0x1a4>
 145:	36                   	ss
 146:	34 00                	xor    $0x0,%al
 148:	62 69 6e             	bound  %ebp,0x6e(%ecx)
 14b:	61                   	popa   
 14c:	72 79                	jb     1c7 <bin8_set+0xe>
 14e:	5f                   	pop    %edi
 14f:	38 00                	cmp    %al,(%eax)
 151:	62 69 6e             	bound  %ebp,0x6e(%ecx)
 154:	61                   	popa   
 155:	72 79                	jb     1d0 <bin8_set+0x17>
 157:	5f                   	pop    %edi
 158:	31 36                	xor    %esi,(%esi)
 15a:	00 62 69             	add    %ah,0x69(%edx)
 15d:	6e                   	outsb  %ds:(%esi),(%dx)
 15e:	61                   	popa   
 15f:	72 79                	jb     1da <bin8_set+0x21>
 161:	5f                   	pop    %edi
 162:	33 32                	xor    (%edx),%esi
 164:	00 62 69             	add    %ah,0x69(%edx)
 167:	6e                   	outsb  %ds:(%esi),(%dx)
 168:	61                   	popa   
 169:	72 79                	jb     1e4 <void_get+0x4>
 16b:	5f                   	pop    %edi
 16c:	36                   	ss
 16d:	34 00                	xor    $0x0,%al
 16f:	6f                   	outsl  %ds:(%esi),(%dx)
 170:	63 74 61 6c          	arpl   %si,0x6c(%ecx,%eiz,2)
 174:	5f                   	pop    %edi
 175:	38 00                	cmp    %al,(%eax)
 177:	6f                   	outsl  %ds:(%esi),(%dx)
 178:	63 74 61 6c          	arpl   %si,0x6c(%ecx,%eiz,2)
 17c:	5f                   	pop    %edi
 17d:	31 36                	xor    %esi,(%esi)
 17f:	00 6f 63             	add    %ch,0x63(%edi)
 182:	74 61                	je     1e5 <void_get+0x5>
 184:	6c                   	insb   (%dx),%es:(%edi)
 185:	5f                   	pop    %edi
 186:	33 32                	xor    (%edx),%esi
 188:	00 6f 63             	add    %ch,0x63(%edi)
 18b:	74 61                	je     1ee <void_get+0xe>
 18d:	6c                   	insb   (%dx),%es:(%edi)
 18e:	5f                   	pop    %edi
 18f:	36                   	ss
 190:	34 00                	xor    $0x0,%al
 192:	69 70 5f 61 64 64 72 	imul   $0x72646461,0x5f(%eax),%esi
 199:	65                   	gs
 19a:	73 73                	jae    20f <void_get+0x2f>
 19c:	00 72 67             	add    %dh,0x67(%edx)
 19f:	62 00                	bound  %eax,(%eax)
 1a1:	72 67                	jb     20a <void_get+0x2a>
 1a3:	62 69 00             	bound  %ebp,0x0(%ecx)
 1a6:	63 79 6d             	arpl   %di,0x6d(%ecx)
 1a9:	6b 00 72             	imul   $0x72,(%eax),%eax
 1ac:	61                   	popa   
 1ad:	74 69                	je     218 <void_get+0x38>
 1af:	6f                   	outsl  %ds:(%esi),(%dx)
 1b0:	00 69 70             	add    %ch,0x70(%ecx)
 1b3:	5f                   	pop    %edi
 1b4:	70 6f                	jo     225 <void_get+0x45>
 1b6:	72 74                	jb     22c <int_get+0x1>
 1b8:	00                   	.byte 0x0

Disassembly of section .rodata:

00000000 <STUB_STRING>:
   0:	4e                   	dec    %esi
   1:	55                   	push   %ebp
   2:	4c                   	dec    %esp
   3:	4c                   	dec    %esp
   4:	00                   	.byte 0x0

Disassembly of section .debug_info:

00000000 <.debug_info>:
int bin64_get(struct conf_var *var, char *s)
{
	s = "";

	return 0;
}
       0:	50                   	push   %eax
       1:	19 00                	sbb    %eax,(%eax)
       3:	00 02                	add    %al,(%edx)
       5:	00 00                	add    %al,(%eax)	6: R_386_32	.debug_abbrev
int oct32_get(struct conf_var *var, char *s)
{
	s = "";

	return 0;
}
       7:	00 00                	add    %al,(%eax)
       9:	00 04 01             	add    %al,(%ecx,%eax,1)

	return 0;
}

int ratio_set(struct conf_var *var, const char *s)
{
       c:	a8 04                	test   $0x4,%al	c: R_386_32	.debug_str
       e:	00 00                	add    %al,(%eax)
      10:	01 6b 04             	add    %ebp,0x4(%ebx)	11: R_386_32	.debug_str
      13:	00 00                	add    %al,(%eax)
	if (var->p == NULL) {
      15:	62 02                	bound  %eax,(%edx)	15: R_386_32	.debug_str
      17:	00 00                	add    %al,(%eax)
      19:	00 00                	add    %al,(%eax)	19: R_386_32	.text
		var->p = malloc(2 * sizeof(int));
      1b:	00 00                	add    %al,(%eax)
      1d:	ea 12 00 00 00 00 00 	ljmp   $0x0,$0x12	1d: R_386_32	.text
	21: R_386_32	.debug_line
      24:	00 02                	add    %al,(%edx)
      26:	74 01                	je     29 <.debug_info+0x29>	26: R_386_32	.debug_str
      28:	00 00                	add    %al,(%eax)
	}

	return 0;
}
      2a:	04 d4                	add    $0xd4,%al
      2c:	30 00                	xor    %al,(%eax)
      2e:	00 00                	add    %al,(%eax)
      30:	03 04 07             	add    (%edi,%eax,1),%eax

	return 0;
}

int cymk_set(struct conf_var *var, const char *s)
{
      33:	4c                   	dec    %esp	33: R_386_32	.debug_str
      34:	00 00                	add    %al,(%eax)
      36:	00 03                	add    %al,(%ebx)
      38:	01 08                	add    %ecx,(%eax)
      3a:	ec                   	in     (%dx),%al	3a: R_386_32	.debug_str
	if (var->p == NULL) {
      3b:	04 00                	add    $0x0,%al
      3d:	00 03                	add    %al,(%ebx)
      3f:	02 07                	add    (%edi),%al
		var->p = malloc(sizeof(unsigned int));
      41:	8c 05 00 00 03 04    	mov    %es,0x4030000	41: R_386_32	.debug_str
      47:	07                   	pop    %es
      48:	72 04                	jb     4e <.debug_info+0x4e>	48: R_386_32	.debug_str
      4a:	00 00                	add    %al,(%eax)
      4c:	03 01                	add    (%ecx),%eax
      4e:	06                   	push   %es
      4f:	80 05 00 00 03 02 05 	addb   $0x5,0x2030000	4f: R_386_32	.debug_str
	}

	return 0;
}
      56:	e1 03                	loope  5b <.debug_info+0x5b>	56: R_386_32	.debug_str
      58:	00 00                	add    %al,(%eax)

	return 0;
}

int rgbi_set(struct conf_var *var, const char *s)
{
      5a:	04 04                	add    $0x4,%al
      5c:	05 69 6e 74 00       	add    $0x746e69,%eax
      61:	03 08                	add    (%eax),%ecx
	if (var->p == NULL) {
      63:	05 a5 02 00 00       	add    $0x2a5,%eax	64: R_386_32	.debug_str
		var->p = malloc(sizeof(unsigned int));
      68:	03 08                	add    (%eax),%ecx
      6a:	07                   	pop    %es
      6b:	f4                   	hlt    	6b: R_386_32	.debug_str
      6c:	00 00                	add    %al,(%eax)
      6e:	00 02                	add    %al,(%edx)
      70:	05 03 00 00 05       	add    $0x5000003,%eax	70: R_386_32	.debug_str
      75:	38 61 00             	cmp    %ah,0x0(%ecx)
	}

	return 0;
}
      78:	00 00                	add    %al,(%eax)
      7a:	02 6f 05             	add    0x5(%edi),%ch	7b: R_386_32	.debug_str
      7d:	00 00                	add    %al,(%eax)
      7f:	05 8d 85 00 00       	add    $0x858d,%eax

	return 0;
}

int rgb_set(struct conf_var *var, const char *s)
{
      84:	00 03                	add    %al,(%ebx)
      86:	04 05                	add    $0x5,%al
      88:	f7 03 00 00 02 ee    	testl  $0xee020000,(%ebx)	88: R_386_32	.debug_str
	8d: R_386_32	.debug_str
	if (var->p == NULL) {
      8e:	05 00 00 05 8e       	add    $0x8e050000,%eax
		var->p = malloc(sizeof(unsigned int));
      93:	6f                   	outsl  %ds:(%esi),(%dx)
      94:	00 00                	add    %al,(%eax)
      96:	00 05 04 06 04 9f    	add    %al,0x9f040604
      9c:	00 00                	add    %al,(%eax)
	}

	return 0;
}
      9e:	00 03                	add    %al,(%ebx)
      a0:	01 06                	add    %eax,(%esi)
      a2:	e9 01 00 00 02       	jmp    20000a8 <ipport_set+0x1ffede5>	a2: R_386_32	.debug_str
      a7:	c0 05 00 00 06 31 b1 	rolb   $0xb1,0x31060000	a7: R_386_32	.debug_str

	return 0;
}

int oct64_set(struct conf_var *var, const char *s)
{
      ae:	00 00                	add    %al,(%eax)
	if (var->p == NULL) {
      b0:	00 07                	add    %al,(%edi)
      b2:	90                   	nop	b2: R_386_32	.debug_str
      b3:	04 00                	add    $0x0,%al
      b5:	00 94 07 11 01 72 02 	add    %dl,0x2720111(%edi,%eax,1)
		var->p = malloc(sizeof(long long int));
      bc:	00 00                	add    %al,(%eax)
      be:	08 63 00             	or     %ah,0x0(%ebx)	bf: R_386_32	.debug_str
      c1:	00 00                	add    %al,(%eax)
      c3:	07                   	pop    %es
      c4:	12 01                	adc    (%ecx),%al
	}

	return 0;
}
      c6:	5a                   	pop    %edx
      c7:	00 00                	add    %al,(%eax)
      c9:	00 02                	add    %al,(%edx)
      cb:	23 00                	and    (%eax),%eax
      cd:	08 09                	or     %cl,(%ecx)	ce: R_386_32	.debug_str

	return 0;
}

int oct32_set(struct conf_var *var, const char *s)
{
      cf:	02 00                	add    (%eax),%al
      d1:	00 07                	add    %al,(%edi)
      d3:	17                   	pop    %ss
      d4:	01 99 00 00 00 02    	add    %ebx,0x2000000(%ecx)
	if (var->p == NULL) {
      da:	23 04 08             	and    (%eax,%ecx,1),%eax
		var->p = malloc(sizeof(unsigned int));
      dd:	cb                   	lret   	dd: R_386_32	.debug_str
      de:	03 00                	add    (%eax),%eax
      e0:	00 07                	add    %al,(%edi)
      e2:	18 01                	sbb    %al,(%ecx)
      e4:	99                   	cltd   
      e5:	00 00                	add    %al,(%eax)
      e7:	00 02                	add    %al,(%edx)
      e9:	23 08                	and    (%eax),%ecx
      eb:	08 99 01 00 00 07    	or     %bl,0x7000001(%ecx)	ec: R_386_32	.debug_str
	}

	return 0;
}
      f1:	19 01                	sbb    %eax,(%ecx)
      f3:	99                   	cltd   
      f4:	00 00                	add    %al,(%eax)

	return 0;
}

int oct16_set(struct conf_var *var, const char *s)
{
      f6:	00 02                	add    %al,(%edx)
      f8:	23 0c 08             	and    (%eax,%ecx,1),%ecx
      fb:	53                   	push   %ebx	fb: R_386_32	.debug_str
      fc:	02 00                	add    (%eax),%al
	if (var->p == NULL) {
      fe:	00 07                	add    %al,(%edi)
     100:	1a 01                	sbb    (%ecx),%al
     102:	99                   	cltd   
     103:	00 00                	add    %al,(%eax)
		var->p = malloc(sizeof(short int));
     105:	00 02                	add    %al,(%edx)
     107:	23 10                	and    (%eax),%edx
     109:	08 1c 05 00 00 07 1b 	or     %bl,0x1b070000(,%eax,1)	10a: R_386_32	.debug_str
     110:	01 99 00 00 00 02    	add    %ebx,0x2000000(%ecx)
	}

	return 0;
}
     116:	23 14 08             	and    (%eax,%ecx,1),%edx
     119:	3e 00 00             	add    %al,%ds:(%eax)	119: R_386_32	.debug_str
     11c:	00 07                	add    %al,(%edi)

	return 0;
}

int oct8_set(struct conf_var *var, const char *s)
{
     11e:	1c 01                	sbb    $0x1,%al
     120:	99                   	cltd   
     121:	00 00                	add    %al,(%eax)
     123:	00 02                	add    %al,(%edx)
	if (var->p == NULL) {
     125:	23 18                	and    (%eax),%ebx
     127:	08 01                	or     %al,(%ecx)	128: R_386_32	.debug_str
     129:	06                   	push   %es
     12a:	00 00                	add    %al,(%eax)
		var->p = malloc(sizeof(unsigned char));
     12c:	07                   	pop    %es
     12d:	1d 01 99 00 00       	sbb    $0x9901,%eax
     132:	00 02                	add    %al,(%edx)
     134:	23 1c 08             	and    (%eax,%ecx,1),%ebx
     137:	29 00                	sub    %eax,(%eax)	137: R_386_32	.debug_str
     139:	00 00                	add    %al,(%eax)
	}

	return 0;
}
     13b:	07                   	pop    %es
     13c:	1e                   	push   %ds
     13d:	01 99 00 00 00 02    	add    %ebx,0x2000000(%ecx)
     143:	23 20                	and    (%eax),%esp

	return 0;
}

int bin64_set(struct conf_var *var, const char *s)
{
     145:	08 bc 02 00 00 07 20 	or     %bh,0x20070000(%edx,%eax,1)	146: R_386_32	.debug_str
	if (var->p == NULL) {
     14c:	01 99 00 00 00 02    	add    %ebx,0x2000000(%ecx)
		var->p = malloc(sizeof(long long int));
     152:	23 24 08             	and    (%eax,%ecx,1),%esp
     155:	24 01                	and    $0x1,%al	155: R_386_32	.debug_str
     157:	00 00                	add    %al,(%eax)
     159:	07                   	pop    %es
     15a:	21 01                	and    %eax,(%ecx)
     15c:	99                   	cltd   
     15d:	00 00                	add    %al,(%eax)
     15f:	00 02                	add    %al,(%edx)
	}

	return 0;
}
     161:	23 28                	and    (%eax),%ebp
     163:	08 ca                	or     %cl,%dl	164: R_386_32	.debug_str
     165:	00 00                	add    %al,(%eax)
     167:	00 07                	add    %al,(%edi)
     169:	22 01                	and    (%ecx),%al

	return 0;
}

int bin32_set(struct conf_var *var, const char *s)
{
     16b:	99                   	cltd   
     16c:	00 00                	add    %al,(%eax)
     16e:	00 02                	add    %al,(%edx)
     170:	23 2c 08             	and    (%eax,%ecx,1),%ebp
	if (var->p == NULL) {
     173:	8a 00                	mov    (%eax),%al	173: R_386_32	.debug_str
     175:	00 00                	add    %al,(%eax)
     177:	07                   	pop    %es
     178:	24 01                	and    $0x1,%al
		var->p = malloc(sizeof(unsigned long));
     17a:	b0 02                	mov    $0x2,%al
     17c:	00 00                	add    %al,(%eax)
     17e:	02 23                	add    (%ebx),%ah
     180:	30 08                	xor    %cl,(%eax)
     182:	a6                   	cmpsb  %es:(%edi),%ds:(%esi)	182: R_386_32	.debug_str
     183:	05 00 00 07 26       	add    $0x26070000,%eax
	}
	return 0;
}
     188:	01 b6 02 00 00 02    	add    %esi,0x2000002(%esi)
     18e:	23 34 08             	and    (%eax,%ecx,1),%esi
     191:	57                   	push   %edi	191: R_386_32	.debug_str

	return 0;
}

int bin16_set(struct conf_var *var, const char *s)
{
     192:	01 00                	add    %eax,(%eax)
     194:	00 07                	add    %al,(%edi)
     196:	28 01                	sub    %al,(%ecx)
     198:	5a                   	pop    %edx
     199:	00 00                	add    %al,(%eax)
	if (var->p == NULL) {
     19b:	00 02                	add    %al,(%edx)
     19d:	23 38                	and    (%eax),%edi
     19f:	08 c5                	or     %al,%ch	1a0: R_386_32	.debug_str
		var->p = malloc(sizeof(short int));
     1a1:	05 00 00 07 2c       	add    $0x2c070000,%eax
     1a6:	01 5a 00             	add    %ebx,0x0(%edx)
     1a9:	00 00                	add    %al,(%eax)
     1ab:	02 23                	add    (%ebx),%ah
     1ad:	3c 08                	cmp    $0x8,%al
	}

	return 0;
}
     1af:	84 04 00             	test   %al,(%eax,%eax,1)	1af: R_386_32	.debug_str
     1b2:	00 07                	add    %al,(%edi)
     1b4:	2e 01 7a 00          	add    %edi,%cs:0x0(%edx)
     1b8:	00 00                	add    %al,(%eax)

	return 0;
}

int bin8_set(struct conf_var *var, const char *s)
{
     1ba:	02 23                	add    (%ebx),%ah
     1bc:	40                   	inc    %eax
     1bd:	08 cd                	or     %cl,%ch	1be: R_386_32	.debug_str
     1bf:	05 00 00 07 32       	add    $0x32070000,%eax
	if (var->p == NULL) {
     1c4:	01 3e                	add    %edi,(%esi)
     1c6:	00 00                	add    %al,(%eax)
		var->p = malloc(sizeof(unsigned char));
     1c8:	00 02                	add    %al,(%edx)
     1ca:	23 44 08 60          	and    0x60(%eax,%ecx,1),%eax	1cd: R_386_32	.debug_str
     1ce:	03 00                	add    (%eax),%eax
     1d0:	00 07                	add    %al,(%edi)
     1d2:	33 01                	xor    (%ecx),%eax
     1d4:	4c                   	dec    %esp
     1d5:	00 00                	add    %al,(%eax)
	}

	return 0;
}
     1d7:	00 02                	add    %al,(%edx)
     1d9:	23 46 08             	and    0x8(%esi),%eax
     1dc:	00 00                	add    %al,(%eax)	1dc: R_386_32	.debug_str
     1de:	00 00                	add    %al,(%eax)
{
	return write_section(stdout, root, NULL);
}

int void_get(struct conf_var *var, char *s)
{
     1e0:	07                   	pop    %es
     1e1:	34 01                	xor    $0x1,%al
     1e3:	bc 02 00 00 02       	mov    $0x2000002,%esp
	if (var->p == NULL) {
     1e8:	23 47 08             	and    0x8(%edi),%eax
     1eb:	65                   	gs	1eb: R_386_32	.debug_str
     1ec:	04 00                	add    $0x0,%al
     1ee:	00 07                	add    %al,(%edi)
     1f0:	38 01                	cmp    %al,(%ecx)

#ifdef __va_arg_pack
__extern_always_inline int
__NTH (sprintf (char *__restrict __s, __const char *__restrict __fmt, ...))
{
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
     1f2:	cc                   	int3   
     1f3:	02 00                	add    (%eax),%al
     1f5:	00 02                	add    %al,(%edx)
     1f7:	23 48 08             	and    0x8(%eax),%ecx
     1fa:	3f                   	aas    	1fa: R_386_32	.debug_str
     1fb:	01 00                	add    %eax,(%eax)
		sprintf(s, "NULL");
		return 0;
     1fd:	00 07                	add    %al,(%edi)
     1ff:	41                   	inc    %ecx
     200:	01 8c 00 00 00 02 23 	add    %ecx,0x23020000(%eax,%eax,1)
     207:	4c                   	dec    %esp
     208:	08 2a                	or     %ch,(%edx)	209: R_386_32	.debug_str
     20a:	03 00                	add    (%eax),%eax
     20c:	00 07                	add    %al,(%edi)
     20e:	4a                   	dec    %edx
     20f:	01 97 00 00 00 02    	add    %edx,0x2000000(%edi)
     215:	23 54 08 31          	and    0x31(%eax,%ecx,1),%edx	218: R_386_32	.debug_str
     219:	03 00                	add    (%eax),%eax
     21b:	00 07                	add    %al,(%edi)
     21d:	4b                   	dec    %ebx
     21e:	01 97 00 00 00 02    	add    %edx,0x2000000(%edi)
	}

	sprintf(s, "%p", var->p);
	return 1;
     224:	23 58 08             	and    0x8(%eax),%ebx
}
     227:	38 03                	cmp    %al,(%ebx)	227: R_386_32	.debug_str
     229:	00 00                	add    %al,(%eax)
	sscanf(s, "%p", &(var->p));
	return 1;
}

int int_get(struct conf_var *var, char *s)
{
     22b:	07                   	pop    %es
     22c:	4c                   	dec    %esp
     22d:	01 97 00 00 00 02    	add    %edx,0x2000000(%edi)
	if (var->p == NULL) {
     233:	23 5c 08 3f          	and    0x3f(%eax,%ecx,1),%ebx	236: R_386_32	.debug_str
     237:	03 00                	add    (%eax),%eax
     239:	00 07                	add    %al,(%edi)
     23b:	4d                   	dec    %ebp
     23c:	01 97 00 00 00 02    	add    %edx,0x2000000(%edi)
     242:	23 60 08             	and    0x8(%eax),%esp
     245:	46                   	inc    %esi	245: R_386_32	.debug_str
     246:	03 00                	add    (%eax),%eax
		sprintf(s, "NULL");
		return 0;
     248:	00 07                	add    %al,(%edi)
     24a:	4e                   	dec    %esi
     24b:	01 25 00 00 00 02    	add    %esp,0x2000000
     251:	23 64 08 ee          	and    -0x12(%eax,%ecx,1),%esp	254: R_386_32	.debug_str
     255:	01 00                	add    %eax,(%eax)
     257:	00 07                	add    %al,(%edi)
     259:	50                   	push   %eax
     25a:	01 5a 00             	add    %ebx,0x0(%edx)
     25d:	00 00                	add    %al,(%eax)
     25f:	02 23                	add    (%ebx),%ah
     261:	68 08 f8 05 00       	push   $0x5f808	263: R_386_32	.debug_str
     266:	00 07                	add    %al,(%edi)
     268:	52                   	push   %edx
     269:	01 d2                	add    %edx,%edx
     26b:	02 00                	add    (%eax),%al
     26d:	00 02                	add    %al,(%edx)
	}

	sprintf(s, "%i", *(int *) (var->p));
	return 1;
     26f:	23 6c 00 09          	and    0x9(%eax,%eax,1),%ebp
     273:	0a 00                	or     (%eax),%al	273: R_386_32	.debug_str
}
     275:	00 00                	add    %al,(%eax)
     277:	07                   	pop    %es

	return 1;
}

int uint_get(struct conf_var *var, char *s)
{
     278:	b6 0a                	mov    $0xa,%dh
     27a:	f4                   	hlt    	27a: R_386_32	.debug_str
     27b:	01 00                	add    %eax,(%eax)
     27d:	00 0c 07             	add    %cl,(%edi,%eax,1)
	if (var->p == NULL) {
     280:	bc b0 02 00 00       	mov    $0x2b0,%esp
     285:	0b ad 01 00 00 07    	or     0x7000001(%ebp),%ebp	286: R_386_32	.debug_str
     28b:	bd b0 02 00 00       	mov    $0x2b0,%ebp
     290:	02 23                	add    (%ebx),%ah
     292:	00 0b                	add    %cl,(%ebx)
		sprintf(s, "NULL");
		return 0;
     294:	04 05                	add    $0x5,%al	294: R_386_32	.debug_str
     296:	00 00                	add    %al,(%eax)
     298:	07                   	pop    %es
     299:	be b6 02 00 00       	mov    $0x2b6,%esi
     29e:	02 23                	add    (%ebx),%ah
     2a0:	04 0b                	add    $0xb,%al
     2a2:	ab                   	stos   %eax,%es:(%edi)	2a2: R_386_32	.debug_str
     2a3:	00 00                	add    %al,(%eax)
     2a5:	00 07                	add    %al,(%edi)
     2a7:	c2 5a 00             	ret    $0x5a
     2aa:	00 00                	add    %al,(%eax)
     2ac:	02 23                	add    (%ebx),%ah
     2ae:	08 00                	or     %al,(%eax)
     2b0:	06                   	push   %es
     2b1:	04 79                	add    $0x79,%al
     2b3:	02 00                	add    (%eax),%al
     2b5:	00 06                	add    %al,(%esi)
     2b7:	04 b1                	add    $0xb1,%al
     2b9:	00 00                	add    %al,(%eax)
     2bb:	00 0c 9f             	add    %cl,(%edi,%ebx,4)
	}

	sprintf(s, "%u", *(unsigned int *) (var->p));
	return 1;
     2be:	00 00                	add    %al,(%eax)
     2c0:	00 cc                	add    %cl,%ah
}
     2c2:	02 00                	add    (%eax),%al
     2c4:	00 0d 30 00 00 00    	add    %cl,0x30

	return 1;
}

int float_get(struct conf_var *var, char *s)
{
     2ca:	00 00                	add    %al,(%eax)
	if (var->p == NULL) {
     2cc:	06                   	push   %es
     2cd:	04 72                	add    $0x72,%al
     2cf:	02 00                	add    (%eax),%al
     2d1:	00 0c 9f             	add    %cl,(%edi,%ebx,4)
     2d4:	00 00                	add    %al,(%eax)
     2d6:	00 e2                	add    %ah,%dl
     2d8:	02 00                	add    (%eax),%al
     2da:	00 0d 30 00 00 00    	add    %cl,0x30
     2e0:	27                   	daa    
		sprintf(s, "NULL");
		return 0;
     2e1:	00 06                	add    %al,(%esi)
     2e3:	04 e8                	add    $0xe8,%al
     2e5:	02 00                	add    (%eax),%al
     2e7:	00 0e                	add    %cl,(%esi)
     2e9:	9f                   	lahf   
     2ea:	00 00                	add    %al,(%eax)
     2ec:	00 06                	add    %al,(%esi)
     2ee:	04 5a                	add    $0x5a,%al
     2f0:	00 00                	add    %al,(%eax)
     2f2:	00 03                	add    %al,(%ebx)
     2f4:	0c 04                	or     $0x4,%al
     2f6:	80 03 00             	addb   $0x0,(%ebx)	2f6: R_386_32	.debug_str
     2f9:	00 03                	add    %al,(%ebx)
     2fb:	08 04 9f             	or     %al,(%edi,%ebx,4)	2fd: R_386_32	.debug_str
     2fe:	05 00 00 0f 04       	add    $0x40f0000,%eax
     303:	09 31                	or     %esi,(%ecx)
     305:	5d                   	pop    %ebp
     306:	03 00                	add    (%eax),%eax
     308:	00 10                	add    %dl,(%eax)
	}

	sprintf(s, "%f", *(double *) (var->p));
	return 1;
     30a:	ad                   	lods   %ds:(%esi),%eax	30a: R_386_32	.debug_str
     30b:	05 00 00 80 02       	add    $0x2800000,%eax
}
     310:	10 4e 01             	adc    %cl,0x1(%esi)	311: R_386_32	.debug_str
	sscanf(s, "%lf", (double *) (var->p));
	return 1;
}

int string_get(struct conf_var *var, char *s)
{
     313:	00 00                	add    %al,(%eax)
     315:	80 04 10 9f          	addb   $0x9f,(%eax,%edx,1)	318: R_386_32	.debug_str
	char * cp;			/* source */

	if (var->p == NULL) {
     319:	04 00                	add    $0x0,%al
     31b:	00 80 08 10 f2 02    	add    %al,0x2f21008(%eax)	31f: R_386_32	.debug_str
     321:	00 00                	add    %al,(%eax)
     323:	80 10 10             	adcb   $0x10,(%eax)
     326:	85 01                	test   %eax,(%ecx)	326: R_386_32	.debug_str
     328:	00 00                	add    %al,(%eax)
     32a:	80 20 10             	andb   $0x10,(%eax)
     32d:	0e                   	push   %cs	32d: R_386_32	.debug_str
		sprintf(s, "NULL");
		return 0;
     32e:	03 00                	add    (%eax),%eax
     330:	00 80 c0 00 10 d8    	add    %al,-0x27efff40(%eax)	335: R_386_32	.debug_str
     336:	03 00                	add    (%eax),%eax
     338:	00 80 80 01 10 3a    	add    %al,0x3a100180(%eax)	33d: R_386_32	.debug_str
     33e:	04 00                	add    $0x0,%al
     340:	00 80 80 02 10 77    	add    %al,0x77100280(%eax)	345: R_386_32	.debug_str
     346:	05 00 00 01 10       	add    $0x10010000,%eax
     34b:	ca 02 00             	lret   $0x2	34b: R_386_32	.debug_str
     34e:	00 02                	add    %al,(%edx)
     350:	10 c2                	adc    %al,%dl	351: R_386_32	.debug_str
     352:	03 00                	add    (%eax),%eax
	}

	cp = (char *)(var->p);
	sprintf(s, "\"%s\"", cp);

	return 1;
     354:	00 04 10             	add    %al,(%eax,%edx,1)
     357:	4c                   	dec    %esp	357: R_386_32	.debug_str
     358:	05 00 00 08 00       	add    $0x80000,%eax

	return 1;
}

int bool_get(struct conf_var *var, char *s)
{
     35d:	0a d8                	or     %al,%bl	35e: R_386_32	.debug_str
     35f:	01 00                	add    %eax,(%eax)
	if ((*(int *) (var->p)) == 0)
     361:	00 10                	add    %dl,(%eax)
     363:	08 20                	or     %ah,(%eax)
     365:	a0 03 00 00 0b       	mov    0xb000003,%al
     36a:	43                   	inc    %ebx	36a: R_386_32	.debug_str
     36b:	04 00                	add    $0x0,%al
     36d:	00 08                	add    %cl,(%eax)
     36f:	21 e2                	and    %esp,%edx
     371:	02 00                	add    (%eax),%al
     373:	00 02                	add    %al,(%edx)
     375:	23 00                	and    (%eax),%eax
     377:	0b dd                	or     %ebp,%ebx	378: R_386_32	.debug_str
     379:	04 00                	add    $0x0,%al
     37b:	00 08                	add    %cl,(%eax)
     37d:	22 e5                	and    %ch,%ah
     37f:	03 00                	add    (%eax),%eax
     381:	00 02                	add    %al,(%edx)
     383:	23 04 11             	and    (%ecx,%edx,1),%eax
		sprintf(s, "False");
	else
		sprintf(s, "True");
	return 1;
}
     386:	70 00                	jo     388 <.debug_info+0x388>
     388:	08 23                	or     %ah,(%ebx)
     38a:	97                   	xchg   %eax,%edi

	return 0;
}

int char_get(struct conf_var *var, char *s)
{
     38b:	00 00                	add    %al,(%eax)
     38d:	00 02                	add    %al,(%edx)
     38f:	23 08                	and    (%eax),%ecx
     391:	11 6c 65 6e          	adc    %ebp,0x6e(%ebp,%eiz,2)
	if (var->p == NULL) {
     395:	00 08                	add    %cl,(%eax)
     397:	24 5a                	and    $0x5a,%al
     399:	00 00                	add    %al,(%eax)
     39b:	00 02                	add    %al,(%edx)
     39d:	23 0c 00             	and    (%eax,%eax,1),%ecx
     3a0:	0a 1f                	or     (%edi),%bl	3a1: R_386_32	.debug_str
     3a2:	00 00                	add    %al,(%eax)
     3a4:	00 10                	add    %dl,(%eax)
     3a6:	08 81 e5 03 00 00    	or     %al,0x3e5(%ecx)
		return 0;
	}

	//printf("*** %s: var '%s' = '%c'\n", __FUNCTION__, var->name, *(char *)(var->p));

	sprintf(s, "%c", *(char *) (var->p));
     3ac:	0b 31                	or     (%ecx),%esi	3ad: R_386_32	.debug_str
     3ae:	02 00                	add    (%eax),%al
     3b0:	00 08                	add    %cl,(%eax)
     3b2:	82                   	(bad)  
     3b3:	5a                   	pop    %edx
     3b4:	00 00                	add    %al,(%eax)
     3b6:	00 02                	add    %al,(%edx)
     3b8:	23 00                	and    (%eax),%eax
     3ba:	0b 0f                	or     (%edi),%ecx	3bb: R_386_32	.debug_str
     3bc:	05 00 00 08 83       	add    $0x83080000,%eax
     3c1:	99                   	cltd   
     3c2:	00 00                	add    %al,(%eax)
     3c4:	00 02                	add    %al,(%edx)
     3c6:	23 04 0b             	and    (%ebx,%ecx,1),%eax
     3c9:	bd 04 00 00 08       	mov    $0x8000004,%ebp	3c9: R_386_32	.debug_str
     3ce:	84 06                	test   %al,(%esi)
	return 1;
     3d0:	04 00                	add    $0x0,%al
     3d2:	00 02                	add    %al,(%edx)
     3d4:	23 08                	and    (%eax),%ecx
}
     3d6:	0b d9                	or     %ecx,%ebx	3d7: R_386_32	.debug_str
     3d8:	05 00 00 08 85       	add    $0x85080000,%eax
	sscanf(cp, "%c", (char *) (var->p));
	return 1;
}

int hex8_get(struct conf_var *var, char *s)
{
     3dd:	21 04 00             	and    %eax,(%eax,%eax,1)
	if (var->p == NULL) {
     3e0:	00 02                	add    %al,(%edx)
     3e2:	23 0c 00             	and    (%eax,%eax,1),%ecx
     3e5:	06                   	push   %es
     3e6:	04 a0                	add    $0xa0,%al
     3e8:	03 00                	add    (%eax),%eax
     3ea:	00 12                	add    %dl,(%edx)
     3ec:	01 5a 00             	add    %ebx,0x0(%edx)
     3ef:	00 00                	add    %al,(%eax)
     3f1:	00 04 00             	add    %al,(%eax,%eax,1)
     3f4:	00 13                	add    %dl,(%ebx)
		sprintf(s, "NULL");
		return 0;
     3f6:	00 04 00             	add    %al,(%eax,%eax,1)
	}

	sprintf(s, "0x%02X", *(unsigned char *) (var->p));
     3f9:	00 13                	add    %dl,(%ebx)
     3fb:	99                   	cltd   
     3fc:	00 00                	add    %al,(%eax)
     3fe:	00 00                	add    %al,(%eax)
     400:	06                   	push   %es
     401:	04 5d                	add    $0x5d,%al
     403:	03 00                	add    (%eax),%eax
     405:	00 06                	add    %al,(%esi)
     407:	04 eb                	add    $0xeb,%al
     409:	03 00                	add    (%eax),%eax
     40b:	00 12                	add    %dl,(%edx)
     40d:	01 5a 00             	add    %ebx,0x0(%edx)
     410:	00 00                	add    %al,(%eax)
     412:	21 04 00             	and    %eax,(%eax,%eax,1)
     415:	00 13                	add    %dl,(%ebx)
     417:	00 04 00             	add    %al,(%eax,%eax,1)
     41a:	00 13                	add    %dl,(%ebx)
     41c:	e2 02                	loop   420 <.debug_info+0x420>
	return 1;
     41e:	00 00                	add    %al,(%eax)
     420:	00 06                	add    %al,(%esi)
     422:	04 0c                	add    $0xc,%al
}
     424:	04 00                	add    $0x0,%al
     426:	00 14 01             	add    %dl,(%ecx,%eax,1)
	sscanf(s, "%X", (unsigned int *) (var->p));
	return 1;
}

int hex16_get(struct conf_var *var, char *s)
{
     429:	18 04 00             	sbb    %al,(%eax,%eax,1)	429: R_386_32	.debug_str
     42c:	00 02                	add    %al,(%edx)
	if (var->p == NULL) {
     42e:	60                   	pusha  
     42f:	01 5a 00             	add    %ebx,0x0(%edx)
     432:	00 00                	add    %al,(%eax)
     434:	03 01                	add    (%ecx),%eax
     436:	52                   	push   %edx
     437:	04 00                	add    $0x0,%al
     439:	00 15 c6 01 00 00    	add    %dl,0x1c6	43b: R_386_32	.debug_str
     43f:	02 60 52             	add    0x52(%eax),%ah
     442:	04 00                	add    $0x0,%al
		sprintf(s, "NULL");
		return 0;
     444:	00 15 c0 01 00 00    	add    %dl,0x1c0	446: R_386_32	.debug_str
     44a:	02 60 e2             	add    -0x1e(%eax),%ah
     44d:	02 00                	add    (%eax),%al
     44f:	00 16                	add    %dl,(%esi)
     451:	00 06                	add    %al,(%esi)
     453:	04 a6                	add    $0xa6,%al
     455:	00 00                	add    %al,(%eax)
     457:	00 14 01             	add    %dl,(%ecx,%eax,1)
     45a:	8c 03                	mov    %es,(%ebx)	45a: R_386_32	.debug_str
     45c:	00 00                	add    %al,(%eax)
     45e:	02 20                	add    (%eax),%ah
     460:	01 5a 00             	add    %ebx,0x0(%edx)
     463:	00 00                	add    %al,(%eax)
     465:	03 01                	add    (%ecx),%eax
     467:	83 04 00 00          	addl   $0x0,(%eax,%eax,1)
	}

	sprintf(s, "0x%04X", *(unsigned int *) (var->p));
	return 1;
     46b:	17                   	pop    %ss
     46c:	5f                   	pop    %edi
     46d:	5f                   	pop    %edi
     46e:	73 00                	jae    470 <.debug_info+0x470>
}
     470:	02 20                	add    (%eax),%ah
     472:	99                   	cltd   
     473:	00 00                	add    %al,(%eax)
	sscanf(s, "%X", (unsigned int *) (var->p));
	return 1;
}

int hex32_get(struct conf_var *var, char *s)
{
     475:	00 15 c0 01 00 00    	add    %dl,0x1c0	477: R_386_32	.debug_str
	if (var->p == NULL) {
     47b:	02 20                	add    (%eax),%ah
     47d:	e2 02                	loop   481 <.debug_info+0x481>
     47f:	00 00                	add    %al,(%eax)
     481:	16                   	push   %ss
     482:	00 14 01             	add    %dl,(%ecx,%eax,1)
     485:	b0 00                	mov    $0x0,%al	485: R_386_32	.debug_str
     487:	00 00                	add    %al,(%eax)
     489:	03 67 01             	add    0x1(%edi),%esp
     48c:	99                   	cltd   
     48d:	00 00                	add    %al,(%eax)
     48f:	00 03                	add    %al,(%ebx)
		sprintf(s, "NULL");
		return 0;
     491:	01 ad 04 00 00 15    	add    %ebp,0x15000004(%ebp)
     497:	47                   	inc    %edi	497: R_386_32	.debug_str
     498:	01 00                	add    %eax,(%eax)
     49a:	00 03                	add    %al,(%ebx)
     49c:	67 99                	addr16 cltd 
     49e:	00 00                	add    %al,(%eax)
     4a0:	00 15 16 05 00 00    	add    %dl,0x516	4a2: R_386_32	.debug_str
     4a6:	03 67 e2             	add    -0x1e(%edi),%esp
     4a9:	02 00                	add    (%eax),%al
     4ab:	00 00                	add    %al,(%eax)
     4ad:	14 01                	adc    $0x1,%al
     4af:	15 01 00 00 03       	adc    $0x3000001,%eax	4af: R_386_32	.debug_str
     4b4:	76 01                	jbe    4b7 <.debug_info+0x4b7>
     4b6:	99                   	cltd   
     4b7:	00 00                	add    %al,(%eax)
	}

	sprintf(s, "0x%08X", *(unsigned int *) (var->p));
	return 1;
     4b9:	00 03                	add    %al,(%ebx)
     4bb:	01 e2                	add    %esp,%edx
}
     4bd:	04 00                	add    $0x0,%al
     4bf:	00 15 47 01 00 00    	add    %dl,0x147	4c1: R_386_32	.debug_str
	sscanf(s, "%X", (unsigned int *) (var->p));
	return 1;
}

int hex64_get(struct conf_var *var, char *s)
{
     4c5:	03 76 99             	add    -0x67(%esi),%esi
     4c8:	00 00                	add    %al,(%eax)
	if (var->p == NULL) {
     4ca:	00 15 16 05 00 00    	add    %dl,0x516	4cc: R_386_32	.debug_str
     4d0:	03 76 e2             	add    -0x1e(%esi),%esi
     4d3:	02 00                	add    (%eax),%al
     4d5:	00 15 e1 00 00 00    	add    %dl,0xe1	4d7: R_386_32	.debug_str
     4db:	03 76 25             	add    0x25(%esi),%esi
		sprintf(s, "NULL");
		return 0;
     4de:	00 00                	add    %al,(%eax)
     4e0:	00 00                	add    %al,(%eax)
     4e2:	14 01                	adc    $0x1,%al
     4e4:	7a 03                	jp     4e9 <.debug_info+0x4e9>	4e4: R_386_32	.debug_str
     4e6:	00 00                	add    %al,(%eax)
     4e8:	02 f5                	add    %ch,%dh
     4ea:	01 99 00 00 00 03    	add    %ebx,0x3000000(%ecx)
     4f0:	01 17                	add    %edx,(%edi)
     4f2:	05 00 00 17 5f       	add    $0x5f170000,%eax
     4f7:	5f                   	pop    %edi
     4f8:	73 00                	jae    4fa <.debug_info+0x4fa>
     4fa:	02 f5                	add    %ch,%dh
     4fc:	99                   	cltd   
     4fd:	00 00                	add    %al,(%eax)
     4ff:	00 17                	add    %dl,(%edi)
     501:	5f                   	pop    %edi
     502:	5f                   	pop    %edi
     503:	6e                   	outsb  %ds:(%esi),(%dx)
     504:	00 02                	add    %al,(%edx)
     506:	f5                   	cmc    
     507:	5a                   	pop    %edx
     508:	00 00                	add    %al,(%eax)
     50a:	00 15 c6 01 00 00    	add    %dl,0x1c6	50c: R_386_32	.debug_str
	}

	sprintf(s, "0x%016llX", *(unsigned long long int *) (var->p));

	return 1;
     510:	02 f5                	add    %ch,%dh
}
     512:	52                   	push   %edx
     513:	04 00                	add    $0x0,%al
     515:	00 00                	add    %al,(%eax)

	return 1;
}

int bin8_get(struct conf_var *var, char *s)
{
     517:	18 01                	sbb    %al,(%ecx)
     519:	17                   	pop    %ss	519: R_386_32	.debug_str
     51a:	03 00                	add    (%eax),%eax
	if (var->p == NULL) {
     51c:	00 01                	add    %al,(%ecx)
     51e:	ee                   	out    %al,(%dx)
     51f:	02 01                	add    (%ecx),%al
     521:	5a                   	pop    %edx
     522:	00 00                	add    %al,(%eax)
     524:	00 00                	add    %al,(%eax)	525: R_386_32	.text
     526:	00 00                	add    %al,(%eax)
     528:	00 06                	add    %al,(%esi)	529: R_386_32	.text
     52a:	00 00                	add    %al,(%eax)
     52c:	00 02                	add    %al,(%edx)
     52e:	74 04                	je     534 <.debug_info+0x534>
		return 0;
	}
	s = "";

	return 0;
}
     530:	4e                   	dec    %esi
     531:	05 00 00 19 76       	add    $0x76190000,%eax

	return 0;
}

int bin16_get(struct conf_var *var, char *s)
{
     536:	61                   	popa   
     537:	72 00                	jb     539 <.debug_info+0x539>
	if (var->p == NULL) {
     539:	01 ee                	add    %ebp,%esi
     53b:	02 00                	add    (%eax),%al
     53d:	04 00                	add    $0x0,%al
     53f:	00 02                	add    %al,(%edx)
     541:	91                   	xchg   %eax,%ecx
     542:	00 1a                	add    %bl,(%edx)
     544:	73 00                	jae    546 <.debug_info+0x546>
     546:	01 ee                	add    %ebp,%esi
     548:	02 99 00 00 00 00    	add    0x0(%ecx),%bl
		return 0;
	}
	s = "";

	return 0;
}
     54e:	18 01                	sbb    %al,(%ecx)
     550:	ff 01                	incl   (%ecx)	550: R_386_32	.debug_str
     552:	00 00                	add    %al,(%eax)

	return 0;
}

int bin32_get(struct conf_var *var, char *s)
{
     554:	01 26                	add    %esp,(%esi)
     556:	03 01                	add    (%ecx),%eax
	if (var->p == NULL) {
     558:	5a                   	pop    %edx
     559:	00 00                	add    %al,(%eax)
     55b:	00 06                	add    %al,(%esi)	55c: R_386_32	.text
     55d:	00 00                	add    %al,(%eax)
     55f:	00 0c 00             	add    %cl,(%eax,%eax,1)	560: R_386_32	.text
     562:	00 00                	add    %al,(%eax)
     564:	02 74 04 85          	add    -0x7b(%esp,%eax,1),%dh
     568:	05 00 00 19 76       	add    $0x76190000,%eax
		return 0;
	}
	s = "";

	return 0;
}
     56d:	61                   	popa   
     56e:	72 00                	jb     570 <.debug_info+0x570>
     570:	01 26                	add    %esp,(%esi)

	return 0;
}

int oct8_get(struct conf_var *var, char *s)
{
     572:	03 00                	add    (%eax),%eax
     574:	04 00                	add    $0x0,%al
	if (var->p == NULL) {
     576:	00 02                	add    %al,(%edx)
     578:	91                   	xchg   %eax,%ecx
     579:	00 1a                	add    %bl,(%edx)
     57b:	73 00                	jae    57d <.debug_info+0x57d>
     57d:	01 26                	add    %esp,(%esi)
     57f:	03 99 00 00 00 00    	add    0x0(%ecx),%ebx
     585:	1b 01                	sbb    (%ecx),%eax
     587:	0e                   	push   %cs	587: R_386_32	.debug_str
     588:	04 00                	add    $0x0,%al
		return 0;
	}
	s = "";

	return 0;
}
     58a:	00 01                	add    %al,(%ecx)
     58c:	b1 03                	mov    $0x3,%cl
     58e:	01 5a 00             	add    %ebx,0x0(%edx)

	return 0;
}

int oct16_get(struct conf_var *var, char *s)
{
     591:	00 00                	add    %al,(%eax)
	if (var->p == NULL) {
     593:	0c 00                	or     $0x0,%al	593: R_386_32	.text
     595:	00 00                	add    %al,(%eax)
     597:	33 00                	xor    (%eax),%eax	597: R_386_32	.text
     599:	00 00                	add    %al,(%eax)
     59b:	00 00                	add    %al,(%eax)	59b: R_386_32	.debug_loc
     59d:	00 00                	add    %al,(%eax)
     59f:	c0 05 00 00 19 76 61 	rolb   $0x61,0x76190000
     5a6:	72 00                	jb     5a8 <.debug_info+0x5a8>
		return 0;
	}
	s = "";

	return 0;
}
     5a8:	01 b1 03 00 04 00    	add    %esi,0x40003(%ecx)

	return 0;
}

int oct64_get(struct conf_var *var, char *s)
{
     5ae:	00 02                	add    %al,(%edx)
     5b0:	91                   	xchg   %eax,%ecx
	if (var->p == NULL) {
     5b1:	00 19                	add    %bl,(%ecx)
     5b3:	73 00                	jae    5b5 <.debug_info+0x5b5>
     5b5:	01 b1 03 e2 02 00    	add    %esi,0x2e203(%ecx)
     5bb:	00 02                	add    %al,(%edx)
     5bd:	91                   	xchg   %eax,%ecx
     5be:	04 00                	add    $0x0,%al
     5c0:	1b 01                	sbb    (%ecx),%eax
     5c2:	29 04 00             	sub    %eax,(%eax,%eax,1)	5c2: R_386_32	.debug_str
		return 0;
	}
	s = "";

	return 0;
}
     5c5:	00 01                	add    %al,(%ecx)
     5c7:	9d                   	popf   
     5c8:	03 01                	add    (%ecx),%eax
     5ca:	5a                   	pop    %edx

	return 0;
}

int rgb_get(struct conf_var *var, char *s)
{
     5cb:	00 00                	add    %al,(%eax)
     5cd:	00 33                	add    %dh,(%ebx)	5ce: R_386_32	.text
	if (var->p == NULL) {
     5cf:	00 00                	add    %al,(%eax)
     5d1:	00 5a 00             	add    %bl,0x0(%edx)	5d2: R_386_32	.text
     5d4:	00 00                	add    %al,(%eax)
     5d6:	44                   	inc    %esp	5d6: R_386_32	.debug_loc
     5d7:	00 00                	add    %al,(%eax)
     5d9:	00 fb                	add    %bh,%bl
     5db:	05 00 00 19 76       	add    $0x76190000,%eax
     5e0:	61                   	popa   
     5e1:	72 00                	jb     5e3 <.debug_info+0x5e3>
		return 0;
	}
	s = "";

	return 0;
}
     5e3:	01 9d 03 00 04 00    	add    %ebx,0x40003(%ebp)

	return 0;
}

int rgbi_get(struct conf_var *var, char *s)
{
     5e9:	00 02                	add    %al,(%edx)
     5eb:	91                   	xchg   %eax,%ecx
     5ec:	00 19                	add    %bl,(%ecx)
	if (var->p == NULL) {
     5ee:	73 00                	jae    5f0 <.debug_info+0x5f0>
     5f0:	01 9d 03 e2 02 00    	add    %ebx,0x2e203(%ebp)
     5f6:	00 02                	add    %al,(%edx)
     5f8:	91                   	xchg   %eax,%ecx
     5f9:	04 00                	add    $0x0,%al
     5fb:	1b 01                	sbb    (%ecx),%eax
     5fd:	c1 00 00             	roll   $0x0,(%eax)	5fd: R_386_32	.debug_str
     600:	00 01                	add    %al,(%ecx)
		return 0;
	}
	s = "";

	return 0;
}
     602:	89 03                	mov    %eax,(%ebx)
     604:	01 5a 00             	add    %ebx,0x0(%edx)

	return 0;
}

int cymk_get(struct conf_var *var, char *s)
{
     607:	00 00                	add    %al,(%eax)
     609:	5a                   	pop    %edx	609: R_386_32	.text
     60a:	00 00                	add    %al,(%eax)
	if (var->p == NULL) {
     60c:	00 81 00 00 00 88    	add    %al,-0x78000000(%ecx)	60d: R_386_32	.text
	611: R_386_32	.debug_loc
     612:	00 00                	add    %al,(%eax)
     614:	00 36                	add    %dh,(%esi)
     616:	06                   	push   %es
     617:	00 00                	add    %al,(%eax)
     619:	19 76 61             	sbb    %esi,0x61(%esi)
     61c:	72 00                	jb     61e <.debug_info+0x61e>
     61e:	01 89 03 00 04 00    	add    %ecx,0x40003(%ecx)
		return 0;
	}
	s = "";

	return 0;
}
     624:	00 02                	add    %al,(%edx)

	return 0;
}

int ratio_get(struct conf_var *var, char *s)
{
     626:	91                   	xchg   %eax,%ecx
     627:	00 19                	add    %bl,(%ecx)
	if (var->p == NULL) {
     629:	73 00                	jae    62b <.debug_info+0x62b>
     62b:	01 89 03 e2 02 00    	add    %ecx,0x2e203(%ecx)
     631:	00 02                	add    %al,(%edx)
     633:	91                   	xchg   %eax,%ecx
     634:	04 00                	add    $0x0,%al
     636:	1b 01                	sbb    (%ecx),%eax
     638:	29 02                	sub    %eax,(%edx)	638: R_386_32	.debug_str
     63a:	00 00                	add    %al,(%eax)
     63c:	01 75 03             	add    %esi,0x3(%ebp)
		return 0;
	}
	s = "";

	return 0;
}
     63f:	01 5a 00             	add    %ebx,0x0(%edx)
     642:	00 00                	add    %al,(%eax)

	return 1;
}

int hex64_set(struct conf_var *var, const char *s)
{
     644:	81 00 00 00 a8 00    	addl   $0xa80000,(%eax)	644: R_386_32	.text
	648: R_386_32	.text
     64a:	00 00                	add    %al,(%eax)
	if (var->p == NULL) {
     64c:	cc                   	int3   	64c: R_386_32	.debug_loc
     64d:	00 00                	add    %al,(%eax)
     64f:	00 71 06             	add    %dh,0x6(%ecx)
		var->p = malloc(sizeof(unsigned long long int));
     652:	00 00                	add    %al,(%eax)
     654:	19 76 61             	sbb    %esi,0x61(%esi)
     657:	72 00                	jb     659 <.debug_info+0x659>
     659:	01 75 03             	add    %esi,0x3(%ebp)
     65c:	00 04 00             	add    %al,(%eax,%eax,1)
     65f:	00 02                	add    %al,(%edx)
	}

	sscanf(s, "%llX", (unsigned long long int *) (var->p));
     661:	91                   	xchg   %eax,%ecx
     662:	00 19                	add    %bl,(%ecx)
     664:	73 00                	jae    666 <.debug_info+0x666>
     666:	01 75 03             	add    %esi,0x3(%ebp)
     669:	e2 02                	loop   66d <.debug_info+0x66d>
     66b:	00 00                	add    %al,(%eax)
     66d:	02 91 04 00 1b 01    	add    0x11b0004(%ecx),%dl
     673:	5f                   	pop    %edi	673: R_386_32	.debug_str
     674:	01 00                	add    %eax,(%eax)
     676:	00 01                	add    %al,(%ecx)
     678:	41                   	inc    %ecx
     679:	03 01                	add    (%ecx),%eax

	return 1;
}
     67b:	5a                   	pop    %edx
     67c:	00 00                	add    %al,(%eax)
     67e:	00 a8 00 00 00 cf    	add    %ch,-0x31000000(%eax)	67f: R_386_32	.text
	683: R_386_32	.text
     684:	00 00                	add    %al,(%eax)
	sprintf(s, "0x%08X", *(unsigned int *) (var->p));
	return 1;
}

int hex32_set(struct conf_var *var, const char *s)
{
     686:	00 10                	add    %dl,(%eax)	687: R_386_32	.debug_loc
     688:	01 00                	add    %eax,(%eax)
     68a:	00 ac 06 00 00 19 76 	add    %ch,0x76190000(%esi,%eax,1)
	if (var->p == NULL) {
     691:	61                   	popa   
     692:	72 00                	jb     694 <.debug_info+0x694>
		var->p = malloc(sizeof(unsigned int));
     694:	01 41 03             	add    %eax,0x3(%ecx)
     697:	00 04 00             	add    %al,(%eax,%eax,1)
     69a:	00 02                	add    %al,(%edx)
     69c:	91                   	xchg   %eax,%ecx
     69d:	00 19                	add    %bl,(%ecx)
     69f:	73 00                	jae    6a1 <.debug_info+0x6a1>
     6a1:	01 41 03             	add    %eax,0x3(%ecx)
	}

	sscanf(s, "%X", (unsigned int *) (var->p));
     6a4:	e2 02                	loop   6a8 <.debug_info+0x6a8>
     6a6:	00 00                	add    %al,(%eax)
     6a8:	02 91 04 00 1b 01    	add    0x11b0004(%ecx),%dl
     6ae:	a1 00 00 00 01       	mov    0x1000000,%eax	6ae: R_386_32	.debug_str
     6b3:	2d 03 01 5a 00       	sub    $0x5a0103,%eax
     6b8:	00 00                	add    %al,(%eax)
     6ba:	cf                   	iret   	6ba: R_386_32	.text
     6bb:	00 00                	add    %al,(%eax)
	return 1;
}
     6bd:	00 f6                	add    %dh,%dh	6be: R_386_32	.text
     6bf:	00 00                	add    %al,(%eax)
     6c1:	00 54 01 00          	add    %dl,0x0(%ecx,%eax,1)	6c2: R_386_32	.debug_loc
     6c5:	00 e7                	add    %ah,%bh
	sprintf(s, "0x%04X", *(unsigned int *) (var->p));
	return 1;
}

int hex16_set(struct conf_var *var, const char *s)
{
     6c7:	06                   	push   %es
     6c8:	00 00                	add    %al,(%eax)
     6ca:	19 76 61             	sbb    %esi,0x61(%esi)
     6cd:	72 00                	jb     6cf <.debug_info+0x6cf>
	if (var->p == NULL) {
     6cf:	01 2d 03 00 04 00    	add    %ebp,0x40003
		var->p = malloc(sizeof(unsigned int));
     6d5:	00 02                	add    %al,(%edx)
     6d7:	91                   	xchg   %eax,%ecx
     6d8:	00 19                	add    %bl,(%ecx)
     6da:	73 00                	jae    6dc <.debug_info+0x6dc>
     6dc:	01 2d 03 e2 02 00    	add    %ebp,0x2e203
     6e2:	00 02                	add    %al,(%edx)
	}
	sscanf(s, "%X", (unsigned int *) (var->p));
     6e4:	91                   	xchg   %eax,%ecx
     6e5:	04 00                	add    $0x0,%al
     6e7:	1b 01                	sbb    (%ecx),%eax
     6e9:	e8 02 00 00 01       	call   10006f0 <ipport_set+0xfff42d>	6e9: R_386_32	.debug_str
     6ee:	1d 03 01 5a 00       	sbb    $0x5a0103,%eax
     6f3:	00 00                	add    %al,(%eax)
     6f5:	f6 00 00             	testb  $0x0,(%eax)	6f5: R_386_32	.text
     6f8:	00 1d 01 00 00 98    	add    %bl,0x98000001	6f9: R_386_32	.text
	6fd: R_386_32	.debug_loc
     6fe:	01 00                	add    %eax,(%eax)
	return 1;
}
     700:	00 22                	add    %ah,(%edx)
     702:	07                   	pop    %es
     703:	00 00                	add    %al,(%eax)
     705:	19 76 61             	sbb    %esi,0x61(%esi)
     708:	72 00                	jb     70a <.debug_info+0x70a>
	sprintf(s, "0x%02X", *(unsigned char *) (var->p));
	return 1;
}

int hex8_set(struct conf_var *var, const char *s)
{
     70a:	01 1d 03 00 04 00    	add    %ebx,0x40003
     710:	00 02                	add    %al,(%edx)
	if (var->p == NULL) {
     712:	91                   	xchg   %eax,%ecx
     713:	00 19                	add    %bl,(%ecx)
     715:	73 00                	jae    717 <.debug_info+0x717>
		var->p = malloc(sizeof(unsigned int));
     717:	01 1d 03 e2 02 00    	add    %ebx,0x2e203
     71d:	00 02                	add    %al,(%edx)
     71f:	91                   	xchg   %eax,%ecx
     720:	04 00                	add    $0x0,%al
     722:	1b 01                	sbb    (%ecx),%eax
     724:	43                   	inc    %ebx	724: R_386_32	.debug_str
     725:	05 00 00 01 09       	add    $0x9010000,%eax
	}
	sscanf(s, "%X", (unsigned int *) (var->p));
     72a:	03 01                	add    (%ecx),%eax
     72c:	5a                   	pop    %edx
     72d:	00 00                	add    %al,(%eax)
     72f:	00 1d 01 00 00 44    	add    %bl,0x44000001	730: R_386_32	.text
	734: R_386_32	.text
     735:	01 00                	add    %eax,(%eax)
     737:	00 dc                	add    %bl,%ah	738: R_386_32	.debug_loc
     739:	01 00                	add    %eax,(%eax)
     73b:	00 5d 07             	add    %bl,0x7(%ebp)
     73e:	00 00                	add    %al,(%eax)
     740:	19 76 61             	sbb    %esi,0x61(%esi)
	return 1;
}
     743:	72 00                	jb     745 <.debug_info+0x745>
     745:	01 09                	add    %ecx,(%ecx)
     747:	03 00                	add    (%eax),%eax
     749:	04 00                	add    $0x0,%al
	sprintf(s, "%f", *(double *) (var->p));
	return 1;
}

int float_set(struct conf_var *var, const char *s)
{
     74b:	00 02                	add    %al,(%edx)
     74d:	91                   	xchg   %eax,%ecx
     74e:	00 19                	add    %bl,(%ecx)
     750:	73 00                	jae    752 <.debug_info+0x752>
     752:	01 09                	add    %ecx,(%ecx)
	if (var->p == NULL) {
     754:	03 e2                	add    %edx,%esp
     756:	02 00                	add    (%eax),%al
     758:	00 02                	add    %al,(%edx)
		var->p = malloc(sizeof(double));
     75a:	91                   	xchg   %eax,%ecx
     75b:	04 00                	add    $0x0,%al
     75d:	1b 01                	sbb    (%ecx),%eax
     75f:	8f 01                	popl   (%ecx)	75f: R_386_32	.debug_str
     761:	00 00                	add    %al,(%eax)
     763:	01 f5                	add    %esi,%ebp
     765:	02 01                	add    (%ecx),%al
     767:	5a                   	pop    %edx
	}
	sscanf(s, "%lf", (double *) (var->p));
     768:	00 00                	add    %al,(%eax)
     76a:	00 44 01 00          	add    %al,0x0(%ecx,%eax,1)	76b: R_386_32	.text
     76e:	00 6b 01             	add    %ch,0x1(%ebx)	76f: R_386_32	.text
     771:	00 00                	add    %al,(%eax)
     773:	20 02                	and    %al,(%edx)	773: R_386_32	.debug_loc
     775:	00 00                	add    %al,(%eax)
     777:	98                   	cwtl   
     778:	07                   	pop    %es
     779:	00 00                	add    %al,(%eax)
     77b:	19 76 61             	sbb    %esi,0x61(%esi)
     77e:	72 00                	jb     780 <.debug_info+0x780>
     780:	01 f5                	add    %esi,%ebp
     782:	02 00                	add    (%eax),%al
	return 1;
}
     784:	04 00                	add    $0x0,%al
     786:	00 02                	add    %al,(%edx)
     788:	91                   	xchg   %eax,%ecx
     789:	00 19                	add    %bl,(%ecx)
     78b:	73 00                	jae    78d <.debug_info+0x78d>
	sprintf(s, "%p", var->p);
	return 1;
}

int void_set(struct conf_var *var, const char *s)
{
     78d:	01 f5                	add    %esi,%ebp
     78f:	02 e2                	add    %dl,%ah
	sscanf(s, "%p", &(var->p));
     791:	02 00                	add    (%eax),%al
     793:	00 02                	add    %al,(%edx)
     795:	91                   	xchg   %eax,%ecx
     796:	04 00                	add    $0x0,%al
     798:	1b 01                	sbb    (%ecx),%eax
     79a:	d7                   	xlat   %ds:(%ebx)	79a: R_386_32	.debug_str
     79b:	00 00                	add    %al,(%eax)
     79d:	00 01                	add    %al,(%ecx)
     79f:	e6 02                	out    %al,$0x2
     7a1:	01 5a 00             	add    %ebx,0x0(%edx)
     7a4:	00 00                	add    %al,(%eax)
     7a6:	6b 01 00             	imul   $0x0,(%ecx),%eax	7a6: R_386_32	.text
     7a9:	00 92 01 00 00 64    	add    %dl,0x64000001(%edx)	7aa: R_386_32	.text
	7ae: R_386_32	.debug_loc
	return 1;
}
     7af:	02 00                	add    (%eax),%al
     7b1:	00 d3                	add    %dl,%bl
     7b3:	07                   	pop    %es
     7b4:	00 00                	add    %al,(%eax)
     7b6:	19 76 61             	sbb    %esi,0x61(%esi)
	sprintf(s, "%c", *(char *) (var->p));
	return 1;
}

int char_set(struct conf_var *var, const char *s)
{
     7b9:	72 00                	jb     7bb <.debug_info+0x7bb>
     7bb:	01 e6                	add    %esp,%esi
     7bd:	02 00                	add    (%eax),%al
     7bf:	04 00                	add    $0x0,%al
	char *cp;			/* source */

	if (var->p == NULL) {
     7c1:	00 02                	add    %al,(%edx)
     7c3:	91                   	xchg   %eax,%ecx
     7c4:	00 19                	add    %bl,(%ecx)
     7c6:	73 00                	jae    7c8 <.debug_info+0x7c8>
		var->p = malloc(sizeof(char));
     7c8:	01 e6                	add    %esp,%esi
     7ca:	02 e2                	add    %dl,%ah
     7cc:	02 00                	add    (%eax),%al
     7ce:	00 02                	add    %al,(%edx)
     7d0:	91                   	xchg   %eax,%ecx
     7d1:	04 00                	add    $0x0,%al
     7d3:	1b 01                	sbb    (%ecx),%eax
     7d5:	b8 03 00 00 01       	mov    $0x1000003,%eax	7d5: R_386_32	.debug_str
	}

	cp = (char *) s;
	LTRIM(cp);
     7da:	d2 02                	rolb   %cl,(%edx)
     7dc:	01 5a 00             	add    %ebx,0x0(%edx)
     7df:	00 00                	add    %al,(%eax)
     7e1:	92                   	xchg   %eax,%edx	7e1: R_386_32	.text
     7e2:	01 00                	add    %eax,(%eax)
     7e4:	00 b9 01 00 00 a8    	add    %bh,-0x57ffffff(%ecx)	7e5: R_386_32	.text
	7e9: R_386_32	.debug_loc
     7ea:	02 00                	add    (%eax),%al
     7ec:	00 0e                	add    %cl,(%esi)
     7ee:	08 00                	or     %al,(%eax)
     7f0:	00 19                	add    %bl,(%ecx)
     7f2:	76 61                	jbe    855 <.debug_info+0x855>
     7f4:	72 00                	jb     7f6 <.debug_info+0x7f6>
     7f6:	01 d2                	add    %edx,%edx

	//printf("*** %s: var '%s' source='%s'\n", __FUNCTION__, var->name, cp);

	sscanf(cp, "%c", (char *) (var->p));
     7f8:	02 00                	add    (%eax),%al
     7fa:	04 00                	add    $0x0,%al
     7fc:	00 02                	add    %al,(%edx)
     7fe:	91                   	xchg   %eax,%ecx
     7ff:	00 19                	add    %bl,(%ecx)
     801:	73 00                	jae    803 <.debug_info+0x803>
     803:	01 d2                	add    %edx,%edx
     805:	02 e2                	add    %dl,%ah
     807:	02 00                	add    (%eax),%al
     809:	00 02                	add    %al,(%edx)
     80b:	91                   	xchg   %eax,%ecx
     80c:	04 00                	add    $0x0,%al
	return 1;
}
     80e:	1b 01                	sbb    (%ecx),%eax
     810:	3a 05 00 00 01 be    	cmp    0xbe010000,%al	810: R_386_32	.debug_str
     816:	02 01                	add    (%ecx),%al
     818:	5a                   	pop    %edx
		sprintf(s, "True");
	return 1;
}

int bool_set(struct conf_var *var, const char *s)
{
     819:	00 00                	add    %al,(%eax)
     81b:	00 b9 01 00 00 e0    	add    %bh,-0x1fffffff(%ecx)	81c: R_386_32	.text
	820: R_386_32	.text
     821:	01 00                	add    %eax,(%eax)
	char *cp;			/* source */

	if (var->p == NULL) {
     823:	00 ec                	add    %ch,%ah	824: R_386_32	.debug_loc
     825:	02 00                	add    (%eax),%al
     827:	00 49 08             	add    %cl,0x8(%ecx)
		var->p = malloc(sizeof(int));
     82a:	00 00                	add    %al,(%eax)
     82c:	19 76 61             	sbb    %esi,0x61(%esi)
     82f:	72 00                	jb     831 <.debug_info+0x831>
     831:	01 be 02 00 04 00    	add    %edi,0x40002(%esi)
	}

	cp = (char *) s;
	LTRIM(cp);
     837:	00 02                	add    %al,(%edx)
     839:	91                   	xchg   %eax,%ecx
     83a:	00 19                	add    %bl,(%ecx)
     83c:	73 00                	jae    83e <.debug_info+0x83e>
     83e:	01 be 02 e2 02 00    	add    %edi,0x2e202(%esi)
     844:	00 02                	add    %al,(%edx)
     846:	91                   	xchg   %eax,%ecx
     847:	04 00                	add    $0x0,%al
     849:	1b 01                	sbb    (%ecx),%eax
     84b:	20 04 00             	and    %al,(%eax,%eax,1)	84b: R_386_32	.debug_str
     84e:	00 01                	add    %al,(%ecx)
     850:	88 01                	mov    %al,(%ecx)
     852:	01 5a 00             	add    %ebx,0x0(%edx)
     855:	00 00                	add    %al,(%eax)
     857:	e0 01                	loopne 85a <.debug_info+0x85a>	857: R_386_32	.text

	if (!strncasecmp(cp, "TRUE", 4) ||
     859:	00 00                	add    %al,(%eax)
     85b:	2b 02                	sub    (%edx),%eax	85b: R_386_32	.text
     85d:	00 00                	add    %al,(%eax)
     85f:	30 03                	xor    %al,(%ebx)	85f: R_386_32	.debug_loc
     861:	00 00                	add    %al,(%eax)
     863:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
     864:	08 00                	or     %al,(%eax)
     866:	00 19                	add    %bl,(%ecx)
     868:	76 61                	jbe    8cb <.debug_info+0x8cb>
     86a:	72 00                	jb     86c <.debug_info+0x86c>
     86c:	01 88 01 00 04 00    	add    %ecx,0x40001(%eax)
     872:	00 02                	add    %al,(%edx)
		!strncasecmp(cp, "YES", 3) ||
     874:	91                   	xchg   %eax,%ecx
     875:	00 19                	add    %bl,(%ecx)
     877:	73 00                	jae    879 <.debug_info+0x879>
     879:	01 88 01 99 00 00    	add    %ecx,0x9901(%eax)
     87f:	00 02                	add    %al,(%edx)
     881:	91                   	xchg   %eax,%ecx
     882:	04 1c                	add    $0x1c,%al
     884:	58                   	pop    %eax
     885:	04 00                	add    $0x0,%al
     887:	00 fe                	add    %bh,%dh	888: R_386_32	.text
     889:	01 00                	add    %eax,(%eax)
     88b:	00 22                	add    %ah,(%edx)	88c: R_386_32	.text
	}

	cp = (char *) s;
	LTRIM(cp);

	if (!strncasecmp(cp, "TRUE", 4) ||
     88d:	02 00                	add    (%eax),%al
     88f:	00 01                	add    %al,(%ecx)
		!strncasecmp(cp, "YES", 3) ||
		!strncasecmp(cp, "ON", 2) || !strncasecmp(cp, "1", 1)) {
     891:	8f 01                	popl   (%ecx)
     893:	1d 76 04 00 00       	sbb    $0x476,%eax
     898:	5c                   	pop    %esp	898: R_386_32	.debug_loc
     899:	03 00                	add    (%eax),%eax
     89b:	00 1d 6b 04 00 00    	add    %bl,0x46b
     8a1:	74 03                	je     8a6 <.debug_info+0x8a6>	8a1: R_386_32	.debug_loc
     8a3:	00 00                	add    %al,(%eax)
     8a5:	00 00                	add    %al,(%eax)
     8a7:	1b 01                	sbb    (%ecx),%eax

	cp = (char *) s;
	LTRIM(cp);

	if (!strncasecmp(cp, "TRUE", 4) ||
		!strncasecmp(cp, "YES", 3) ||
     8a9:	58                   	pop    %eax	8a9: R_386_32	.debug_str
     8aa:	03 00                	add    (%eax),%eax
		!strncasecmp(cp, "ON", 2) || !strncasecmp(cp, "1", 1)) {
     8ac:	00 01                	add    %al,(%ecx)
     8ae:	99                   	cltd   
     8af:	01 01                	add    %eax,(%ecx)
     8b1:	5a                   	pop    %edx
     8b2:	00 00                	add    %al,(%eax)
     8b4:	00 2b                	add    %ch,(%ebx)	8b5: R_386_32	.text
     8b6:	02 00                	add    (%eax),%al
     8b8:	00 78 02             	add    %bh,0x2(%eax)	8b9: R_386_32	.text
     8bb:	00 00                	add    %al,(%eax)
     8bd:	88 03                	mov    %al,(%ebx)	8bd: R_386_32	.debug_loc
     8bf:	00 00                	add    %al,(%eax)
     8c1:	05 09 00 00 19       	add    $0x19000009,%eax
     8c6:	76 61                	jbe    929 <.debug_info+0x929>

		*((int *) var->p) = 1;
     8c8:	72 00                	jb     8ca <.debug_info+0x8ca>
     8ca:	01 99 01 00 04 00    	add    %ebx,0x40001(%ecx)
     8d0:	00 02                	add    %al,(%edx)
		return 1;
     8d2:	91                   	xchg   %eax,%ecx
     8d3:	00 19                	add    %bl,(%ecx)
     8d5:	73 00                	jae    8d7 <.debug_info+0x8d7>
     8d7:	01 99 01 99 00 00    	add    %ebx,0x9901(%ecx)
	}

	if (!strncasecmp(cp, "FALSE", 5) ||
     8dd:	00 02                	add    %al,(%edx)
     8df:	91                   	xchg   %eax,%ecx
     8e0:	04 1c                	add    $0x1c,%al
     8e2:	58                   	pop    %eax
     8e3:	04 00                	add    $0x0,%al
     8e5:	00 49 02             	add    %cl,0x2(%ecx)	8e6: R_386_32	.text
     8e8:	00 00                	add    %al,(%eax)
     8ea:	6f                   	outsl  %ds:(%esi),(%dx)	8ea: R_386_32	.text
     8eb:	02 00                	add    (%eax),%al
     8ed:	00 01                	add    %al,(%ecx)
     8ef:	a0 01 1d 76 04       	mov    0x4761d01,%al
     8f4:	00 00                	add    %al,(%eax)
     8f6:	b4 03                	mov    $0x3,%ah	8f6: R_386_32	.debug_loc
		!strncasecmp(cp, "NO", 2) ||
     8f8:	00 00                	add    %al,(%eax)
     8fa:	1d 6b 04 00 00       	sbb    $0x46b,%eax
     8ff:	cc                   	int3   	8ff: R_386_32	.debug_loc
     900:	03 00                	add    (%eax),%eax
     902:	00 00                	add    %al,(%eax)
     904:	00 1b                	add    %bl,(%ebx)
     906:	01 0e                	add    %ecx,(%esi)	907: R_386_32	.debug_str
     908:	06                   	push   %es
     909:	00 00                	add    %al,(%eax)
     90b:	01 b3 01 01 5a 00    	add    %esi,0x5a0101(%ebx)

		*((int *) var->p) = 1;
		return 1;
	}

	if (!strncasecmp(cp, "FALSE", 5) ||
     911:	00 00                	add    %al,(%eax)
		!strncasecmp(cp, "NO", 2) ||
		!strncasecmp(cp, "OFF", 3) || !strncasecmp(cp, "0", 1)) {
     913:	78 02                	js     917 <.debug_info+0x917>	913: R_386_32	.text
     915:	00 00                	add    %al,(%eax)
     917:	c5 02                	lds    (%edx),%eax	917: R_386_32	.text
     919:	00 00                	add    %al,(%eax)
     91b:	e0 03                	loopne 920 <.debug_info+0x920>	91b: R_386_32	.debug_loc
     91d:	00 00                	add    %al,(%eax)
     91f:	63 09                	arpl   %cx,(%ecx)
     921:	00 00                	add    %al,(%eax)
     923:	19 76 61             	sbb    %esi,0x61(%esi)
     926:	72 00                	jb     928 <.debug_info+0x928>
     928:	01 b3 01 00 04 00    	add    %esi,0x40001(%ebx)
		*((int *) var->p) = 1;
		return 1;
	}

	if (!strncasecmp(cp, "FALSE", 5) ||
		!strncasecmp(cp, "NO", 2) ||
     92e:	00 02                	add    %al,(%edx)
		!strncasecmp(cp, "OFF", 3) || !strncasecmp(cp, "0", 1)) {
     930:	91                   	xchg   %eax,%ecx
     931:	00 19                	add    %bl,(%ecx)
     933:	73 00                	jae    935 <.debug_info+0x935>
     935:	01 b3 01 99 00 00    	add    %esi,0x9901(%ebx)
     93b:	00 02                	add    %al,(%edx)
     93d:	91                   	xchg   %eax,%ecx
     93e:	04 1c                	add    $0x1c,%al
     940:	58                   	pop    %eax
     941:	04 00                	add    $0x0,%al
     943:	00 96 02 00 00 bc    	add    %dl,-0x43fffffe(%esi)	944: R_386_32	.text
	948: R_386_32	.text

		*((int *) var->p) = 0;
		return 1;
	}

	return 0;
     949:	02 00                	add    (%eax),%al
     94b:	00 01                	add    %al,(%ecx)
     94d:	ba 01 1d 76 04       	mov    $0x4761d01,%edx

	if (!strncasecmp(cp, "FALSE", 5) ||
		!strncasecmp(cp, "NO", 2) ||
		!strncasecmp(cp, "OFF", 3) || !strncasecmp(cp, "0", 1)) {

		*((int *) var->p) = 0;
     952:	00 00                	add    %al,(%eax)
     954:	0c 04                	or     $0x4,%al	954: R_386_32	.debug_loc
     956:	00 00                	add    %al,(%eax)
     958:	1d 6b 04 00 00       	sbb    $0x46b,%eax
		return 1;
     95d:	24 04                	and    $0x4,%al	95d: R_386_32	.debug_loc
     95f:	00 00                	add    %al,(%eax)
	}

	return 0;
}
     961:	00 00                	add    %al,(%eax)
     963:	1b 01                	sbb    (%ecx),%eax
     965:	0b 01                	or     (%ecx),%eax	965: R_386_32	.debug_str

	return 1;
}

int string_set(struct conf_var *var, const char *s)
{
     967:	00 00                	add    %al,(%eax)
     969:	01 cd                	add    %ecx,%ebp
     96b:	01 01                	add    %eax,(%ecx)
     96d:	5a                   	pop    %edx
     96e:	00 00                	add    %al,(%eax)
     970:	00 c5                	add    %al,%ch	971: R_386_32	.text
     972:	02 00                	add    (%eax),%al
	char *cp;			/* source */
	int len;
	char quote;
	char *ep;

	if ((!s) || (!var))
     974:	00 12                	add    %dl,(%edx)	975: R_386_32	.text
     976:	03 00                	add    (%eax),%eax
     978:	00 38                	add    %bh,(%eax)	979: R_386_32	.debug_loc
     97a:	04 00                	add    $0x0,%al
     97c:	00 c1                	add    %al,%cl
     97e:	09 00                	or     %eax,(%eax)
     980:	00 19                	add    %bl,(%ecx)
     982:	76 61                	jbe    9e5 <.debug_info+0x9e5>
		return 0;

	cp = (char *) s;
	LTRIM(cp);
     984:	72 00                	jb     986 <.debug_info+0x986>
     986:	01 cd                	add    %ecx,%ebp
     988:	01 00                	add    %eax,(%eax)
     98a:	04 00                	add    $0x0,%al
     98c:	00 02                	add    %al,(%edx)
     98e:	91                   	xchg   %eax,%ecx
     98f:	00 19                	add    %bl,(%ecx)
     991:	73 00                	jae    993 <.debug_info+0x993>
     993:	01 cd                	add    %ecx,%ebp
     995:	01 99 00 00 00 02    	add    %ebx,0x2000000(%ecx)
     99b:	91                   	xchg   %eax,%ecx
     99c:	04 1c                	add    $0x1c,%al
     99e:	58                   	pop    %eax
     99f:	04 00                	add    $0x0,%al
     9a1:	00 e3                	add    %ah,%bl	9a2: R_386_32	.text
     9a3:	02 00                	add    (%eax),%al
     9a5:	00 09                	add    %cl,(%ecx)	9a6: R_386_32	.text
     9a7:	03 00                	add    (%eax),%eax
	if ((*cp == '"') || (*cp == '\'')) {
     9a9:	00 01                	add    %al,(%ecx)
     9ab:	d4 01                	aam    $0x1
     9ad:	1d 76 04 00 00       	sbb    $0x476,%eax
		quote = *cp;
		cp++;
     9b2:	64                   	fs	9b2: R_386_32	.debug_loc
     9b3:	04 00                	add    $0x0,%al
		if ((ep = strchr(cp, quote)) != NULL)
     9b5:	00 1d 6b 04 00 00    	add    %bl,0x46b
     9bb:	7c 04                	jl     9c1 <.debug_info+0x9c1>	9bb: R_386_32	.debug_loc
     9bd:	00 00                	add    %al,(%eax)
     9bf:	00 00                	add    %al,(%eax)
     9c1:	1b 01                	sbb    (%ecx),%eax
     9c3:	d2 04 00             	rolb   %cl,(%eax,%eax,1)	9c3: R_386_32	.debug_str
			len = ep - cp;
     9c6:	00 01                	add    %al,(%ecx)
	cp = (char *) s;
	LTRIM(cp);
	if ((*cp == '"') || (*cp == '\'')) {
		quote = *cp;
		cp++;
		if ((ep = strchr(cp, quote)) != NULL)
     9c8:	e1 01                	loope  9cb <.debug_info+0x9cb>
     9ca:	01 5a 00             	add    %ebx,0x0(%edx)

# ifdef __va_arg_pack
__extern_always_inline int
fprintf (FILE *__restrict __stream, __const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
     9cd:	00 00                	add    %al,(%eax)
     9cf:	12 03                	adc    (%ebx),%al	9cf: R_386_32	.text
     9d1:	00 00                	add    %al,(%eax)
     9d3:	5d                   	pop    %ebp	9d3: R_386_32	.text
     9d4:	03 00                	add    (%eax),%eax
     9d6:	00 90 04 00 00 2e    	add    %dl,0x2e000004(%eax)	9d7: R_386_32	.debug_loc
     9dc:	0a 00                	or     (%eax),%al
     9de:	00 19                	add    %bl,(%ecx)
     9e0:	76 61                	jbe    a43 <.debug_info+0xa43>
     9e2:	72 00                	jb     9e4 <.debug_info+0x9e4>
     9e4:	01 e1                	add    %esp,%ecx
     9e6:	01 00                	add    %eax,(%eax)
     9e8:	04 00                	add    $0x0,%al
     9ea:	00 02                	add    %al,(%edx)
     9ec:	91                   	xchg   %eax,%ecx
     9ed:	00 19                	add    %bl,(%ecx)
     9ef:	73 00                	jae    9f1 <.debug_info+0x9f1>
			len = ep - cp;
		else {
#ifdef DEBUG
			fprintf(stderr, "Unterminated string.\n");
#endif
			len = 0;
     9f1:	01 e1                	add    %esp,%ecx
     9f3:	01 99 00 00 00 02    	add    %ebx,0x2000000(%ecx)
	if ((!s) || (!var))
		return 0;

	cp = (char *) s;
	LTRIM(cp);
	if ((*cp == '"') || (*cp == '\'')) {
     9f9:	91                   	xchg   %eax,%ecx
#endif
			len = 0;
		}

	} else {
		len = strlen(cp);
     9fa:	04 1e                	add    $0x1e,%al
     9fc:	63 70 00             	arpl   %si,0x0(%eax)
     9ff:	01 e3                	add    %esp,%ebx
     a01:	01 99 00 00 00 bc    	add    %ebx,-0x44000000(%ecx)	a06: R_386_32	.debug_loc
     a07:	04 00                	add    $0x0,%al
     a09:	00 1c 58             	add    %bl,(%eax,%ebx,2)
     a0c:	04 00                	add    $0x0,%al
	}

	if (var->p == NULL) {
     a0e:	00 30                	add    %dh,(%eax)	a0f: R_386_32	.text
     a10:	03 00                	add    (%eax),%eax
     a12:	00 54 03 00          	add    %dl,0x0(%ebx,%eax,1)	a13: R_386_32	.text
		var->p = malloc(len + 1);
     a16:	00 01                	add    %al,(%ecx)
     a18:	eb 01                	jmp    a1b <.debug_info+0xa1b>
     a1a:	1d 76 04 00 00       	sbb    $0x476,%eax
     a1f:	d3 04 00             	roll   %cl,(%eax,%eax,1)	a1f: R_386_32	.debug_loc
	}

	if (var->len > 0)
     a22:	00 1d 6b 04 00 00    	add    %bl,0x46b
		len = MIN(len, var->len);
     a28:	eb 04                	jmp    a2e <.debug_info+0xa2e>	a28: R_386_32	.debug_loc
     a2a:	00 00                	add    %al,(%eax)
     a2c:	00 00                	add    %al,(%eax)

__extern_always_inline char *
__NTH (strncpy (char *__restrict __dest, __const char *__restrict __src,
		size_t __len))
{
  return __builtin___strncpy_chk (__dest, __src, __len, __bos (__dest));
     a2e:	18 01                	sbb    %al,(%ecx)
     a30:	5c                   	pop    %esp	a30: R_386_32	.debug_str
     a31:	05 00 00 01 1a       	add    $0x1a010000,%eax
     a36:	02 01                	add    (%ecx),%al
     a38:	5a                   	pop    %edx
     a39:	00 00                	add    %al,(%eax)
     a3b:	00 5d 03             	add    %bl,0x3(%ebp)	a3c: R_386_32	.text
     a3e:	00 00                	add    %al,(%eax)

	strncpy((char *) (var->p), cp, len);
	cp = (char *)(var->p);
	cp[len] = '\0';
     a40:	8b 03                	mov    (%ebx),%eax	a40: R_386_32	.text
     a42:	00 00                	add    %al,(%eax)
     a44:	02 74 04 68          	add    0x68(%esp,%eax,1),%dh

	return 1;
     a48:	0a 00                	or     (%eax),%al
     a4a:	00 19                	add    %bl,(%ecx)
     a4c:	76 61                	jbe    aaf <.debug_info+0xaaf>
	int len;
	char quote;
	char *ep;

	if ((!s) || (!var))
		return 0;
     a4e:	72 00                	jb     a50 <.debug_info+0xa50>
     a50:	01 1a                	add    %ebx,(%edx)
     a52:	02 00                	add    (%eax),%al
	strncpy((char *) (var->p), cp, len);
	cp = (char *)(var->p);
	cp[len] = '\0';

	return 1;
}
     a54:	04 00                	add    $0x0,%al
     a56:	00 02                	add    %al,(%edx)
     a58:	91                   	xchg   %eax,%ecx
     a59:	00 19                	add    %bl,(%ecx)
	sprintf(s, "%u", *(unsigned int *) (var->p));
	return 1;
}

int uint_set(struct conf_var *var, const char *s)
{
     a5b:	73 00                	jae    a5d <.debug_info+0xa5d>
     a5d:	01 1a                	add    %ebx,(%edx)
     a5f:	02 99 00 00 00 02    	add    0x2000000(%ecx),%bl
	unsigned int *p;

	if (var->p == NULL) {
     a65:	91                   	xchg   %eax,%ecx
     a66:	04 00                	add    $0x0,%al
		var->p = malloc(sizeof(unsigned int));
     a68:	1b 01                	sbb    (%ecx),%eax
     a6a:	b4 04                	mov    $0x4,%ah	a6a: R_386_32	.debug_str
     a6c:	00 00                	add    %al,(%eax)
     a6e:	01 41 02             	add    %eax,0x2(%ecx)
     a71:	01 5a 00             	add    %ebx,0x0(%edx)
     a74:	00 00                	add    %al,(%eax)
     a76:	8b 03                	mov    (%ebx),%eax	a76: R_386_32	.text
	}

	p = (unsigned int *) var->p;
     a78:	00 00                	add    %al,(%eax)

	*p = strtoul(s, NULL, 0);
     a7a:	d9 03                	flds   (%ebx)	a7a: R_386_32	.text
     a7c:	00 00                	add    %al,(%eax)
     a7e:	ff 04 00             	incl   (%eax,%eax,1)	a7e: R_386_32	.debug_loc
     a81:	00 c6                	add    %al,%dh
     a83:	0a 00                	or     (%eax),%al
     a85:	00 19                	add    %bl,(%ecx)
     a87:	76 61                	jbe    aea <.debug_info+0xaea>
     a89:	72 00                	jb     a8b <.debug_info+0xa8b>
     a8b:	01 41 02             	add    %eax,0x2(%ecx)
     a8e:	00 04 00             	add    %al,(%eax,%eax,1)
     a91:	00 02                	add    %al,(%edx)
     a93:	91                   	xchg   %eax,%ecx
     a94:	00 19                	add    %bl,(%ecx)
     a96:	73 00                	jae    a98 <.debug_info+0xa98>

	return 1;
}
     a98:	01 41 02             	add    %eax,0x2(%ecx)
     a9b:	99                   	cltd   
     a9c:	00 00                	add    %al,(%eax)
     a9e:	00 02                	add    %al,(%edx)
     aa0:	91                   	xchg   %eax,%ecx
     aa1:	04 1c                	add    $0x1c,%al
	sprintf(s, "%i", *(int *) (var->p));
	return 1;
}

int int_set(struct conf_var *var, const char *s)
{
     aa3:	58                   	pop    %eax
     aa4:	04 00                	add    $0x0,%al
     aa6:	00 b0 03 00 00 d0    	add    %dh,-0x2ffffffd(%eax)	aa7: R_386_32	.text
	aab: R_386_32	.text
	int *p;

	if (var->p == NULL) {
     aac:	03 00                	add    (%eax),%eax
     aae:	00 01                	add    %al,(%ecx)
		var->p = malloc(sizeof(int));
     ab0:	4a                   	dec    %edx
     ab1:	02 1d 76 04 00 00    	add    0x476,%bl
     ab7:	2b 05 00 00 1d 6b    	sub    0x6b1d0000,%eax	ab7: R_386_32	.debug_loc
     abd:	04 00                	add    $0x0,%al
	}

	p = (int *) var->p;
     abf:	00 43 05             	add    %al,0x5(%ebx)	ac0: R_386_32	.debug_loc

	*p = strtol(s, NULL, 0);
     ac2:	00 00                	add    %al,(%eax)
     ac4:	00 00                	add    %al,(%eax)
     ac6:	1b 01                	sbb    (%ecx),%eax
     ac8:	35 00 00 00 01       	xor    $0x1000000,%eax	ac8: R_386_32	.debug_str
     acd:	5f                   	pop    %edi
     ace:	02 01                	add    (%ecx),%al
     ad0:	5a                   	pop    %edx
     ad1:	00 00                	add    %al,(%eax)
     ad3:	00 d9                	add    %bl,%cl	ad4: R_386_32	.text
     ad5:	03 00                	add    (%eax),%eax
     ad7:	00 27                	add    %ah,(%edi)	ad8: R_386_32	.text
     ad9:	04 00                	add    $0x0,%al
     adb:	00 57 05             	add    %dl,0x5(%edi)	adc: R_386_32	.debug_loc
     ade:	00 00                	add    %al,(%eax)

	return 1;
}
     ae0:	24 0b                	and    $0xb,%al
     ae2:	00 00                	add    %al,(%eax)
     ae4:	19 76 61             	sbb    %esi,0x61(%esi)
     ae7:	72 00                	jb     ae9 <.debug_info+0xae9>
     ae9:	01 5f 02             	add    %ebx,0x2(%edi)
/*
* Recursive writes a section into a stream
*
*/
static int write_section(FILE * f, struct conf_var *section, char *branch)
{
     aec:	00 04 00             	add    %al,(%eax,%eax,1)
     aef:	00 02                	add    %al,(%edx)
     af1:	91                   	xchg   %eax,%ecx
     af2:	00 19                	add    %bl,(%ecx)
     af4:	73 00                	jae    af6 <.debug_info+0xaf6>
     af6:	01 5f 02             	add    %ebx,0x2(%edi)
     af9:	99                   	cltd   
     afa:	00 00                	add    %al,(%eax)
     afc:	00 02                	add    %al,(%edx)
     afe:	91                   	xchg   %eax,%ecx
     aff:	04 1c                	add    $0x1c,%al
     b01:	58                   	pop    %eax
     b02:	04 00                	add    $0x0,%al
     b04:	00 fe                	add    %bh,%dh	b05: R_386_32	.text
     b06:	03 00                	add    (%eax),%eax
	struct conf_var *queue[1024];
	int head = 0;
	int tail = 0;

	if (section == NULL)
		return 0;
     b08:	00 1e                	add    %bl,(%esi)	b09: R_386_32	.text
     b0a:	04 00                	add    $0x0,%al
     b0c:	00 01                	add    %al,(%ecx)
     b0e:	66                   	data16
	/* define a queue for sections */
	struct conf_var *queue[1024];
	int head = 0;
	int tail = 0;

	if (section == NULL)
     b0f:	02 1d 76 04 00 00    	add    0x476,%bl
     b15:	83 05 00 00 1d 6b 04 	addl   $0x4,0x6b1d0000	b15: R_386_32	.debug_loc
		return 0;

	entry = section;
	while (entry->name != NULL) {
     b1c:	00 00                	add    %al,(%eax)
     b1e:	9b                   	fwait	b1e: R_386_32	.debug_loc
     b1f:	05 00 00 00 00       	add    $0x0,%eax
     b24:	1b 01                	sbb    (%ecx),%eax
     b26:	51                   	push   %ecx	b26: R_386_32	.debug_str
     b27:	04 00                	add    $0x0,%al
     b29:	00 01                	add    %al,(%ecx)

		if (entry->type == CONF_TYPE(CONF_SECTION)) {
			queue[tail++] = (struct conf_var *) entry;
		} else {
			if (entry->type->t_get(entry, buf)) {
     b2b:	73 02                	jae    b2f <.debug_info+0xb2f>
     b2d:	01 5a 00             	add    %ebx,0x0(%edx)
     b30:	00 00                	add    %al,(%eax)
     b32:	27                   	daa    	b32: R_386_32	.text
     b33:	04 00                	add    $0x0,%al
     b35:	00 74 04 00          	add    %dh,0x0(%esp,%eax,1)	b36: R_386_32	.text
     b39:	00 af 05 00 00 82    	add    %ch,-0x7dfffffb(%edi)	b3a: R_386_32	.debug_loc
		return 0;

	entry = section;
	while (entry->name != NULL) {

		if (entry->type == CONF_TYPE(CONF_SECTION)) {
     b3f:	0b 00                	or     (%eax),%eax
     b41:	00 19                	add    %bl,(%ecx)
     b43:	76 61                	jbe    ba6 <.debug_info+0xba6>
     b45:	72 00                	jb     b47 <.debug_info+0xb47>
     b47:	01 73 02             	add    %esi,0x2(%ebx)
			queue[tail++] = (struct conf_var *) entry;
     b4a:	00 04 00             	add    %al,(%eax,%eax,1)
     b4d:	00 02                	add    %al,(%edx)
     b4f:	91                   	xchg   %eax,%ecx
     b50:	00 19                	add    %bl,(%ecx)
		} else {
			if (entry->type->t_get(entry, buf)) {
     b52:	73 00                	jae    b54 <.debug_info+0xb54>
     b54:	01 73 02             	add    %esi,0x2(%ebx)
     b57:	99                   	cltd   
     b58:	00 00                	add    %al,(%eax)
     b5a:	00 02                	add    %al,(%edx)
     b5c:	91                   	xchg   %eax,%ecx
     b5d:	04 1c                	add    $0x1c,%al
     b5f:	58                   	pop    %eax
				fprintf(f, "%s = %s\n", entry->name, buf);
     b60:	04 00                	add    $0x0,%al
     b62:	00 45 04             	add    %al,0x4(%ebp)	b63: R_386_32	.text
     b65:	00 00                	add    %al,(%eax)
     b67:	6b 04 00 00          	imul   $0x0,(%eax,%eax,1),%eax	b67: R_386_32	.text
     b6b:	01 7a 02             	add    %edi,0x2(%edx)
     b6e:	1d 76 04 00 00       	sbb    $0x476,%eax
     b73:	db 05 00 00 1d 6b    	fildl  0x6b1d0000	b73: R_386_32	.debug_loc
     b79:	04 00                	add    $0x0,%al
     b7b:	00 f3                	add    %dh,%bl	b7c: R_386_32	.debug_loc
     b7d:	05 00 00 00 00       	add    $0x0,%eax
     b82:	1b 01                	sbb    (%ecx),%eax
     b84:	7b 01                	jnp    b87 <.debug_info+0xb87>	b84: R_386_32	.debug_str
     b86:	00 00                	add    %al,(%eax)
     b88:	01 87 02 01 5a 00    	add    %eax,0x5a0102(%edi)
     b8e:	00 00                	add    %al,(%eax)
     b90:	74 04                	je     b96 <.debug_info+0xb96>	b90: R_386_32	.text
     b92:	00 00                	add    %al,(%eax)
     b94:	c1 04 00 00          	roll   $0x0,(%eax,%eax,1)	b94: R_386_32	.text
     b98:	07                   	pop    %es	b98: R_386_32	.debug_loc
     b99:	06                   	push   %es
     b9a:	00 00                	add    %al,(%eax)
     b9c:	e0 0b                	loopne ba9 <.debug_info+0xba9>
     b9e:	00 00                	add    %al,(%eax)
     ba0:	19 76 61             	sbb    %esi,0x61(%esi)
     ba3:	72 00                	jb     ba5 <.debug_info+0xba5>
     ba5:	01 87 02 00 04 00    	add    %eax,0x40002(%edi)
     bab:	00 02                	add    %al,(%edx)
     bad:	91                   	xchg   %eax,%ecx
     bae:	00 19                	add    %bl,(%ecx)
     bb0:	73 00                	jae    bb2 <.debug_info+0xbb2>
			} else {
				/* Assuming the above failure means configuration stub. */
				fprintf(f, "%s = %s\n", entry->name, STUB_STRING);
			}
			count++;
     bb2:	01 87 02 99 00 00    	add    %eax,0x9902(%edi)

	if (section == NULL)
		return 0;

	entry = section;
	while (entry->name != NULL) {
     bb8:	00 02                	add    %al,(%edx)
     bba:	91                   	xchg   %eax,%ecx
     bbb:	04 1c                	add    $0x1c,%al
     bbd:	58                   	pop    %eax
     bbe:	04 00                	add    $0x0,%al
     bc0:	00 92 04 00 00 b8    	add    %dl,-0x47fffffc(%edx)	bc1: R_386_32	.text
	bc5: R_386_32	.text
     bc6:	04 00                	add    $0x0,%al
     bc8:	00 01                	add    %al,(%ecx)
			count++;
		}
		entry++;
	}

	for (head = 0; head < tail; head++) {
     bca:	8e 02                	mov    (%edx),%es
     bcc:	1d 76 04 00 00       	sbb    $0x476,%eax
     bd1:	33 06                	xor    (%esi),%eax	bd1: R_386_32	.debug_loc
     bd3:	00 00                	add    %al,(%eax)
     bd5:	1d 6b 04 00 00       	sbb    $0x46b,%eax
		entry = queue[head];
     bda:	4b                   	dec    %ebx	bda: R_386_32	.debug_loc
     bdb:	06                   	push   %es
     bdc:	00 00                	add    %al,(%eax)
		if (head != 0)
     bde:	00 00                	add    %al,(%eax)
     be0:	1b 01                	sbb    (%ecx),%eax
     be2:	16                   	push   %ss	be2: R_386_32	.debug_str
     be3:	02 00                	add    (%eax),%al
     be5:	00 01                	add    %al,(%ecx)
     be7:	9c                   	pushf  
     be8:	02 01                	add    (%ecx),%al
     bea:	5a                   	pop    %edx
     beb:	00 00                	add    %al,(%eax)
     bed:	00 c1                	add    %al,%cl	bee: R_386_32	.text
     bef:	04 00                	add    $0x0,%al
     bf1:	00 17                	add    %dl,(%edi)	bf2: R_386_32	.text
     bf3:	05 00 00 5f 06       	add    $0x65f0000,%eax	bf6: R_386_32	.debug_loc
			fprintf(f, "\n");
		if ((branch != NULL) && (*branch != '\0'))
     bf8:	00 00                	add    %al,(%eax)
     bfa:	3e                   	ds
     bfb:	0c 00                	or     $0x0,%al
     bfd:	00 19                	add    %bl,(%ecx)

#ifdef __va_arg_pack
__extern_always_inline int
__NTH (sprintf (char *__restrict __s, __const char *__restrict __fmt, ...))
{
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
     bff:	76 61                	jbe    c62 <.debug_info+0xc62>
     c01:	72 00                	jb     c03 <.debug_info+0xc03>
     c03:	01 9c 02 00 04 00 00 	add    %ebx,0x400(%edx,%eax,1)
     c0a:	02 91 00 19 73 00    	add    0x731900(%ecx),%dl
     c10:	01 9c 02 99 00 00 00 	add    %ebx,0x99(%edx,%eax,1)
     c17:	02 91 04 1c 58 04    	add    0x4581c04(%ecx),%dl
     c1d:	00 00                	add    %al,(%eax)
     c1f:	e0 04                	loopne c25 <.debug_info+0xc25>	c1f: R_386_32	.text
			sprintf(buf, "%s/%s", branch, entry->name);
     c21:	00 00                	add    %al,(%eax)
     c23:	0d 05 00 00 01       	or     $0x1000005,%eax	c23: R_386_32	.text
     c28:	a3 02 1d 76 04       	mov    %eax,0x4761d02
#endif

__extern_always_inline char *
__NTH (strcpy (char *__restrict __dest, __const char *__restrict __src))
{
  return __builtin___strcpy_chk (__dest, __src, __bos (__dest));
     c2d:	00 00                	add    %al,(%eax)
     c2f:	a3 06 00 00 1d       	mov    %eax,0x1d000006	c2f: R_386_32	.debug_loc
     c34:	6b 04 00 00          	imul   $0x0,(%eax,%eax,1),%eax
     c38:	bb 06 00 00 00       	mov    $0x6,%ebx	c38: R_386_32	.debug_loc
     c3d:	00 18                	add    %bl,(%eax)
     c3f:	01 6f 00             	add    %ebp,0x0(%edi)	c40: R_386_32	.debug_str
		else
			strcpy(buf, entry->name);
		fprintf(f, "[%s]\n", buf);
     c42:	00 00                	add    %al,(%eax)
     c44:	01 b3 02 01 5a 00    	add    %esi,0x5a0102(%ebx)

# ifdef __va_arg_pack
__extern_always_inline int
fprintf (FILE *__restrict __stream, __const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
     c4a:	00 00                	add    %al,(%eax)
     c4c:	17                   	pop    %ss	c4c: R_386_32	.text
     c4d:	05 00 00 35 05       	add    $0x5350000,%eax	c50: R_386_32	.text
     c52:	00 00                	add    %al,(%eax)
     c54:	02 74 04 78          	add    0x78(%esp,%eax,1),%dh
     c58:	0c 00                	or     $0x0,%al
     c5a:	00 19                	add    %bl,(%ecx)
     c5c:	76 61                	jbe    cbf <.debug_info+0xcbf>
     c5e:	72 00                	jb     c60 <.debug_info+0xc60>
     c60:	01 b3 02 00 04 00    	add    %esi,0x40002(%ebx)
		count += write_section(f, (struct conf_var *) entry->p, buf);
     c66:	00 02                	add    %al,(%edx)
     c68:	91                   	xchg   %eax,%ecx
     c69:	00 19                	add    %bl,(%ecx)
     c6b:	73 00                	jae    c6d <.debug_info+0xc6d>
     c6d:	01 b3 02 99 00 00    	add    %esi,0x9902(%ebx)
			count++;
		}
		entry++;
	}

	for (head = 0; head < tail; head++) {
     c73:	00 02                	add    %al,(%edx)
     c75:	91                   	xchg   %eax,%ecx
     c76:	04 00                	add    $0x0,%al
     c78:	18 01                	sbb    %al,(%ecx)
     c7a:	65                   	gs	c7a: R_386_32	.debug_str
     c7b:	05 00 00 01 c7       	add    $0xc7010000,%eax
		fprintf(f, "[%s]\n", buf);
		count += write_section(f, (struct conf_var *) entry->p, buf);
	}

	return count;
}
     c80:	02 01                	add    (%ecx),%al
     c82:	5a                   	pop    %edx
     c83:	00 00                	add    %al,(%eax)
     c85:	00 35 05 00 00 53    	add    %dh,0x53000005	c86: R_386_32	.text
	c8a: R_386_32	.text
     c8b:	05 00 00 02 74       	add    $0x74020000,%eax
     c90:	04 b2                	add    $0xb2,%al
     c92:	0c 00                	or     $0x0,%al
     c94:	00 19                	add    %bl,(%ecx)
		}
		entry++;
	}

	for (head = 0; head < tail; head++) {
		entry = queue[head];
     c96:	76 61                	jbe    cf9 <.debug_info+0xcf9>
     c98:	72 00                	jb     c9a <.debug_info+0xc9a>
     c9a:	01 c7                	add    %eax,%edi
     c9c:	02 00                	add    (%eax),%al
     c9e:	04 00                	add    $0x0,%al
		if (head != 0)
			fprintf(f, "\n");
		if ((branch != NULL) && (*branch != '\0'))
			sprintf(buf, "%s/%s", branch, entry->name);
     ca0:	00 02                	add    %al,(%edx)
     ca2:	91                   	xchg   %eax,%ecx
     ca3:	00 19                	add    %bl,(%ecx)
     ca5:	73 00                	jae    ca7 <.debug_info+0xca7>
     ca7:	01 c7                	add    %eax,%edi
     ca9:	02 99 00 00 00 02    	add    0x2000000(%ecx),%bl
		fprintf(f, "[%s]\n", buf);
		count += write_section(f, (struct conf_var *) entry->p, buf);
	}

	return count;
}
     caf:	91                   	xchg   %eax,%ecx
     cb0:	04 00                	add    $0x0,%al
     cb2:	18 01                	sbb    %al,(%ecx)
     cb4:	38 02                	cmp    %al,(%edx)	cb4: R_386_32	.debug_str
     cb6:	00 00                	add    %al,(%eax)
     cb8:	01 db                	add    %ebx,%ebx
     cba:	02 01                	add    (%ecx),%al
	/* {CONF_IPPORT, "ip_port", ipport_get, ipport_set} */
	{CONF_IPPORT, "ip_port", string_get, string_set}
};

struct conf_var *var_lookup(struct conf_var *section, const char *name)
{
     cbc:	5a                   	pop    %edx
     cbd:	00 00                	add    %al,(%eax)
     cbf:	00 53 05             	add    %dl,0x5(%ebx)	cc0: R_386_32	.text
     cc2:	00 00                	add    %al,(%eax)
     cc4:	71 05                	jno    ccb <.debug_info+0xccb>	cc4: R_386_32	.text
     cc6:	00 00                	add    %al,(%eax)
	struct conf_var *entry;

	if ((name == NULL) || (*name == '\0')) {
     cc8:	02 74 04 ec          	add    -0x14(%esp,%eax,1),%dh
		//      fprintf(stderr, "name invalid\n");
		return NULL;
     ccc:	0c 00                	or     $0x0,%al
     cce:	00 19                	add    %bl,(%ecx)
     cd0:	76 61                	jbe    d33 <.debug_info+0xd33>

struct conf_var *var_lookup(struct conf_var *section, const char *name)
{
	struct conf_var *entry;

	if ((name == NULL) || (*name == '\0')) {
     cd2:	72 00                	jb     cd4 <.debug_info+0xcd4>
     cd4:	01 db                	add    %ebx,%ebx
		//      fprintf(stderr, "name invalid\n");
		return NULL;
	}

	if ((entry = section) == NULL) {
     cd6:	02 00                	add    (%eax),%al
     cd8:	04 00                	add    $0x0,%al
		//      fprintf(stderr, "section invalid\n");
		return NULL;
	}

	while (entry->name != NULL) {
     cda:	00 02                	add    %al,(%edx)
     cdc:	91                   	xchg   %eax,%ecx
     cdd:	00 19                	add    %bl,(%ecx)
     cdf:	73 00                	jae    ce1 <.debug_info+0xce1>
     ce1:	01 db                	add    %ebx,%ebx
		if (strcmp(entry->name, name) == 0)
     ce3:	02 99 00 00 00 02    	add    0x2000000(%ecx),%bl
     ce9:	91                   	xchg   %eax,%ecx
     cea:	04 00                	add    $0x0,%al
     cec:	18 01                	sbb    %al,(%ecx)
     cee:	78 00                	js     cf0 <.debug_info+0xcf0>	cee: R_386_32	.debug_str
     cf0:	00 00                	add    %al,(%eax)
			return entry;
		entry++;
     cf2:	01 fe                	add    %edi,%esi
     cf4:	02 01                	add    (%ecx),%al
	if ((entry = section) == NULL) {
		//      fprintf(stderr, "section invalid\n");
		return NULL;
	}

	while (entry->name != NULL) {
     cf6:	5a                   	pop    %edx
     cf7:	00 00                	add    %al,(%eax)
     cf9:	00 71 05             	add    %dh,0x5(%ecx)	cfa: R_386_32	.text
			return entry;
		entry++;
	}

//      fprintf(stderr, "name not found\n");
	return NULL;
     cfc:	00 00                	add    %al,(%eax)
     cfe:	8f 05 00 00 02 74    	popl   0x74020000	cfe: R_386_32	.text
{
	struct conf_var *entry;

	if ((name == NULL) || (*name == '\0')) {
		//      fprintf(stderr, "name invalid\n");
		return NULL;
     d04:	04 26                	add    $0x26,%al
     d06:	0d 00 00 19 76       	or     $0x76190000,%eax
	}

	if ((entry = section) == NULL) {
		//      fprintf(stderr, "section invalid\n");
		return NULL;
     d0b:	61                   	popa   
     d0c:	72 00                	jb     d0e <.debug_info+0xd0e>
		entry++;
	}

//      fprintf(stderr, "name not found\n");
	return NULL;
}
     d0e:	01 fe                	add    %edi,%esi
     d10:	02 00                	add    (%eax),%al
     d12:	04 00                	add    $0x0,%al
     d14:	00 02                	add    %al,(%edx)

int var_set(struct conf_var *section, const char *name, const char *value)
{
     d16:	91                   	xchg   %eax,%ecx
     d17:	00 19                	add    %bl,(%ecx)
     d19:	73 00                	jae    d1b <.debug_info+0xd1b>
     d1b:	01 fe                	add    %edi,%esi
     d1d:	02 99 00 00 00 02    	add    0x2000000(%ecx),%bl
	struct conf_var *entry;

	entry = var_lookup(section, name);
     d23:	91                   	xchg   %eax,%ecx
     d24:	04 00                	add    $0x0,%al
     d26:	18 01                	sbb    %al,(%ecx)
     d28:	5b                   	pop    %ebx	d28: R_386_32	.debug_str
     d29:	04 00                	add    $0x0,%al
     d2b:	00 01                	add    %al,(%ecx)
     d2d:	12 03                	adc    (%ebx),%al
     d2f:	01 5a 00             	add    %ebx,0x0(%edx)
	if (entry == NULL)
     d32:	00 00                	add    %al,(%eax)
     d34:	8f 05 00 00 ad 05    	popl   0x5ad0000	d34: R_386_32	.text
	d38: R_386_32	.text
		return -1;

	/* Assuming NULL set as a stub configuration. */
	if (value == NULL)
		value = STUB_STRING;
     d3a:	00 00                	add    %al,(%eax)
     d3c:	02 74 04 60          	add    0x60(%esp,%eax,1),%dh
	
	if (entry->type->t_set(entry, value))
     d40:	0d 00 00 19 76       	or     $0x76190000,%eax
     d45:	61                   	popa   
     d46:	72 00                	jb     d48 <.debug_info+0xd48>
     d48:	01 12                	add    %edx,(%edx)
     d4a:	03 00                	add    (%eax),%eax
     d4c:	04 00                	add    $0x0,%al
		return 0;
     d4e:	00 02                	add    %al,(%edx)
     d50:	91                   	xchg   %eax,%ecx
     d51:	00 19                	add    %bl,(%ecx)
     d53:	73 00                	jae    d55 <.debug_info+0xd55>
{
	struct conf_var *entry;

	entry = var_lookup(section, name);
	if (entry == NULL)
		return -1;
     d55:	01 12                	add    %edx,(%edx)
     d57:	03 99 00 00 00 02    	add    0x2000000(%ecx),%ebx
	
	if (entry->type->t_set(entry, value))
		return 0;

	return -1;
}
     d5d:	91                   	xchg   %eax,%ecx

int var_get(struct conf_var *section, const char *name, char *value)
{
     d5e:	04 00                	add    $0x0,%al
     d60:	18 01                	sbb    %al,(%ecx)
     d62:	fb                   	sti    	d62: R_386_32	.debug_str
     d63:	02 00                	add    (%eax),%al
     d65:	00 01                	add    %al,(%ecx)
	struct conf_var *entry;

	if (value == NULL)
     d67:	36 03 01             	add    %ss:(%ecx),%eax
		return -1;

	entry = var_lookup(section, name);
     d6a:	5a                   	pop    %edx
     d6b:	00 00                	add    %al,(%eax)
     d6d:	00 ad 05 00 00 cb    	add    %ch,-0x34fffffb(%ebp)	d6e: R_386_32	.text
	d72: R_386_32	.text
     d73:	05 00 00 02 74       	add    $0x74020000,%eax
     d78:	04 9a                	add    $0x9a,%al
     d7a:	0d 00 00 19 76       	or     $0x76190000,%eax
	if (entry == NULL)
     d7f:	61                   	popa   
     d80:	72 00                	jb     d82 <.debug_info+0xd82>
		return -1;

	if (entry->type->t_get(entry, value))
     d82:	01 36                	add    %esi,(%esi)
     d84:	03 00                	add    (%eax),%eax
     d86:	04 00                	add    $0x0,%al
     d88:	00 02                	add    %al,(%edx)
     d8a:	91                   	xchg   %eax,%ecx
     d8b:	00 19                	add    %bl,(%ecx)
     d8d:	73 00                	jae    d8f <.debug_info+0xd8f>
		return 0;
     d8f:	01 36                	add    %esi,(%esi)
     d91:	03 99 00 00 00 02    	add    0x2000000(%ecx),%ebx

	entry = var_lookup(section, name);
	if (entry == NULL)
		return -1;

	if (entry->type->t_get(entry, value))
     d97:	91                   	xchg   %eax,%ecx
     d98:	04 00                	add    $0x0,%al
     d9a:	18 01                	sbb    %al,(%ecx)
     d9c:	00 04 00             	add    %al,(%eax,%eax,1)	d9c: R_386_32	.debug_str
     d9f:	00 01                	add    %al,(%ecx)
     da1:	6a 03                	push   $0x3
     da3:	01 5a 00             	add    %ebx,0x0(%edx)
     da6:	00 00                	add    %al,(%eax)
     da8:	cb                   	lret   	da8: R_386_32	.text
		return 0;
	else {
		strcpy(value, STUB_STRING);
		return 0;
     da9:	05 00 00 e9 05       	add    $0x5e90000,%eax	dac: R_386_32	.text
int var_get(struct conf_var *section, const char *name, char *value)
{
	struct conf_var *entry;

	if (value == NULL)
		return -1;
     dae:	00 00                	add    %al,(%eax)
     db0:	02 74 04 d4          	add    -0x2c(%esp,%eax,1),%dh

	entry = var_lookup(section, name);
	if (entry == NULL)
		return -1;
     db4:	0d 00 00 19 76       	or     $0x76190000,%eax
		strcpy(value, STUB_STRING);
		return 0;
	}

	return -1;
}
     db9:	61                   	popa   
     dba:	72 00                	jb     dbc <.debug_info+0xdbc>
     dbc:	01 6a 03             	add    %ebp,0x3(%edx)

int conf_load(const char *path, struct conf_var *root)
{
     dbf:	00 04 00             	add    %al,(%eax,%eax,1)
     dc2:	00 02                	add    %al,(%edx)
     dc4:	91                   	xchg   %eax,%ecx
     dc5:	00 19                	add    %bl,(%ecx)
     dc7:	73 00                	jae    dc9 <.debug_info+0xdc9>
     dc9:	01 6a 03             	add    %ebp,0x3(%edx)
     dcc:	99                   	cltd   
     dcd:	00 00                	add    %al,(%eax)
     dcf:	00 02                	add    %al,(%edx)
     dd1:	91                   	xchg   %eax,%ecx
     dd2:	04 00                	add    $0x0,%al
     dd4:	18 01                	sbb    %al,(%ecx)
     dd6:	20 02                	and    %al,(%edx)	dd6: R_386_32	.debug_str
     dd8:	00 00                	add    %al,(%eax)
     dda:	01 7e 03             	add    %edi,0x3(%esi)
     ddd:	01 5a 00             	add    %ebx,0x0(%edx)
     de0:	00 00                	add    %al,(%eax)
     de2:	e9 05 00 00 07       	jmp    7000dec <ipport_set+0x6fffb29>	de2: R_386_32	.text
	de6: R_386_32	.text
     de7:	06                   	push   %es
     de8:	00 00                	add    %al,(%eax)
     dea:	02 74 04 0e          	add    0xe(%esp,%eax,1),%dh
			"int load_conf(const char *path, struct conf_var *root)\n"
			"path = %p \"%s\",\nroot = %p\n{\n",
			path, path, root);
	#endif

	if (!(f = fopen(path, "r"))) {
     dee:	0e                   	push   %cs
     def:	00 00                	add    %al,(%eax)
     df1:	19 76 61             	sbb    %esi,0x61(%esi)
     df4:	72 00                	jb     df6 <.debug_info+0xdf6>
     df6:	01 7e 03             	add    %edi,0x3(%esi)
     df9:	00 04 00             	add    %al,(%eax,%eax,1)
     dfc:	00 02                	add    %al,(%edx)
     dfe:	91                   	xchg   %eax,%ecx
     dff:	00 19                	add    %bl,(%ecx)
     e01:	73 00                	jae    e03 <.debug_info+0xe03>
     e03:	01 7e 03             	add    %edi,0x3(%esi)
     e06:	99                   	cltd   
     e07:	00 00                	add    %al,(%eax)
     e09:	00 02                	add    %al,(%edx)
     e0b:	91                   	xchg   %eax,%ecx
     e0c:	04 00                	add    $0x0,%al
     e0e:	18 01                	sbb    %al,(%ecx)
     e10:	e5 05                	in     $0x5,%eax	e10: R_386_32	.debug_str
     e12:	00 00                	add    %al,(%eax)
     e14:	01 92 03 01 5a 00    	add    %edx,0x5a0103(%edx)
     e1a:	00 00                	add    %al,(%eax)
     e1c:	07                   	pop    %es	e1c: R_386_32	.text
     e1d:	06                   	push   %es
     e1e:	00 00                	add    %al,(%eax)
     e20:	25 06 00 00 02       	and    $0x2000006,%eax	e20: R_386_32	.text
     e25:	74 04                	je     e2b <.debug_info+0xe2b>
     e27:	48                   	dec    %eax
     e28:	0e                   	push   %cs
     e29:	00 00                	add    %al,(%eax)
     e2b:	19 76 61             	sbb    %esi,0x61(%esi)
     e2e:	72 00                	jb     e30 <.debug_info+0xe30>
     e30:	01 92 03 00 04 00    	add    %edx,0x40003(%edx)
			"\tif (!(f = fopen(path, \"r\"))) {\n\t\treturn -1;\n\t};\n"
			"\tsection = root;\n\twhile (fgets(buf, 1024, f)) {\n");
	#endif
	
	while (fgets(buf, 1024, f)) {
		line++;
     e36:	00 02                	add    %al,(%edx)
		
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tcp = buf;\t(buf: %p)\n", buf);
		#endif

		LTRIM(cp);
     e38:	91                   	xchg   %eax,%ecx
     e39:	00 19                	add    %bl,(%ecx)
     e3b:	73 00                	jae    e3d <.debug_info+0xe3d>
     e3d:	01 92 03 99 00 00    	add    %edx,0x9903(%edx)
		line++;
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tline++\t(interaction#: %i)\n", line);
		#endif

		cp = buf;
     e43:	00 02                	add    %al,(%edx)
     e45:	91                   	xchg   %eax,%ecx
		
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tcp = buf;\t(buf: %p)\n", buf);
		#endif

		LTRIM(cp);
     e46:	04 00                	add    $0x0,%al
     e48:	18 01                	sbb    %al,(%ecx)
     e4a:	b6 05                	mov    $0x5,%dh	e4a: R_386_32	.debug_str
     e4c:	00 00                	add    %al,(%eax)
     e4e:	01 a6 03 01 5a 00    	add    %esp,0x5a0103(%esi)
     e54:	00 00                	add    %al,(%eax)
     e56:	25 06 00 00 43       	and    $0x43000006,%eax	e56: R_386_32	.text
	e5a: R_386_32	.text
     e5b:	06                   	push   %es
     e5c:	00 00                	add    %al,(%eax)
     e5e:	02 74 04 82          	add    -0x7e(%esp,%eax,1),%dh
		RTRIM(cp);
     e62:	0e                   	push   %cs
     e63:	00 00                	add    %al,(%eax)
     e65:	19 76 61             	sbb    %esi,0x61(%esi)
     e68:	72 00                	jb     e6a <.debug_info+0xe6a>
     e6a:	01 a6 03 00 04 00    	add    %esp,0x40003(%esi)
     e70:	00 02                	add    %al,(%edx)
     e72:	91                   	xchg   %eax,%ecx
     e73:	00 19                	add    %bl,(%ecx)
     e75:	73 00                	jae    e77 <.debug_info+0xe77>
     e77:	01 a6 03 99 00 00    	add    %esp,0x9903(%esi)
     e7d:	00 02                	add    %al,(%edx)
     e7f:	91                   	xchg   %eax,%ecx
     e80:	04 00                	add    $0x0,%al
     e82:	1b 01                	sbb    (%ecx),%eax
     e84:	b7 00                	mov    $0x0,%bh	e84: R_386_32	.debug_str
     e86:	00 00                	add    %al,(%eax)
     e88:	01 a8 02 01 5a 00    	add    %ebp,0x5a0102(%eax)
     e8e:	00 00                	add    %al,(%eax)
     e90:	43                   	inc    %ebx	e90: R_386_32	.text
     e91:	06                   	push   %es
     e92:	00 00                	add    %al,(%eax)
     e94:	85 06                	test   %eax,(%esi)	e94: R_386_32	.text
     e96:	00 00                	add    %al,(%eax)
     e98:	cf                   	iret   	e98: R_386_32	.debug_loc
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tLTRIM(cp);\n\t\tRTRIM(cp);\t(cp: %p,", cp);
		fprintf(stderr," *cp: %c)\n", *cp);
		#endif

		if ((*cp == '\0') || (*cp == '#') || (*cp == ';') || (*cp == '\n'))
     e99:	06                   	push   %es
     e9a:	00 00                	add    %al,(%eax)
     e9c:	bd 0e 00 00 19       	mov    $0x1900000e,%ebp
     ea1:	76 61                	jbe    f04 <.debug_info+0xf04>
     ea3:	72 00                	jb     ea5 <.debug_info+0xea5>
     ea5:	01 a8 02 00 04 00    	add    %ebp,0x40002(%eax)
     eab:	00 02                	add    %al,(%edx)
     ead:	91                   	xchg   %eax,%ecx
     eae:	00 19                	add    %bl,(%ecx)
     eb0:	73 00                	jae    eb2 <.debug_info+0xeb2>
     eb2:	01 a8 02 e2 02 00    	add    %ebp,0x2e202(%eax)
     eb8:	00 02                	add    %al,(%edx)
     eba:	91                   	xchg   %eax,%ecx
     ebb:	04 00                	add    $0x0,%al
			continue;

		if (*cp == '[') {
     ebd:	1b 01                	sbb    (%ecx),%eax
     ebf:	59                   	pop    %ecx	ebf: R_386_32	.debug_str
     ec0:	00 00                	add    %al,(%eax)
     ec2:	00 01                	add    %al,(%ecx)
     ec4:	92                   	xchg   %eax,%edx
     ec5:	02 01                	add    (%ecx),%al

			cp++;
			LTRIM(cp);
     ec7:	5a                   	pop    %edx
     ec8:	00 00                	add    %al,(%eax)
     eca:	00 85 06 00 00 c7    	add    %al,-0x38fffffa(%ebp)	ecb: R_386_32	.text
	ecf: R_386_32	.text
     ed0:	06                   	push   %es
     ed1:	00 00                	add    %al,(%eax)
     ed3:	13 07                	adc    (%edi),%eax	ed3: R_386_32	.debug_loc
     ed5:	00 00                	add    %al,(%eax)
     ed7:	f8                   	clc    
     ed8:	0e                   	push   %cs
     ed9:	00 00                	add    %al,(%eax)
     edb:	19 76 61             	sbb    %esi,0x61(%esi)
     ede:	72 00                	jb     ee0 <.debug_info+0xee0>
     ee0:	01 92 02 00 04 00    	add    %edx,0x40002(%edx)
     ee6:	00 02                	add    %al,(%edx)
     ee8:	91                   	xchg   %eax,%ecx
     ee9:	00 19                	add    %bl,(%ecx)
     eeb:	73 00                	jae    eed <.debug_info+0xeed>
     eed:	01 92 02 e2 02 00    	add    %edx,0x2e202(%edx)

			if ((ep = strchr(cp, ']')) != NULL)
     ef3:	00 02                	add    %al,(%edx)
     ef5:	91                   	xchg   %eax,%ecx
     ef6:	04 00                	add    $0x0,%al
     ef8:	1b 01                	sbb    (%ecx),%eax
     efa:	de 02                	fiadd  (%edx)	efa: R_386_32	.debug_str
     efc:	00 00                	add    %al,(%eax)
     efe:	01 7e 02             	add    %edi,0x2(%esi)
     f01:	01 5a 00             	add    %ebx,0x0(%edx)
				*ep = '\0';
     f04:	00 00                	add    %al,(%eax)
     f06:	c7 06 00 00 09 07    	movl   $0x7090000,(%esi)	f06: R_386_32	.text
	f0a: R_386_32	.text
			else {
				fprintf(stderr, "%s:%d: parse error.\n", path, line);
				ignore = 1;
				continue;
			}
			RTRIM(cp);
     f0c:	00 00                	add    %al,(%eax)
     f0e:	57                   	push   %edi	f0e: R_386_32	.debug_loc
     f0f:	07                   	pop    %es
     f10:	00 00                	add    %al,(%eax)
     f12:	33 0f                	xor    (%edi),%ecx
     f14:	00 00                	add    %al,(%eax)
     f16:	19 76 61             	sbb    %esi,0x61(%esi)
     f19:	72 00                	jb     f1b <.debug_info+0xf1b>
     f1b:	01 7e 02             	add    %edi,0x2(%esi)
     f1e:	00 04 00             	add    %al,(%eax,%eax,1)
     f21:	00 02                	add    %al,(%edx)
     f23:	91                   	xchg   %eax,%ecx
     f24:	00 19                	add    %bl,(%ecx)
     f26:	73 00                	jae    f28 <.debug_info+0xf28>
     f28:	01 7e 02             	add    %edi,0x2(%esi)
     f2b:	e2 02                	loop   f2f <.debug_info+0xf2f>
     f2d:	00 00                	add    %al,(%eax)
     f2f:	02 91 04 00 1b 01    	add    0x11b0004(%ecx),%dl
     f35:	c9                   	leave  	f35: R_386_32	.debug_str
     f36:	04 00                	add    $0x0,%al
     f38:	00 01                	add    %al,(%ecx)
     f3a:	6a 02                	push   $0x2
     f3c:	01 5a 00             	add    %ebx,0x0(%edx)
     f3f:	00 00                	add    %al,(%eax)
     f41:	09 07                	or     %eax,(%edi)	f41: R_386_32	.text
     f43:	00 00                	add    %al,(%eax)
     f45:	4b                   	dec    %ebx	f45: R_386_32	.text
     f46:	07                   	pop    %es
     f47:	00 00                	add    %al,(%eax)
     f49:	9b                   	fwait	f49: R_386_32	.debug_loc
     f4a:	07                   	pop    %es
     f4b:	00 00                	add    %al,(%eax)
     f4d:	6e                   	outsb  %ds:(%esi),(%dx)
     f4e:	0f 00 00             	sldt   (%eax)
     f51:	19 76 61             	sbb    %esi,0x61(%esi)
     f54:	72 00                	jb     f56 <.debug_info+0xf56>
     f56:	01 6a 02             	add    %ebp,0x2(%edx)
     f59:	00 04 00             	add    %al,(%eax,%eax,1)
     f5c:	00 02                	add    %al,(%edx)

			if ((ep = strchr(cp, ']')) != NULL)
				*ep = '\0';
			else {
				fprintf(stderr, "%s:%d: parse error.\n", path, line);
				ignore = 1;
     f5e:	91                   	xchg   %eax,%ecx
     f5f:	00 19                	add    %bl,(%ecx)
     f61:	73 00                	jae    f63 <.debug_info+0xf63>
     f63:	01 6a 02             	add    %ebp,0x2(%edx)
				continue;
     f66:	e2 02                	loop   f6a <.debug_info+0xf6a>
     f68:	00 00                	add    %al,(%eax)
     f6a:	02 91 04 00 1b 01    	add    0x11b0004(%ecx),%dl
			}
			RTRIM(cp);
     f70:	fa                   	cli    	f70: R_386_32	.debug_str
     f71:	04 00                	add    $0x0,%al
     f73:	00 01                	add    %al,(%ecx)
     f75:	d8 01                	fadds  (%ecx)
     f77:	01 5a 00             	add    %ebx,0x0(%edx)
     f7a:	00 00                	add    %al,(%eax)
     f7c:	4b                   	dec    %ebx	f7c: R_386_32	.text
     f7d:	07                   	pop    %es
     f7e:	00 00                	add    %al,(%eax)

			/* search for a valid section entry, in the root section */
			entry = var_lookup(root, cp);
     f80:	8d 07                	lea    (%edi),%eax	f80: R_386_32	.text
     f82:	00 00                	add    %al,(%eax)
     f84:	df 07                	fild   (%edi)	f84: R_386_32	.debug_loc
     f86:	00 00                	add    %al,(%eax)
     f88:	a9 0f 00 00 19       	test   $0x1900000f,%eax
     f8d:	76 61                	jbe    ff0 <.debug_info+0xff0>
     f8f:	72 00                	jb     f91 <.debug_info+0xf91>
     f91:	01 d8                	add    %ebx,%eax
			if (entry == NULL) {
     f93:	01 00                	add    %eax,(%eax)
     f95:	04 00                	add    $0x0,%al
     f97:	00 02                	add    %al,(%edx)
     f99:	91                   	xchg   %eax,%ecx
     f9a:	00 19                	add    %bl,(%ecx)
     f9c:	73 00                	jae    f9e <.debug_info+0xf9e>
     f9e:	01 d8                	add    %ebx,%eax
     fa0:	01 e2                	add    %esp,%edx
     fa2:	02 00                	add    (%eax),%al
     fa4:	00 02                	add    %al,(%edx)
     fa6:	91                   	xchg   %eax,%ecx
     fa7:	04 00                	add    $0x0,%al
     fa9:	1b 01                	sbb    (%ecx),%eax
     fab:	81 00 00 00 01 93    	addl   $0x93010000,(%eax)	fab: R_386_32	.debug_str
     fb1:	01 01                	add    %eax,(%ecx)
     fb3:	5a                   	pop    %edx
     fb4:	00 00                	add    %al,(%eax)
     fb6:	00 8d 07 00 00 b8    	add    %cl,-0x47fffff9(%ebp)	fb7: R_386_32	.text
	fbb: R_386_32	.text
     fbc:	07                   	pop    %es
     fbd:	00 00                	add    %al,(%eax)
     fbf:	23 08                	and    (%eax),%ecx	fbf: R_386_32	.debug_loc
     fc1:	00 00                	add    %al,(%eax)
     fc3:	e4 0f                	in     $0xf,%al
     fc5:	00 00                	add    %al,(%eax)
				/* section not found */
				fprintf(stderr, "%s:%d: section unknown '%s'\n",
						path, line, cp);
				ignore = 1;
     fc7:	19 76 61             	sbb    %esi,0x61(%esi)
     fca:	72 00                	jb     fcc <.debug_info+0xfcc>
     fcc:	01 93 01 00 04 00    	add    %edx,0x40001(%ebx)
				continue;
     fd2:	00 02                	add    %al,(%edx)
			}
			if (entry->type != CONF_TYPE(CONF_SECTION)) {
     fd4:	91                   	xchg   %eax,%ecx
     fd5:	00 19                	add    %bl,(%ecx)
     fd7:	73 00                	jae    fd9 <.debug_info+0xfd9>
     fd9:	01 93 01 e2 02 00    	add    %edx,0x2e201(%ebx)
     fdf:	00 02                	add    %al,(%edx)
     fe1:	91                   	xchg   %eax,%ecx
     fe2:	04 00                	add    $0x0,%al
     fe4:	1b 01                	sbb    (%ecx),%eax
     fe6:	21 03                	and    %eax,(%ebx)	fe6: R_386_32	.debug_str
     fe8:	00 00                	add    %al,(%eax)
     fea:	01 4e 02             	add    %ecx,0x2(%esi)
     fed:	01 5a 00             	add    %ebx,0x0(%edx)
     ff0:	00 00                	add    %al,(%eax)
     ff2:	b8 07 00 00 19       	mov    $0x19000007,%eax	ff2: R_386_32	.text
	ff6: R_386_32	.text
     ff7:	08 00                	or     %al,(%eax)
     ff9:	00 4f 08             	add    %cl,0x8(%edi)	ffa: R_386_32	.debug_loc
     ffc:	00 00                	add    %al,(%eax)
     ffe:	48                   	dec    %eax
     fff:	10 00                	adc    %al,(%eax)
    1001:	00 19                	add    %bl,(%ecx)
    1003:	76 61                	jbe    1066 <.debug_info+0x1066>
    1005:	72 00                	jb     1007 <.debug_info+0x1007>
    1007:	01 4e 02             	add    %ecx,0x2(%esi)
    100a:	00 04 00             	add    %al,(%eax,%eax,1)
    100d:	00 02                	add    %al,(%edx)
				fprintf(stderr, "%s:%d: not a section '%s'\n", path, line,
						cp);
				ignore = 1;
			}

			section = (struct conf_var *) entry->p;
    100f:	91                   	xchg   %eax,%ecx
    1010:	00 19                	add    %bl,(%ecx)
    1012:	73 00                	jae    1014 <.debug_info+0x1014>
    1014:	01 4e 02             	add    %ecx,0x2(%esi)
			ignore = 0;
    1017:	e2 02                	loop   101b <.debug_info+0x101b>
    1019:	00 00                	add    %al,(%eax)
    101b:	02 91 04 1e 63 70    	add    0x70631e04(%ecx),%dl
			continue;
    1021:	00 01                	add    %al,(%ecx)
		}

		if (ignore)
    1023:	50                   	push   %eax
    1024:	02 99 00 00 00 ab    	add    -0x55000000(%ecx),%bl	1029: R_386_32	.debug_loc
    102a:	08 00                	or     %al,(%eax)
    102c:	00 1f                	add    %bl,(%edi)

		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tfor (ap = cp; (*cp != '\\0') && (*cp != '='); cp++);"
				"\t(*cp: %c, conf.c, 255)", *cp);
		#endif
		for (ap = cp; (*cp != '\0') && (*cp != '='); cp++);
    102e:	d6                   	(bad)  	102e: R_386_32	.text
    102f:	07                   	pop    %es
    1030:	00 00                	add    %al,(%eax)
    1032:	f7 07 00 00 1e 5f    	testl  $0x5f1e0000,(%edi)	1032: R_386_32	.text
    1038:	63 70 00             	arpl   %si,0x0(%eax)
    103b:	01 57 02             	add    %edx,0x2(%edi)
    103e:	99                   	cltd   
    103f:	00 00                	add    %al,(%eax)
    1041:	00 ca                	add    %cl,%dl	1042: R_386_32	.debug_loc
    1043:	08 00                	or     %al,(%eax)
    1045:	00 00                	add    %al,(%eax)
    1047:	00 1b                	add    %bl,(%ebx)
    1049:	01 aa 03 00 00 01    	add    %ebp,0x1000003(%edx)	104a: R_386_32	.debug_str

		#ifdef _CONF_DEBUG
		fprintf(stderr,"\n\t\tif (*cp == '\\0') {...}\t(cp: %p, *cp: %c)",cp,*cp);
		#endif
		if (*cp == '\0') {
    104f:	23 02                	and    (%edx),%eax
    1051:	01 5a 00             	add    %ebx,0x0(%edx)
    1054:	00 00                	add    %al,(%eax)
    1056:	19 08                	sbb    %ecx,(%eax)	1056: R_386_32	.text
    1058:	00 00                	add    %al,(%eax)
    105a:	66 09 00             	or     %ax,(%eax)	105a: R_386_32	.text
    105d:	00 e9                	add    %ch,%cl	105e: R_386_32	.debug_loc
    105f:	08 00                	or     %al,(%eax)
    1061:	00 ac 10 00 00 19 76 	add    %ch,0x76190000(%eax,%edx,1)
    1068:	61                   	popa   
    1069:	72 00                	jb     106b <.debug_info+0x106b>
    106b:	01 23                	add    %esp,(%ebx)
    106d:	02 00                	add    (%eax),%al
    106f:	04 00                	add    $0x0,%al
    1071:	00 02                	add    %al,(%edx)
    1073:	91                   	xchg   %eax,%ecx
    1074:	00 19                	add    %bl,(%ecx)
    1076:	73 00                	jae    1078 <.debug_info+0x1078>
    1078:	01 23                	add    %esp,(%ebx)
    107a:	02 e2                	add    %dl,%ah
    107c:	02 00                	add    (%eax),%al
    107e:	00 02                	add    %al,(%edx)
			fprintf(stderr, "%s:%d: parse error.\n", path, line);
			continue;
    1080:	91                   	xchg   %eax,%ecx
    1081:	04 1e                	add    $0x1e,%al
    1083:	63 70 00             	arpl   %si,0x0(%eax)

		cp--;
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\n\t\tcp--\t(cp: %p)\n\t*cp = '\\0';", cp);
		#endif
		*cp = '\0';
    1086:	01 25 02 99 00 00    	add    %esp,0x9902
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\n\t\tcp++;\n\tcp++;\t(cp: %p)\n", cp);
		#endif


		LTRIM(ap);
    108c:	00 45 09             	add    %al,0x9(%ebp)	108d: R_386_32	.debug_loc
    108f:	00 00                	add    %al,(%eax)
    1091:	1f                   	pop    %ds
    1092:	37                   	aaa    	1092: R_386_32	.text
    1093:	08 00                	or     %al,(%eax)
    1095:	00 58 08             	add    %bl,0x8(%eax)	1096: R_386_32	.text
    1098:	00 00                	add    %al,(%eax)
    109a:	1e                   	push   %ds
    109b:	5f                   	pop    %edi
    109c:	63 70 00             	arpl   %si,0x0(%eax)
    109f:	01 2c 02             	add    %ebp,(%edx,%eax,1)
    10a2:	99                   	cltd   
    10a3:	00 00                	add    %al,(%eax)
    10a5:	00 64 09 00          	add    %ah,0x0(%ecx,%ecx,1)	10a6: R_386_32	.debug_loc
    10a9:	00 00                	add    %al,(%eax)
    10ab:	00 1b                	add    %bl,(%ebx)
    10ad:	01 4d 03             	add    %ecx,0x3(%ebp)	10ae: R_386_32	.debug_str
    10b0:	00 00                	add    %al,(%eax)
    10b2:	01 f0                	add    %esi,%eax
    10b4:	01 01                	add    %eax,(%ecx)
    10b6:	5a                   	pop    %edx
    10b7:	00 00                	add    %al,(%eax)
    10b9:	00 66 09             	add    %ah,0x9(%esi)	10ba: R_386_32	.text
    10bc:	00 00                	add    %al,(%eax)
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tLTRIM(ap);\t(ap: %p, *ap: %c)\n", ap, *ap);
		#endif
		strcpy(name, ap);
    10be:	5a                   	pop    %edx	10be: R_386_32	.text
    10bf:	0a 00                	or     (%eax),%al
    10c1:	00 83 09 00 00 3b    	add    %al,0x3b000009(%ebx)	10c2: R_386_32	.debug_loc
    10c7:	11 00                	adc    %eax,(%eax)
    10c9:	00 19                	add    %bl,(%ecx)
    10cb:	76 61                	jbe    112e <.debug_info+0x112e>
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tstrcpy(name, ap);\t(ap[]: %s\n", ap);
		#endif

		RTRIM(cp);
    10cd:	72 00                	jb     10cf <.debug_info+0x10cf>
    10cf:	01 f0                	add    %esi,%eax
    10d1:	01 00                	add    %eax,(%eax)
    10d3:	04 00                	add    $0x0,%al
    10d5:	00 02                	add    %al,(%edx)
    10d7:	91                   	xchg   %eax,%ecx
    10d8:	00 19                	add    %bl,(%ecx)
    10da:	73 00                	jae    10dc <.debug_info+0x10dc>
    10dc:	01 f0                	add    %esi,%eax
    10de:	01 e2                	add    %esp,%edx
    10e0:	02 00                	add    (%eax),%al
    10e2:	00 02                	add    %al,(%edx)
    10e4:	91                   	xchg   %eax,%ecx
    10e5:	04 1e                	add    $0x1e,%al
    10e7:	63 70 00             	arpl   %si,0x0(%eax)
    10ea:	01 f2                	add    %esi,%edx
    10ec:	01 99 00 00 00 f7    	add    %ebx,-0x9000000(%ecx)	10f1: R_386_32	.debug_loc
    10f2:	09 00                	or     %eax,(%eax)
    10f4:	00 1e                	add    %bl,(%esi)
    10f6:	6c                   	insb   (%dx),%es:(%edi)
    10f7:	65 6e                	outsb  %gs:(%esi),(%dx)
    10f9:	00 01                	add    %al,(%ecx)
    10fb:	f3 01 5a 00          	repz add %ebx,0x0(%edx)
    10ff:	00 00                	add    %al,(%eax)
    1101:	3a 0a                	cmp    (%edx),%cl	1101: R_386_32	.debug_loc
    1103:	00 00                	add    %al,(%eax)
    1105:	20 08                	and    %cl,(%eax)	1106: R_386_32	.debug_str
    1107:	04 00                	add    $0x0,%al
    1109:	00 01                	add    %al,(%ecx)
    110b:	f4                   	hlt    
    110c:	01 9f 00 00 00 66    	add    %ebx,0x66000000(%edi)	1111: R_386_32	.debug_loc
    1112:	0a 00                	or     (%eax),%al
    1114:	00 1e                	add    %bl,(%esi)
		strcpy(value, cp);
    1116:	65                   	gs
    1117:	70 00                	jo     1119 <.debug_info+0x1119>
    1119:	01 f5                	add    %esi,%ebp
    111b:	01 99 00 00 00 7a    	add    %ebx,0x7a000000(%ecx)	1120: R_386_32	.debug_loc
    1121:	0a 00                	or     (%eax),%al
    1123:	00 21                	add    %ah,(%ecx)
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tRTRIM(cp);\n\t\tstrcpy(value, cp);\t(cp[]: %s)\n",cp);
		#endif

		entry = var_lookup(section, name);
    1125:	00 00                	add    %al,(%eax)	1125: R_386_32	.debug_ranges
    1127:	00 00                	add    %al,(%eax)
    1129:	1e                   	push   %ds
    112a:	5f                   	pop    %edi
    112b:	63 70 00             	arpl   %si,0x0(%eax)
    112e:	01 fb                	add    %edi,%ebx
    1130:	01 99 00 00 00 8d    	add    %ebx,-0x73000000(%ecx)	1135: R_386_32	.debug_loc
    1136:	0a 00                	or     (%eax),%al
    1138:	00 00                	add    %al,(%eax)
    113a:	00 1b                	add    %bl,(%ebx)
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tentry = var_lookup(section, name);\n");
		#endif

		if (entry == NULL) {
    113c:	01 48 04             	add    %ecx,0x4(%eax)	113d: R_386_32	.debug_str
    113f:	00 00                	add    %al,(%eax)
			fprintf(stderr, "%s:%d: symbol unknown '%s'\n", path, line, name);
    1141:	01 be 01 01 5a 00    	add    %edi,0x5a0101(%esi)
    1147:	00 00                	add    %al,(%eax)
    1149:	5a                   	pop    %edx	1149: R_386_32	.text
    114a:	0a 00                	or     (%eax),%al
    114c:	00 a2 0a 00 00 b8    	add    %ah,-0x47fffff6(%edx)	114d: R_386_32	.text
	1151: R_386_32	.debug_loc
    1152:	0a 00                	or     (%eax),%al
    1154:	00 84 11 00 00 19 76 	add    %al,0x76190000(%ecx,%edx,1)
    115b:	61                   	popa   
    115c:	72 00                	jb     115e <.debug_info+0x115e>
    115e:	01 be 01 00 04 00    	add    %edi,0x40001(%esi)
    1164:	00 02                	add    %al,(%edx)
    1166:	91                   	xchg   %eax,%ecx
    1167:	00 19                	add    %bl,(%ecx)
    1169:	73 00                	jae    116b <.debug_info+0x116b>
    116b:	01 be 01 e2 02 00    	add    %edi,0x2e201(%esi)
    1171:	00 02                	add    %al,(%edx)
    1173:	91                   	xchg   %eax,%ecx
    1174:	04 1e                	add    $0x1e,%al
    1176:	70 00                	jo     1178 <.debug_info+0x1178>
			continue;
    1178:	01 c0                	add    %eax,%eax
		fprintf(stderr,"(entry: %p, entry->type: %p, entry->type->t_set: %p,"
				" value[]: %s)\n", entry, entry->type, entry->type->t_set, value);
		#endif

		/* set the variable */
		if (entry->type->t_set(entry, value))
    117a:	01 84 11 00 00 fc 0a 	add    %eax,0xafc0000(%ecx,%edx,1)	117f: R_386_32	.debug_loc
    1181:	00 00                	add    %al,(%eax)
    1183:	00 06                	add    %al,(%esi)
    1185:	04 30                	add    $0x30,%al
    1187:	00 00                	add    %al,(%eax)
    1189:	00 1b                	add    %bl,(%ebx)
    118b:	01 b3 01 00 00 01    	add    %esi,0x1000001(%ebx)	118c: R_386_32	.debug_str
    1191:	a4                   	movsb  %ds:(%esi),%es:(%edi)
			count++;
    1192:	01 01                	add    %eax,(%ecx)
    1194:	5a                   	pop    %edx
    1195:	00 00                	add    %al,(%eax)
    1197:	00 a2 0a 00 00 ea    	add    %ah,-0x15fffff6(%edx)	1198: R_386_32	.text
	119c: R_386_32	.text
    119d:	0a 00                	or     (%eax),%al
    119f:	00 1e                	add    %bl,(%esi)	11a0: R_386_32	.debug_loc
    11a1:	0b 00                	or     (%eax),%eax
    11a3:	00 d3                	add    %dl,%bl
    11a5:	11 00                	adc    %eax,(%eax)
    11a7:	00 19                	add    %bl,(%ecx)
    11a9:	76 61                	jbe    120c <.debug_info+0x120c>
    11ab:	72 00                	jb     11ad <.debug_info+0x11ad>
    11ad:	01 a4 01 00 04 00 00 	add    %esp,0x400(%ecx,%eax,1)
    11b4:	02 91 00 19 73 00    	add    0x731900(%ecx),%dl
    11ba:	01 a4 01 e2 02 00 00 	add    %esp,0x2e2(%ecx,%eax,1)
    11c1:	02 91 04 1e 70 00    	add    0x701e04(%ecx),%dl
	return __fgets_chk (__s, __bos (__s), __n, __stream);

      if ((size_t) __n > __bos (__s))
	return __fgets_chk_warn (__s, __bos (__s), __n, __stream);
    }
  return __fgets_alias (__s, __n, __stream);
    11c7:	01 a6 01 ed 02 00    	add    %esp,0x2ed01(%esi)
    11cd:	00 62 0b             	add    %ah,0xb(%edx)	11ce: R_386_32	.debug_loc
    11d0:	00 00                	add    %al,(%eax)
    11d2:	00 22                	add    %ah,(%edx)
    11d4:	94                   	xchg   %eax,%esp	11d4: R_386_32	.debug_str
    11d5:	03 00                	add    (%eax),%eax
	fprintf(stderr,
			"\tif (!(f = fopen(path, \"r\"))) {\n\t\treturn -1;\n\t};\n"
			"\tsection = root;\n\twhile (fgets(buf, 1024, f)) {\n");
	#endif
	
	while (fgets(buf, 1024, f)) {
    11d7:	00 01                	add    %al,(%ecx)
    11d9:	45                   	inc    %ebp
    11da:	01 01                	add    %eax,(%ecx)
    11dc:	5a                   	pop    %edx
    11dd:	00 00                	add    %al,(%eax)
    11df:	00 ea                	add    %ch,%dl	11e0: R_386_32	.text
    11e1:	0a 00                	or     (%eax),%al
    11e3:	00 bb 0c 00 00 84    	add    %bh,-0x7bfffff4(%ebx)	11e4: R_386_32	.text
	11e8: R_386_32	.debug_loc
    11e9:	0b 00                	or     (%eax),%eax
			fprintf(stderr, "%s:%d: parse error.\n", path, line);
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tif (entry->type->t_set(entry, value))\n");
		#endif
	}
	fclose(f);
    11eb:	00 3e                	add    %bh,(%esi)
    11ed:	13 00                	adc    (%eax),%eax
    11ef:	00 23                	add    %ah,(%ebx)
    11f1:	66                   	data16
    11f2:	00 01                	add    %al,(%ecx)
    11f4:	45                   	inc    %ebp
    11f5:	01 52 04             	add    %edx,0x4(%edx)
			"path = %p \"%s\",\nroot = %p\n{\n",
			path, path, root);
	#endif

	if (!(f = fopen(path, "r"))) {
		return -1;
    11f8:	00 00                	add    %al,(%eax)
    11fa:	11 0c 00             	adc    %ecx,(%eax,%eax,1)	11fa: R_386_32	.debug_loc
    11fd:	00 24 32             	add    %ah,(%edx,%esi,1)	11ff: R_386_32	.debug_str
		#endif
	}
	fclose(f);

	return count;
}
    1200:	04 00                	add    $0x0,%al
    1202:	00 01                	add    %al,(%ecx)
    1204:	45                   	inc    %ebp
    1205:	01 00                	add    %eax,(%eax)
    1207:	04 00                	add    $0x0,%al
    1209:	00 31                	add    %dh,(%ecx)	120a: R_386_32	.debug_loc
    120b:	0c 00                	or     $0x0,%al
    120d:	00 24 1d 01 00 00 01 	add    %ah,0x1000001(,%ebx,1)	120f: R_386_32	.debug_str
    1214:	45                   	inc    %ebp
    1215:	01 99 00 00 00 44    	add    %ebx,0x44000000(%ecx)	121a: R_386_32	.debug_loc
    121b:	0c 00                	or     $0x0,%al
    121d:	00 20                	add    %ah,(%eax)
    121f:	ee                   	out    %al,(%dx)	121f: R_386_32	.debug_str
    1220:	00 00                	add    %al,(%eax)
    1222:	00 01                	add    %al,(%ecx)

	return count;
}

int conf_save(const char *path, struct conf_var *root)
{
    1224:	47                   	inc    %edi
    1225:	01 5a 00             	add    %ebx,0x0(%edx)
    1228:	00 00                	add    %al,(%eax)
    122a:	71 0c                	jno    1238 <.debug_info+0x1238>	122a: R_386_32	.debug_loc
    122c:	00 00                	add    %al,(%eax)
    122e:	20 c3                	and    %al,%bl	122f: R_386_32	.debug_str
	FILE *f;
	int count;

	if (!(f = fopen(path, "w+"))) {
    1230:	04 00                	add    $0x0,%al
    1232:	00 01                	add    %al,(%ecx)
    1234:	48                   	dec    %eax
    1235:	01 00                	add    %eax,(%eax)
    1237:	04 00                	add    $0x0,%al
    1239:	00 b5 0c 00 00 25    	add    %dh,0x2500000c(%ebp)	123a: R_386_32	.debug_loc
    123f:	62 75 66             	bound  %esi,0x66(%ebp)
    1242:	00 01                	add    %al,(%ecx)
    1244:	49                   	dec    %ecx
    1245:	01 3e                	add    %edi,(%esi)
    1247:	13 00                	adc    (%eax),%eax
		return -1;
	};

	count = write_section(f, root, NULL);
    1249:	00 03                	add    %al,(%ebx)
    124b:	91                   	xchg   %eax,%ecx
    124c:	dc 6f 26             	fsubrl 0x26(%edi)
    124f:	99                   	cltd   	124f: R_386_32	.debug_str
    1250:	04 00                	add    $0x0,%al
    1252:	00 01                	add    %al,(%ecx)
    1254:	4c                   	dec    %esp
    1255:	01 4f 13             	add    %ecx,0x13(%edi)
    1258:	00 00                	add    %al,(%eax)

	fclose(f);
    125a:	03 91 dc 4f 20 6a    	add    0x6a204fdc(%ecx),%edx	125f: R_386_32	.debug_str
    1260:	00 00                	add    %al,(%eax)

	return count;
    1262:	00 01                	add    %al,(%ecx)
{
	FILE *f;
	int count;

	if (!(f = fopen(path, "w+"))) {
		return -1;
    1264:	4d                   	dec    %ebp
    1265:	01 5a 00             	add    %ebx,0x0(%edx)
	count = write_section(f, root, NULL);

	fclose(f);

	return count;
}
    1268:	00 00                	add    %al,(%eax)
    126a:	16                   	push   %ss	126a: R_386_32	.debug_loc
    126b:	0d 00 00 20 35       	or     $0x35200000,%eax	126f: R_386_32	.debug_str
    1270:	05 00 00 01 4e       	add    $0x4e010000,%eax
    1275:	01 5a 00             	add    %ebx,0x0(%edx)

int conf_dump(struct conf_var *root)
{
    1278:	00 00                	add    %al,(%eax)
	return write_section(stdout, root, NULL);
    127a:	4c                   	dec    %esp	127a: R_386_32	.debug_loc
    127b:	0d 00 00 27 27       	or     $0x27270000,%eax
    1280:	04 00                	add    $0x0,%al
    1282:	00 60 0b             	add    %ah,0xb(%eax)	1283: R_386_32	.text
    1285:	00 00                	add    %al,(%eax)
    1287:	88 0b                	mov    %cl,(%ebx)	1287: R_386_32	.text
    1289:	00 00                	add    %al,(%eax)
    128b:	01 5a 01             	add    %ebx,0x1(%edx)
}
    128e:	a5                   	movsl  %ds:(%esi),%es:(%edi)
    128f:	12 00                	adc    (%eax),%al
int ipaddr_get(struct conf_var *var, char *s)
{
	s = "";

	return 0;
}
    1291:	00 1d 45 04 00 00    	add    %bl,0x445

int ipaddr_set(struct conf_var *var, const char *s)
{
    1297:	90                   	nop	1297: R_386_32	.debug_loc
    1298:	0d 00 00 1d 3a       	or     $0x3a1d0000,%eax
    129d:	04 00                	add    $0x0,%al
	if (var->p == NULL) {
    129f:	00 a8 0d 00 00 00    	add    %ch,0xd(%eax)	12a0: R_386_32	.debug_loc
		var->p = malloc(sizeof(unsigned int));
    12a5:	27                   	daa    
    12a6:	27                   	daa    
    12a7:	04 00                	add    $0x0,%al
    12a9:	00 88 0b 00 00 b2    	add    %cl,-0x4dfffff5(%eax)	12aa: R_386_32	.text
	12ae: R_386_32	.text
    12af:	0b 00                	or     (%eax),%eax
    12b1:	00 01                	add    %al,(%ecx)
	}

	return 0;
}
    12b3:	5d                   	pop    %ebp
    12b4:	01 cc                	add    %ecx,%esp
    12b6:	12 00                	adc    (%eax),%al
    12b8:	00 1d 45 04 00 00    	add    %bl,0x445
int ipport_get(struct conf_var *var, char *s)
{
	s = "";

	return 0;
}
    12be:	bd 0d 00 00 1d       	mov    $0x1d00000d,%ebp	12be: R_386_32	.debug_loc

int ipport_set(struct conf_var *var, const char *s)
{
    12c3:	3a 04 00             	cmp    (%eax,%eax,1),%al
    12c6:	00 d5                	add    %dl,%ch	12c7: R_386_32	.debug_loc
    12c8:	0d 00 00 00 28       	or     $0x28000000,%eax
	if (var->p == NULL) {
    12cd:	58                   	pop    %eax
    12ce:	04 00                	add    $0x0,%al
    12d0:	00 ff                	add    %bh,%bh	12d1: R_386_32	.text
		var->p = malloc(sizeof(unsigned int));
    12d2:	0b 00                	or     (%eax),%eax
    12d4:	00 18                	add    %bl,(%eax)	12d5: R_386_32	.debug_ranges
    12d6:	00 00                	add    %al,(%eax)
    12d8:	00 01                	add    %al,(%ecx)
    12da:	69 01 f3 12 00 00    	imul   $0x12f3,(%ecx),%eax
	}

	return 0;
}
    12e0:	1d 76 04 00 00       	sbb    $0x476,%eax
    12e5:	ea 0d 00 00 1d 6b 04 	ljmp   $0x46b,$0x1d00000d	12e5: R_386_32	.debug_loc
    12ec:	00 00                	add    %al,(%eax)
    12ee:	02 0e                	add    (%esi),%cl	12ee: R_386_32	.debug_loc
    12f0:	00 00                	add    %al,(%eax)
    12f2:	00 27                	add    %ah,(%edi)
    12f4:	83 04 00 00          	addl   $0x0,(%eax,%eax,1)
    12f8:	2b 0c 00             	sub    (%eax,%eax,1),%ecx	12f8: R_386_32	.text
    12fb:	00 41 0c             	add    %al,0xc(%ecx)	12fc: R_386_32	.text
    12fe:	00 00                	add    %al,(%eax)
    1300:	01 6b 01             	add    %ebp,0x1(%ebx)
    1303:	1a 13                	sbb    (%ebx),%dl
    1305:	00 00                	add    %al,(%eax)
    1307:	1d a1 04 00 00       	sbb    $0x4a1,%eax
    130c:	15 0e 00 00 1d       	adc    $0x1d00000e,%eax	130c: R_386_32	.debug_loc
    1311:	96                   	xchg   %eax,%esi
    1312:	04 00                	add    $0x0,%al
    1314:	00 29                	add    %ch,(%ecx)	1315: R_386_32	.debug_loc
    1316:	0e                   	push   %cs
    1317:	00 00                	add    %al,(%eax)
    1319:	00 1c 27             	add    %bl,(%edi,%eiz,1)
    131c:	04 00                	add    $0x0,%al
    131e:	00 41 0c             	add    %al,0xc(%ecx)	131f: R_386_32	.text
    1321:	00 00                	add    %al,(%eax)
    1323:	61                   	popa   	1323: R_386_32	.text
    1324:	0c 00                	or     $0x0,%al
    1326:	00 01                	add    %al,(%ecx)
    1328:	6c                   	insb   (%dx),%es:(%edi)
    1329:	01 1d 45 04 00 00    	add    %ebx,0x445
    132f:	3c 0e                	cmp    $0xe,%al	132f: R_386_32	.debug_loc
    1331:	00 00                	add    %al,(%eax)
    1333:	1d 3a 04 00 00       	sbb    $0x43a,%eax
    1338:	64                   	fs	1338: R_386_32	.debug_loc
    1339:	0e                   	push   %cs
    133a:	00 00                	add    %al,(%eax)
    133c:	00 00                	add    %al,(%eax)
    133e:	0c 9f                	or     $0x9f,%al
    1340:	00 00                	add    %al,(%eax)
    1342:	00 4f 13             	add    %cl,0x13(%edi)
    1345:	00 00                	add    %al,(%eax)
    1347:	29 30                	sub    %esi,(%eax)
    1349:	00 00                	add    %al,(%eax)
    134b:	00 ff                	add    %bh,%bh
    134d:	07                   	pop    %es
    134e:	00 0c 00             	add    %cl,(%eax,%eax,1)
    1351:	04 00                	add    $0x0,%al
    1353:	00 60 13             	add    %ah,0x13(%eax)
    1356:	00 00                	add    %al,(%eax)
    1358:	29 30                	sub    %esi,(%eax)
    135a:	00 00                	add    %al,(%eax)
    135c:	00 ff                	add    %bh,%bh
    135e:	03 00                	add    (%eax),%eax
    1360:	2a 01                	sub    (%ecx),%al
    1362:	69 01 00 00 01 5d    	imul   $0x5d010000,(%ecx),%eax	1362: R_386_32	.debug_str
    1368:	01 00                	add    %eax,(%eax)
    136a:	04 00                	add    $0x0,%al
    136c:	00 bb 0c 00 00 16    	add    %bh,0x1600000c(%ebx)	136d: R_386_32	.text
	1371: R_386_32	.text
    1372:	0d 00 00 86 0e       	or     $0xe860000,%eax	1375: R_386_32	.debug_loc
    1377:	00 00                	add    %al,(%eax)
    1379:	c9                   	leave  
    137a:	13 00                	adc    (%eax),%eax
    137c:	00 2b                	add    %ch,(%ebx)
    137e:	32 04 00             	xor    (%eax,%eax,1),%al	137e: R_386_32	.debug_str
    1381:	00 01                	add    %al,(%ecx)
    1383:	5d                   	pop    %ebp
    1384:	00 04 00             	add    %al,(%eax,%eax,1)
    1387:	00 02                	add    %al,(%edx)
    1389:	91                   	xchg   %eax,%ecx
    138a:	00 2b                	add    %ch,(%ebx)
    138c:	43                   	inc    %ebx	138c: R_386_32	.debug_str
    138d:	04 00                	add    $0x0,%al
    138f:	00 01                	add    %al,(%ecx)
    1391:	5d                   	pop    %ebp
    1392:	e2 02                	loop   1396 <.debug_info+0x1396>
    1394:	00 00                	add    %al,(%eax)
    1396:	02 91 04 2c c3 04    	add    0x4c32c04(%ecx),%dl	139a: R_386_32	.debug_str
    139c:	00 00                	add    %al,(%eax)
    139e:	01 5f 00             	add    %ebx,0x0(%edi)
    13a1:	04 00                	add    $0x0,%al
    13a3:	00 e2                	add    %ah,%dl	13a4: R_386_32	.debug_loc
    13a5:	0e                   	push   %cs
    13a6:	00 00                	add    %al,(%eax)
    13a8:	1f                   	pop    %ds
    13a9:	e2 0c                	loop   13b7 <.debug_info+0x13b7>	13a9: R_386_32	.text
    13ab:	00 00                	add    %al,(%eax)
    13ad:	ee                   	out    %al,(%dx)	13ad: R_386_32	.text
    13ae:	0c 00                	or     $0x0,%al
    13b0:	00 2d cf 01 00 00    	add    %ch,0x1cf	13b2: R_386_32	.debug_str
    13b6:	01 6c 25 00          	add    %ebp,0x0(%ebp,%eiz,1)
    13ba:	00 00                	add    %al,(%eax)
    13bc:	2d b3 02 00 00       	sub    $0x2b3,%eax	13bd: R_386_32	.debug_str
    13c1:	01 6c 25 00          	add    %ebp,0x0(%ebp,%eiz,1)
    13c5:	00 00                	add    %al,(%eax)
    13c7:	00 00                	add    %al,(%eax)
    13c9:	2a 01                	sub    (%ecx),%al
    13cb:	e1 01                	loope  13ce <.debug_info+0x13ce>	13cb: R_386_32	.debug_str
    13cd:	00 00                	add    %al,(%eax)
    13cf:	01 75 01             	add    %esi,0x1(%ebp)
    13d2:	5a                   	pop    %edx
    13d3:	00 00                	add    %al,(%eax)
    13d5:	00 16                	add    %dl,(%esi)	13d6: R_386_32	.text
    13d7:	0d 00 00 5e 0d       	or     $0xd5e0000,%eax	13da: R_386_32	.text
    13dc:	00 00                	add    %al,(%eax)
    13de:	0d 0f 00 00 21       	or     $0x2100000f,%eax	13de: R_386_32	.debug_loc
    13e3:	14 00                	adc    $0x0,%al
    13e5:	00 2b                	add    %ch,(%ebx)
    13e7:	32 04 00             	xor    (%eax,%eax,1),%al	13e7: R_386_32	.debug_str
    13ea:	00 01                	add    %al,(%ecx)
    13ec:	75 00                	jne    13ee <.debug_info+0x13ee>
    13ee:	04 00                	add    $0x0,%al
    13f0:	00 02                	add    %al,(%edx)
    13f2:	91                   	xchg   %eax,%ecx
    13f3:	00 2b                	add    %ch,(%ebx)
    13f5:	43                   	inc    %ebx	13f5: R_386_32	.debug_str
    13f6:	04 00                	add    $0x0,%al
    13f8:	00 01                	add    %al,(%ecx)
    13fa:	75 e2                	jne    13de <.debug_info+0x13de>
    13fc:	02 00                	add    (%eax),%al
    13fe:	00 02                	add    %al,(%edx)
    1400:	91                   	xchg   %eax,%ecx
    1401:	04 2e                	add    $0x2e,%al
    1403:	df 05 00 00 01 75    	fild   0x75010000	1403: R_386_32	.debug_str
    1409:	e2 02                	loop   140d <.debug_info+0x140d>
    140b:	00 00                	add    %al,(%eax)
    140d:	51                   	push   %ecx	140d: R_386_32	.debug_loc
    140e:	0f 00 00             	sldt   (%eax)
    1411:	2c c3                	sub    $0xc3,%al	1412: R_386_32	.debug_str
    1413:	04 00                	add    $0x0,%al
    1415:	00 01                	add    %al,(%ecx)
    1417:	77 00                	ja     1419 <.debug_info+0x1419>
    1419:	04 00                	add    $0x0,%al
    141b:	00 7c 0f 00          	add    %bh,0x0(%edi,%ecx,1)	141c: R_386_32	.debug_loc
    141f:	00 00                	add    %al,(%eax)
    1421:	2a 01                	sub    (%ecx),%al
    1423:	a2 03 00 00 01       	mov    %al,0x1000003	1423: R_386_32	.debug_str
    1428:	87 01                	xchg   %eax,(%ecx)
    142a:	5a                   	pop    %edx
    142b:	00 00                	add    %al,(%eax)
    142d:	00 5e 0d             	add    %bl,0xd(%esi)	142e: R_386_32	.text
    1430:	00 00                	add    %al,(%eax)
    1432:	be 0d 00 00 9a       	mov    $0x9a00000d,%esi	1432: R_386_32	.text
	1436: R_386_32	.debug_loc
    1437:	0f 00 00             	sldt   (%eax)
    143a:	78 14                	js     1450 <.debug_info+0x1450>
    143c:	00 00                	add    %al,(%eax)
    143e:	2b 32                	sub    (%edx),%esi	143f: R_386_32	.debug_str
    1440:	04 00                	add    $0x0,%al
    1442:	00 01                	add    %al,(%ecx)
    1444:	87 00                	xchg   %eax,(%eax)
    1446:	04 00                	add    $0x0,%al
    1448:	00 02                	add    %al,(%edx)
    144a:	91                   	xchg   %eax,%ecx
    144b:	00 2b                	add    %ch,(%ebx)
    144d:	43                   	inc    %ebx	144d: R_386_32	.debug_str
    144e:	04 00                	add    $0x0,%al
    1450:	00 01                	add    %al,(%ecx)
    1452:	87 e2                	xchg   %esp,%edx
    1454:	02 00                	add    (%eax),%al
    1456:	00 02                	add    %al,(%edx)
    1458:	91                   	xchg   %eax,%ecx
    1459:	04 2b                	add    $0x2b,%al
    145b:	df 05 00 00 01 87    	fild   0x87010000	145b: R_386_32	.debug_str
    1461:	99                   	cltd   
    1462:	00 00                	add    %al,(%eax)
    1464:	00 02                	add    %al,(%edx)
    1466:	91                   	xchg   %eax,%ecx
    1467:	08 2c c3             	or     %ch,(%ebx,%eax,8)	1469: R_386_32	.debug_str
    146a:	04 00                	add    $0x0,%al
    146c:	00 01                	add    %al,(%ecx)
    146e:	89 00                	mov    %eax,(%eax)
    1470:	04 00                	add    $0x0,%al
    1472:	00 de                	add    %bl,%dh	1473: R_386_32	.debug_loc
    1474:	0f 00 00             	sldt   (%eax)
    1477:	00 2a                	add    %ch,(%edx)
    1479:	01 49 02             	add    %ecx,0x2(%ecx)	147a: R_386_32	.debug_str
    147c:	00 00                	add    %al,(%eax)
    147e:	01 9c 01 5a 00 00 00 	add    %ebx,0x5a(%ecx,%eax,1)
    1485:	be 0d 00 00 24       	mov    $0x2400000d,%esi	1485: R_386_32	.text
	1489: R_386_32	.text
    148a:	12 00                	adc    (%eax),%al
    148c:	00 fc                	add    %bh,%ah	148d: R_386_32	.debug_loc
    148e:	0f 00 00             	sldt   (%eax)
    1491:	55                   	push   %ebp
    1492:	17                   	pop    %ss
    1493:	00 00                	add    %al,(%eax)
    1495:	2b bb 01 00 00 01    	sub    0x1000001(%ebx),%edi	1496: R_386_32	.debug_str
    149b:	9c                   	pushf  
    149c:	e2 02                	loop   14a0 <.debug_info+0x14a0>
    149e:	00 00                	add    %al,(%eax)
    14a0:	02 91 00 2b b3 03    	add    0x3b32b00(%ecx),%dl	14a4: R_386_32	.debug_str
    14a6:	00 00                	add    %al,(%eax)
    14a8:	01 9c 00 04 00 00 02 	add    %ebx,0x2000004(%eax,%eax,1)
    14af:	91                   	xchg   %eax,%ecx
    14b0:	04 2f                	add    $0x2f,%al
    14b2:	66                   	data16
    14b3:	00 01                	add    %al,(%ecx)
    14b5:	9e                   	sahf   
    14b6:	52                   	push   %edx
    14b7:	04 00                	add    $0x0,%al
    14b9:	00 89 10 00 00 30    	add    %cl,0x30000010(%ecx)	14ba: R_386_32	.debug_loc
    14bf:	62 75 66             	bound  %esi,0x66(%ebp)
    14c2:	00 01                	add    %al,(%ecx)
    14c4:	9f                   	lahf   
    14c5:	55                   	push   %ebp
    14c6:	17                   	pop    %ss
    14c7:	00 00                	add    %al,(%eax)
    14c9:	03 91 dc 6f 31 43    	add    0x43316fdc(%ecx),%edx	14ce: R_386_32	.debug_str
    14cf:	04 00                	add    $0x0,%al
    14d1:	00 01                	add    %al,(%ecx)
    14d3:	a0 66 17 00 00       	mov    0x1766,%al
    14d8:	03 91 dc 77 31 df    	add    -0x20ce8824(%ecx),%edx	14dd: R_386_32	.debug_str
    14de:	05 00 00 01 a1       	add    $0xa1010000,%eax
    14e3:	66 17                	popw   %ss
    14e5:	00 00                	add    %al,(%eax)
    14e7:	03 91 dc 7b 2c ee    	add    -0x11d38424(%ecx),%edx	14ec: R_386_32	.debug_str
    14ed:	00 00                	add    %al,(%eax)
    14ef:	00 01                	add    %al,(%ecx)
    14f1:	a2 5a 00 00 00       	mov    %al,0x5a
    14f6:	a9 10 00 00 2f       	test   $0x2f000010,%eax	14f6: R_386_32	.debug_loc
    14fb:	63 70 00             	arpl   %si,0x0(%eax)
    14fe:	01 a3 99 00 00 00    	add    %esp,0x99(%ebx)
    1504:	be 10 00 00 2f       	mov    $0x2f000010,%esi	1504: R_386_32	.debug_loc
    1509:	65                   	gs
    150a:	70 00                	jo     150c <.debug_info+0x150c>
    150c:	01 a4 99 00 00 00 48 	add    %esp,0x48000000(%ecx,%ebx,4)	1512: R_386_32	.debug_loc
    1513:	11 00                	adc    %eax,(%eax)
    1515:	00 2f                	add    %ch,(%edi)
    1517:	61                   	popa   
    1518:	70 00                	jo     151a <.debug_info+0x151a>
    151a:	01 a5 99 00 00 00    	add    %esp,0x99(%ebp)
    1520:	66 11 00             	adc    %ax,(%eax)	1520: R_386_32	.debug_loc
    1523:	00 2c 0a             	add    %ch,(%edx,%ecx,1)	1525: R_386_32	.debug_str
    1526:	05 00 00 01 a6       	add    $0xa6010000,%eax
    152b:	5a                   	pop    %edx
    152c:	00 00                	add    %al,(%eax)
    152e:	00 79 11             	add    %bh,0x11(%ecx)	152f: R_386_32	.debug_loc
    1531:	00 00                	add    %al,(%eax)
    1533:	2c 32                	sub    $0x32,%al	1534: R_386_32	.debug_str
    1535:	04 00                	add    $0x0,%al
    1537:	00 01                	add    %al,(%ecx)
    1539:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
    153a:	00 04 00             	add    %al,(%eax,%eax,1)
    153d:	00 8e 11 00 00 2c    	add    %cl,0x2c000011(%esi)	153e: R_386_32	.debug_loc
    1543:	c3                   	ret    	1543: R_386_32	.debug_str
    1544:	04 00                	add    $0x0,%al
    1546:	00 01                	add    %al,(%ecx)
    1548:	a8 00                	test   $0x0,%al
    154a:	04 00                	add    $0x0,%al
    154c:	00 bb 11 00 00 2c    	add    %bh,0x2c000011(%ebx)	154d: R_386_32	.debug_loc
    1552:	e7 00                	out    %eax,$0x0	1552: R_386_32	.debug_str
    1554:	00 00                	add    %al,(%eax)
    1556:	01 a9 5a 00 00 00    	add    %ebp,0x5a(%ecx)
    155c:	ef                   	out    %eax,(%dx)	155c: R_386_32	.debug_loc
    155d:	11 00                	adc    %eax,(%eax)
    155f:	00 32                	add    %dh,(%edx)
    1561:	37                   	aaa    	1561: R_386_32	.text
    1562:	0e                   	push   %cs
    1563:	00 00                	add    %al,(%eax)
    1565:	62 0e                	bound  %ecx,(%esi)	1565: R_386_32	.text
    1567:	00 00                	add    %al,(%eax)
    1569:	7d 15                	jge    1580 <.debug_info+0x1580>
    156b:	00 00                	add    %al,(%eax)
    156d:	2f                   	das    
    156e:	5f                   	pop    %edi
    156f:	63 70 00             	arpl   %si,0x0(%eax)
    1572:	01 cd                	add    %ecx,%ebp
    1574:	99                   	cltd   
    1575:	00 00                	add    %al,(%eax)
    1577:	00 67 12             	add    %ah,0x12(%edi)	1578: R_386_32	.debug_loc
    157a:	00 00                	add    %al,(%eax)
    157c:	00 32                	add    %dh,(%edx)
    157e:	62 0e                	bound  %ecx,(%esi)	157e: R_386_32	.text
    1580:	00 00                	add    %al,(%eax)
    1582:	99                   	cltd   	1582: R_386_32	.text
    1583:	0e                   	push   %cs
    1584:	00 00                	add    %al,(%eax)
    1586:	9a 15 00 00 2f 5f 63 	lcall  $0x635f,$0x2f000015
    158d:	70 00                	jo     158f <.debug_info+0x158f>
    158f:	01 ce                	add    %ecx,%esi
    1591:	99                   	cltd   
    1592:	00 00                	add    %al,(%eax)
    1594:	00 88 12 00 00 00    	add    %cl,0x12(%eax)	1595: R_386_32	.debug_loc
    159a:	32 c6                	xor    %dh,%al	159b: R_386_32	.text
    159c:	0e                   	push   %cs
    159d:	00 00                	add    %al,(%eax)
    159f:	f0 0e                	lock push %cs	159f: R_386_32	.text
    15a1:	00 00                	add    %al,(%eax)
    15a3:	b7 15                	mov    $0x15,%bh
    15a5:	00 00                	add    %al,(%eax)
    15a7:	2f                   	das    
    15a8:	5f                   	pop    %edi
    15a9:	63 70 00             	arpl   %si,0x0(%eax)
    15ac:	01 da                	add    %ebx,%edx
    15ae:	99                   	cltd   
    15af:	00 00                	add    %al,(%eax)
    15b1:	00 a8 12 00 00 00    	add    %ch,0x12(%eax)	15b2: R_386_32	.debug_loc
    15b7:	33 30                	xor    (%eax),%esi	15b8: R_386_32	.debug_ranges
    15b9:	00 00                	add    %al,(%eax)
    15bb:	00 d0                	add    %dl,%al
    15bd:	15 00 00 2f 5f       	adc    $0x5f2f0000,%eax
    15c2:	63 70 00             	arpl   %si,0x0(%eax)
    15c5:	01 e3                	add    %esp,%ebx
    15c7:	99                   	cltd   
    15c8:	00 00                	add    %al,(%eax)
    15ca:	00 d5                	add    %dl,%ch	15cb: R_386_32	.debug_loc
    15cc:	12 00                	adc    (%eax),%al
    15ce:	00 00                	add    %al,(%eax)
    15d0:	34 27                	xor    $0x27,%al
    15d2:	04 00                	add    $0x0,%al
    15d4:	00 31                	add    %dh,(%ecx)	15d5: R_386_32	.text
    15d6:	0f 00 00             	sldt   (%eax)
    15d9:	5e                   	pop    %esi	15d9: R_386_32	.text
    15da:	0f 00 00             	sldt   (%eax)
    15dd:	01 df                	add    %ebx,%edi
    15df:	f2 15 00 00 1d 45    	repnz adc $0x451d0000,%eax
    15e5:	04 00                	add    $0x0,%al
    15e7:	00 00                	add    %al,(%eax)	15e8: R_386_32	.debug_loc
    15e9:	13 00                	adc    (%eax),%eax
    15eb:	00 35 3a 04 00 00    	add    %dh,0x43a
    15f1:	00 34 27             	add    %dh,(%edi,%eiz,1)
    15f4:	04 00                	add    $0x0,%al
    15f6:	00 96 0f 00 00 c7    	add    %dl,-0x38fffff1(%esi)	15f7: R_386_32	.text
	15fb: R_386_32	.text
    15fc:	0f 00 00             	sldt   (%eax)
    15ff:	01 e9                	add    %ebp,%ecx
    1601:	14 16                	adc    $0x16,%al
    1603:	00 00                	add    %al,(%eax)
    1605:	1d 45 04 00 00       	sbb    $0x445,%eax
    160a:	18 13                	sbb    %dl,(%ebx)	160a: R_386_32	.debug_loc
    160c:	00 00                	add    %al,(%eax)
    160e:	35 3a 04 00 00       	xor    $0x43a,%eax
    1613:	00 34 27             	add    %dh,(%edi,%eiz,1)
    1616:	04 00                	add    $0x0,%al
    1618:	00 dd                	add    %bl,%ch	1619: R_386_32	.text
    161a:	0f 00 00             	sldt   (%eax)
    161d:	0e                   	push   %cs	161d: R_386_32	.text
    161e:	10 00                	adc    %al,(%eax)
    1620:	00 01                	add    %al,(%ecx)
    1622:	ef                   	out    %eax,(%dx)
    1623:	36                   	ss
    1624:	16                   	push   %ss
    1625:	00 00                	add    %al,(%eax)
    1627:	1d 45 04 00 00       	sbb    $0x445,%eax
    162c:	30 13                	xor    %dl,(%ebx)	162c: R_386_32	.debug_loc
    162e:	00 00                	add    %al,(%eax)
    1630:	35 3a 04 00 00       	xor    $0x43a,%eax
    1635:	00 27                	add    %ah,(%edi)
    1637:	27                   	daa    
    1638:	04 00                	add    $0x0,%al
    163a:	00 52 10             	add    %dl,0x10(%edx)	163b: R_386_32	.text
    163d:	00 00                	add    %al,(%eax)
    163f:	7f 10                	jg     1651 <.debug_info+0x1651>	163f: R_386_32	.text
    1641:	00 00                	add    %al,(%eax)
    1643:	01 06                	add    %eax,(%esi)
    1645:	01 59 16             	add    %ebx,0x16(%ecx)
    1648:	00 00                	add    %al,(%eax)
    164a:	1d 45 04 00 00       	sbb    $0x445,%eax
    164f:	48                   	dec    %eax	164f: R_386_32	.debug_loc
    1650:	13 00                	adc    (%eax),%eax
    1652:	00 35 3a 04 00 00    	add    %dh,0x43a
    1658:	00 32                	add    %dh,(%edx)
    165a:	8b 10                	mov    (%eax),%edx	165a: R_386_32	.text
    165c:	00 00                	add    %al,(%eax)
    165e:	b2 10                	mov    $0x10,%dl	165e: R_386_32	.text
    1660:	00 00                	add    %al,(%eax)
    1662:	77 16                	ja     167a <.debug_info+0x167a>
    1664:	00 00                	add    %al,(%eax)
    1666:	1e                   	push   %ds
    1667:	5f                   	pop    %edi
    1668:	63 70 00             	arpl   %si,0x0(%eax)
    166b:	01 16                	add    %edx,(%esi)
    166d:	01 99 00 00 00 60    	add    %ebx,0x60000000(%ecx)	1672: R_386_32	.debug_loc
    1673:	13 00                	adc    (%eax),%eax
    1675:	00 00                	add    %al,(%eax)
    1677:	27                   	daa    
    1678:	83 04 00 00          	addl   $0x0,(%eax,%eax,1)
    167c:	b2 10                	mov    $0x10,%dl	167c: R_386_32	.text
    167e:	00 00                	add    %al,(%eax)
    1680:	cd 10                	int    $0x10	1680: R_386_32	.text
    1682:	00 00                	add    %al,(%eax)
    1684:	01 1a                	add    %ebx,(%edx)
    1686:	01 9e 16 00 00 1d    	add    %ebx,0x1d000016(%esi)
    168c:	a1 04 00 00 66       	mov    0x66000004,%eax	1690: R_386_32	.debug_loc
    1691:	11 00                	adc    %eax,(%eax)
    1693:	00 1d 96 04 00 00    	add    %bl,0x496
    1699:	89 13                	mov    %edx,(%ebx)	1699: R_386_32	.debug_loc
    169b:	00 00                	add    %al,(%eax)
    169d:	00 32                	add    %dh,(%edx)
    169f:	cd 10                	int    $0x10	169f: R_386_32	.text
    16a1:	00 00                	add    %al,(%eax)
    16a3:	0a 11                	or     (%ecx),%dl	16a3: R_386_32	.text
    16a5:	00 00                	add    %al,(%eax)
    16a7:	bc 16 00 00 1e       	mov    $0x1e000016,%esp
    16ac:	5f                   	pop    %edi
    16ad:	63 70 00             	arpl   %si,0x0(%eax)
    16b0:	01 1f                	add    %ebx,(%edi)
    16b2:	01 99 00 00 00 9f    	add    %ebx,-0x61000000(%ecx)	16b7: R_386_32	.debug_loc
    16b8:	13 00                	adc    (%eax),%eax
    16ba:	00 00                	add    %al,(%eax)
    16bc:	27                   	daa    
    16bd:	83 04 00 00          	addl   $0x0,(%eax,%eax,1)
    16c1:	0a 11                	or     (%ecx),%dl	16c1: R_386_32	.text
    16c3:	00 00                	add    %al,(%eax)
    16c5:	25 11 00 00 01       	and    $0x1000011,%eax	16c5: R_386_32	.text
    16ca:	20 01                	and    %al,(%ecx)
    16cc:	e3 16                	jecxz  16e4 <.debug_info+0x16e4>
    16ce:	00 00                	add    %al,(%eax)
    16d0:	1d a1 04 00 00       	sbb    $0x4a1,%eax
    16d5:	bf 13 00 00 1d       	mov    $0x1d000013,%edi	16d5: R_386_32	.debug_loc
    16da:	96                   	xchg   %eax,%esi
    16db:	04 00                	add    $0x0,%al
    16dd:	00 d2                	add    %dl,%dl	16de: R_386_32	.debug_loc
    16df:	13 00                	adc    (%eax),%eax
    16e1:	00 00                	add    %al,(%eax)
    16e3:	27                   	daa    
    16e4:	27                   	daa    
    16e5:	04 00                	add    $0x0,%al
    16e7:	00 40 11             	add    %al,0x11(%eax)	16e8: R_386_32	.text
    16ea:	00 00                	add    %al,(%eax)
    16ec:	78 11                	js     16ff <.debug_info+0x16ff>	16ec: R_386_32	.text
    16ee:	00 00                	add    %al,(%eax)
    16f0:	01 2b                	add    %ebp,(%ebx)
    16f2:	01 06                	add    %eax,(%esi)
    16f4:	17                   	pop    %ss
    16f5:	00 00                	add    %al,(%eax)
    16f7:	1d 45 04 00 00       	sbb    $0x445,%eax
    16fc:	e8 13 00 00 35       	call   35001714 <ipport_set+0x35000451>	16fc: R_386_32	.debug_loc
    1701:	3a 04 00             	cmp    (%eax,%eax,1),%al
    1704:	00 00                	add    %al,(%eax)
    1706:	27                   	daa    
    1707:	27                   	daa    
    1708:	04 00                	add    $0x0,%al
    170a:	00 99 11 00 00 c6    	add    %bl,-0x39ffffef(%ecx)	170b: R_386_32	.text
	170f: R_386_32	.text
    1710:	11 00                	adc    %eax,(%eax)
    1712:	00 01                	add    %al,(%ecx)
    1714:	37                   	aaa    
    1715:	01 29                	add    %ebp,(%ecx)
    1717:	17                   	pop    %ss
    1718:	00 00                	add    %al,(%eax)
    171a:	1d 45 04 00 00       	sbb    $0x445,%eax
    171f:	00 14 00             	add    %dl,(%eax,%eax,1)	171f: R_386_32	.debug_loc
    1722:	00 35 3a 04 00 00    	add    %dh,0x43a
    1728:	00 36                	add    %dh,(%esi)
    172a:	e2 04                	loop   1730 <.debug_info+0x1730>
    172c:	00 00                	add    %al,(%eax)
    172e:	c6                   	(bad)  	172e: R_386_32	.text
    172f:	11 00                	adc    %eax,(%eax)
    1731:	00 e2                	add    %ah,%dl	1732: R_386_32	.text
    1733:	11 00                	adc    %eax,(%eax)
    1735:	00 01                	add    %al,(%ecx)
    1737:	c1 1d 0b 05 00 00 18 	rcrl   $0x18,0x50b	173d: R_386_32	.debug_loc
    173e:	14 00                	adc    $0x0,%al
    1740:	00 1d 00 05 00 00    	add    %bl,0x500
    1746:	2d 14 00 00 1d       	sub    $0x1d000014,%eax	1746: R_386_32	.debug_loc
    174b:	f5                   	cmc    
    174c:	04 00                	add    $0x0,%al
    174e:	00 43 14             	add    %al,0x14(%ebx)	174f: R_386_32	.debug_loc
    1751:	00 00                	add    %al,(%eax)
    1753:	00 00                	add    %al,(%eax)
    1755:	0c 9f                	or     $0x9f,%al
    1757:	00 00                	add    %al,(%eax)
    1759:	00 66 17             	add    %ah,0x17(%esi)
    175c:	00 00                	add    %al,(%eax)
    175e:	29 30                	sub    %esi,(%eax)
    1760:	00 00                	add    %al,(%eax)
    1762:	00 ff                	add    %bh,%bh
    1764:	03 00                	add    (%eax),%eax
    1766:	0c 9f                	or     $0x9f,%al
    1768:	00 00                	add    %al,(%eax)
    176a:	00 77 17             	add    %dh,0x17(%edi)
    176d:	00 00                	add    %al,(%eax)
    176f:	29 30                	sub    %esi,(%eax)
    1771:	00 00                	add    %al,(%eax)
    1773:	00 ff                	add    %bh,%bh
    1775:	01 00                	add    %eax,(%eax)
    1777:	1b 01                	sbb    (%ecx),%eax
    1779:	e2 04                	loop   177f <.debug_info+0x177f>	1779: R_386_32	.debug_str
    177b:	00 00                	add    %al,(%eax)
    177d:	01 73 01             	add    %esi,0x1(%ebx)
    1780:	01 5a 00             	add    %ebx,0x0(%edx)
    1783:	00 00                	add    %al,(%eax)
    1785:	24 12                	and    $0x12,%al	1785: R_386_32	.text
    1787:	00 00                	add    %al,(%eax)
    1789:	76 12                	jbe    179d <.debug_info+0x179d>	1789: R_386_32	.text
    178b:	00 00                	add    %al,(%eax)
    178d:	72 14                	jb     17a3 <.debug_info+0x17a3>	178d: R_386_32	.debug_loc
    178f:	00 00                	add    %al,(%eax)
    1791:	d2 17                	rclb   %cl,(%edi)
    1793:	00 00                	add    %al,(%eax)
    1795:	37                   	aaa    
    1796:	bb 01 00 00 01       	mov    $0x1000001,%ebx	1796: R_386_32	.debug_str
    179b:	73 01                	jae    179e <.debug_info+0x179e>
    179d:	e2 02                	loop   17a1 <.debug_info+0x17a1>
    179f:	00 00                	add    %al,(%eax)
    17a1:	02 91 00 37 b3 03    	add    0x3b33700(%ecx),%dl	17a5: R_386_32	.debug_str
    17a7:	00 00                	add    %al,(%eax)
    17a9:	01 73 01             	add    %esi,0x1(%ebx)
    17ac:	00 04 00             	add    %al,(%eax,%eax,1)
    17af:	00 02                	add    %al,(%edx)
    17b1:	91                   	xchg   %eax,%ecx
    17b2:	04 1e                	add    $0x1e,%al
    17b4:	66                   	data16
    17b5:	00 01                	add    %al,(%ecx)
    17b7:	75 01                	jne    17ba <.debug_info+0x17ba>
    17b9:	52                   	push   %edx
    17ba:	04 00                	add    $0x0,%al
    17bc:	00 9e 14 00 00 20    	add    %bl,0x20000014(%esi)	17bd: R_386_32	.debug_loc
    17c2:	ee                   	out    %al,(%dx)	17c2: R_386_32	.debug_str
    17c3:	00 00                	add    %al,(%eax)
    17c5:	00 01                	add    %al,(%ecx)
    17c7:	76 01                	jbe    17ca <.debug_info+0x17ca>
    17c9:	5a                   	pop    %edx
    17ca:	00 00                	add    %al,(%eax)
    17cc:	00 bc 14 00 00 00 1b 	add    %bh,0x1b000000(%esp,%edx,1)	17cd: R_386_32	.debug_loc
    17d3:	01 15 00 00 00 01    	add    %edx,0x1000000	17d4: R_386_32	.debug_str
    17d9:	83 01 01             	addl   $0x1,(%ecx)
    17dc:	5a                   	pop    %edx
    17dd:	00 00                	add    %al,(%eax)
    17df:	00 76 12             	add    %dh,0x12(%esi)	17e0: R_386_32	.text
    17e2:	00 00                	add    %al,(%eax)
    17e4:	90                   	nop	17e4: R_386_32	.text
    17e5:	12 00                	adc    (%eax),%al
    17e7:	00 da                	add    %bl,%dl	17e8: R_386_32	.debug_loc
    17e9:	14 00                	adc    $0x0,%al
    17eb:	00 00                	add    %al,(%eax)
    17ed:	18 00                	sbb    %al,(%eax)
    17ef:	00 37                	add    %dh,(%edi)
    17f1:	b3 03                	mov    $0x3,%bl	17f1: R_386_32	.debug_str
    17f3:	00 00                	add    %al,(%eax)
    17f5:	01 83 01 00 04 00    	add    %eax,0x40001(%ebx)
    17fb:	00 02                	add    %al,(%edx)
    17fd:	91                   	xchg   %eax,%ecx
    17fe:	00 00                	add    %al,(%eax)
    1800:	18 01                	sbb    %al,(%ecx)
    1802:	d3 02                	roll   %cl,(%edx)	1802: R_386_32	.debug_str
    1804:	00 00                	add    %al,(%eax)
    1806:	01 4a 03             	add    %ecx,0x3(%edx)
    1809:	01 5a 00             	add    %ebx,0x0(%edx)
    180c:	00 00                	add    %al,(%eax)
    180e:	90                   	nop	180e: R_386_32	.text
    180f:	12 00                	adc    (%eax),%al
    1811:	00 96 12 00 00 02    	add    %dl,0x2000012(%esi)	1812: R_386_32	.text
    1817:	74 04                	je     181d <.debug_info+0x181d>
    1819:	37                   	aaa    
    181a:	18 00                	sbb    %al,(%eax)
    181c:	00 19                	add    %bl,(%ecx)
    181e:	76 61                	jbe    1881 <.debug_info+0x1881>
    1820:	72 00                	jb     1822 <.debug_info+0x1822>
    1822:	01 4a 03             	add    %ecx,0x3(%edx)
    1825:	00 04 00             	add    %al,(%eax,%eax,1)
    1828:	00 02                	add    %al,(%edx)
    182a:	91                   	xchg   %eax,%ecx
    182b:	00 1a                	add    %bl,(%edx)
    182d:	73 00                	jae    182f <.debug_info+0x182f>
    182f:	01 4a 03             	add    %ecx,0x3(%edx)
    1832:	99                   	cltd   
    1833:	00 00                	add    %al,(%eax)
    1835:	00 00                	add    %al,(%eax)
    1837:	1b 01                	sbb    (%ecx),%eax
    1839:	34 01                	xor    $0x1,%al	1839: R_386_32	.debug_str
    183b:	00 00                	add    %al,(%eax)
    183d:	01 51 03             	add    %edx,0x3(%ecx)
    1840:	01 5a 00             	add    %ebx,0x0(%edx)
    1843:	00 00                	add    %al,(%eax)
    1845:	96                   	xchg   %eax,%esi	1845: R_386_32	.text
    1846:	12 00                	adc    (%eax),%al
    1848:	00 bd 12 00 00 06    	add    %bh,0x6000012(%ebp)	1849: R_386_32	.text
	184d: R_386_32	.debug_loc
    184e:	15 00 00 72 18       	adc    $0x18720000,%eax
    1853:	00 00                	add    %al,(%eax)
    1855:	19 76 61             	sbb    %esi,0x61(%esi)
    1858:	72 00                	jb     185a <.debug_info+0x185a>
    185a:	01 51 03             	add    %edx,0x3(%ecx)
    185d:	00 04 00             	add    %al,(%eax,%eax,1)
    1860:	00 02                	add    %al,(%edx)
    1862:	91                   	xchg   %eax,%ecx
    1863:	00 19                	add    %bl,(%ecx)
    1865:	73 00                	jae    1867 <.debug_info+0x1867>
    1867:	01 51 03             	add    %edx,0x3(%ecx)
    186a:	e2 02                	loop   186e <.debug_info+0x186e>
    186c:	00 00                	add    %al,(%eax)
    186e:	02 91 04 00 18 01    	add    0x1180004(%ecx),%dl
    1874:	2a 05 00 00 01 5a    	sub    0x5a010000,%al	1874: R_386_32	.debug_str
    187a:	03 01                	add    (%ecx),%eax
    187c:	5a                   	pop    %edx
    187d:	00 00                	add    %al,(%eax)
    187f:	00 bd 12 00 00 c3    	add    %bh,-0x3cffffee(%ebp)	1880: R_386_32	.text
	1884: R_386_32	.text
    1885:	12 00                	adc    (%eax),%al
    1887:	00 02                	add    %al,(%edx)
    1889:	74 04                	je     188f <.debug_info+0x188f>
    188b:	a9 18 00 00 19       	test   $0x19000018,%eax
    1890:	76 61                	jbe    18f3 <.debug_info+0x18f3>
    1892:	72 00                	jb     1894 <.debug_info+0x1894>
    1894:	01 5a 03             	add    %ebx,0x3(%edx)
    1897:	00 04 00             	add    %al,(%eax,%eax,1)
    189a:	00 02                	add    %al,(%edx)
    189c:	91                   	xchg   %eax,%ecx
    189d:	00 1a                	add    %bl,(%edx)
    189f:	73 00                	jae    18a1 <.debug_info+0x18a1>
    18a1:	01 5a 03             	add    %ebx,0x3(%edx)
    18a4:	99                   	cltd   
    18a5:	00 00                	add    %al,(%eax)
    18a7:	00 00                	add    %al,(%eax)
    18a9:	1b 01                	sbb    (%ecx),%eax
    18ab:	6f                   	outsl  %ds:(%esi),(%dx)	18ab: R_386_32	.debug_str
    18ac:	03 00                	add    (%eax),%eax
    18ae:	00 01                	add    %al,(%ecx)
    18b0:	61                   	popa   
    18b1:	03 01                	add    (%ecx),%eax
    18b3:	5a                   	pop    %edx
    18b4:	00 00                	add    %al,(%eax)
    18b6:	00 c3                	add    %al,%bl	18b7: R_386_32	.text
    18b8:	12 00                	adc    (%eax),%al
    18ba:	00 ea                	add    %ch,%dl	18bb: R_386_32	.text
    18bc:	12 00                	adc    (%eax),%al
    18be:	00 4a 15             	add    %cl,0x15(%edx)	18bf: R_386_32	.debug_loc
    18c1:	00 00                	add    %al,(%eax)
    18c3:	e4 18                	in     $0x18,%al
    18c5:	00 00                	add    %al,(%eax)
    18c7:	19 76 61             	sbb    %esi,0x61(%esi)
    18ca:	72 00                	jb     18cc <.debug_info+0x18cc>
    18cc:	01 61 03             	add    %esp,0x3(%ecx)
    18cf:	00 04 00             	add    %al,(%eax,%eax,1)
    18d2:	00 02                	add    %al,(%edx)
    18d4:	91                   	xchg   %eax,%ecx
    18d5:	00 19                	add    %bl,(%ecx)
    18d7:	73 00                	jae    18d9 <.debug_info+0x18d9>
    18d9:	01 61 03             	add    %esp,0x3(%ecx)
    18dc:	e2 02                	loop   18e0 <.debug_info+0x18e0>
    18de:	00 00                	add    %al,(%eax)
    18e0:	02 91 04 00 0c 9f    	add    -0x60f3fffc(%ecx),%dl
    18e6:	00 00                	add    %al,(%eax)
    18e8:	00 f4                	add    %dh,%ah
    18ea:	18 00                	sbb    %al,(%eax)
    18ec:	00 0d 30 00 00 00    	add    %cl,0x30
    18f2:	04 00                	add    $0x0,%al
    18f4:	31 eb                	xor    %ebp,%ebx	18f5: R_386_32	.debug_str
    18f6:	03 00                	add    (%eax),%eax
    18f8:	00 01                	add    %al,(%ecx)
    18fa:	30 05 19 00 00 05    	xor    %al,0x5000019
    1900:	03 00                	add    (%eax),%eax	1901: R_386_32	.rodata
    1902:	00 00                	add    %al,(%eax)
    1904:	00 0e                	add    %cl,(%esi)
    1906:	e4 18                	in     $0x18,%al
    1908:	00 00                	add    %al,(%eax)
    190a:	38 a7 01 00 00 06    	cmp    %ah,0x6000001(%edi)	190b: R_386_32	.debug_str
    1910:	a9 b6 02 00 00       	test   $0x2b6,%eax
    1915:	01 01                	add    %eax,(%ecx)
    1917:	38 55 05             	cmp    %dl,0x5(%ebp)	1918: R_386_32	.debug_str
    191a:	00 00                	add    %al,(%eax)
    191c:	06                   	push   %es
    191d:	aa                   	stos   %al,%es:(%edi)
    191e:	b6 02                	mov    $0x2,%dh
    1920:	00 00                	add    %al,(%eax)
    1922:	01 01                	add    %eax,(%ecx)
    1924:	38 42 02             	cmp    %al,0x2(%edx)	1925: R_386_32	.debug_str
    1927:	00 00                	add    %al,(%eax)
    1929:	06                   	push   %es
    192a:	ab                   	stos   %eax,%es:(%edi)
    192b:	b6 02                	mov    $0x2,%dh
    192d:	00 00                	add    %al,(%eax)
    192f:	01 01                	add    %eax,(%ecx)
    1931:	0c a0                	or     $0xa0,%al
    1933:	03 00                	add    (%eax),%eax
    1935:	00 41 19             	add    %al,0x19(%ecx)
    1938:	00 00                	add    %al,(%eax)
    193a:	0d 30 00 00 00       	or     $0x30,%eax
    193f:	19 00                	sbb    %eax,(%eax)
    1941:	39 93 00 00 00 01    	cmp    %edx,0x1000000(%ebx)	1942: R_386_32	.debug_str
    1947:	3e 31 19             	xor    %ebx,%ds:(%ecx)
    194a:	00 00                	add    %al,(%eax)
    194c:	01 05 03 00 00 00    	add    %eax,0x3	194f: R_386_32	conf_type_tab
    1952:	00 00                	add    %al,(%eax)

Disassembly of section .debug_abbrev:

00000000 <.debug_abbrev>:
int bin64_get(struct conf_var *var, char *s)
{
	s = "";

	return 0;
}
   0:	01 11                	add    %edx,(%ecx)
   2:	01 25 0e 13 0b 03    	add    %esp,0x30b130e
int oct32_get(struct conf_var *var, char *s)
{
	s = "";

	return 0;
}
   8:	0e                   	push   %cs
   9:	1b 0e                	sbb    (%esi),%ecx
   b:	11 01                	adc    %eax,(%ecx)

	return 0;
}

int ratio_set(struct conf_var *var, const char *s)
{
   d:	12 01                	adc    (%ecx),%al
   f:	10 06                	adc    %al,(%esi)
  11:	00 00                	add    %al,(%eax)
  13:	02 16                	add    (%esi),%dl
	if (var->p == NULL) {
  15:	00 03                	add    %al,(%ebx)
  17:	0e                   	push   %cs
  18:	3a 0b                	cmp    (%ebx),%cl
		var->p = malloc(2 * sizeof(int));
  1a:	3b 0b                	cmp    (%ebx),%ecx
  1c:	49                   	dec    %ecx
  1d:	13 00                	adc    (%eax),%eax
  1f:	00 03                	add    %al,(%ebx)
  21:	24 00                	and    $0x0,%al
  23:	0b 0b                	or     (%ebx),%ecx
  25:	3e 0b 03             	or     %ds:(%ebx),%eax
  28:	0e                   	push   %cs
	}

	return 0;
}
  29:	00 00                	add    %al,(%eax)
  2b:	04 24                	add    $0x24,%al
  2d:	00 0b                	add    %cl,(%ebx)
  2f:	0b 3e                	or     (%esi),%edi
  31:	0b 03                	or     (%ebx),%eax

	return 0;
}

int cymk_set(struct conf_var *var, const char *s)
{
  33:	08 00                	or     %al,(%eax)
  35:	00 05 0f 00 0b 0b    	add    %al,0xb0b000f
	if (var->p == NULL) {
  3b:	00 00                	add    %al,(%eax)
  3d:	06                   	push   %es
  3e:	0f 00 0b             	str    (%ebx)
		var->p = malloc(sizeof(unsigned int));
  41:	0b 49 13             	or     0x13(%ecx),%ecx
  44:	00 00                	add    %al,(%eax)
  46:	07                   	pop    %es
  47:	13 01                	adc    (%ecx),%eax
  49:	03 0e                	add    (%esi),%ecx
  4b:	0b 0b                	or     (%ebx),%ecx
  4d:	3a 0b                	cmp    (%ebx),%cl
  4f:	3b 05 01 13 00 00    	cmp    0x1301,%eax
	}

	return 0;
}
  55:	08 0d 00 03 0e 3a    	or     %cl,0x3a0e0300

	return 0;
}

int rgbi_set(struct conf_var *var, const char *s)
{
  5b:	0b 3b                	or     (%ebx),%edi
  5d:	05 49 13 38 0a       	add    $0xa381349,%eax
	if (var->p == NULL) {
  62:	00 00                	add    %al,(%eax)
  64:	09 16                	or     %edx,(%esi)
  66:	00 03                	add    %al,(%ebx)
		var->p = malloc(sizeof(unsigned int));
  68:	0e                   	push   %cs
  69:	3a 0b                	cmp    (%ebx),%cl
  6b:	3b 0b                	cmp    (%ebx),%ecx
  6d:	00 00                	add    %al,(%eax)
  6f:	0a 13                	or     (%ebx),%dl
  71:	01 03                	add    %eax,(%ebx)
  73:	0e                   	push   %cs
  74:	0b 0b                	or     (%ebx),%ecx
  76:	3a 0b                	cmp    (%ebx),%cl
	}

	return 0;
}
  78:	3b 0b                	cmp    (%ebx),%ecx
  7a:	01 13                	add    %edx,(%ebx)
  7c:	00 00                	add    %al,(%eax)
  7e:	0b 0d 00 03 0e 3a    	or     0x3a0e0300,%ecx

	return 0;
}

int rgb_set(struct conf_var *var, const char *s)
{
  84:	0b 3b                	or     (%ebx),%edi
  86:	0b 49 13             	or     0x13(%ecx),%ecx
	if (var->p == NULL) {
  89:	38 0a                	cmp    %cl,(%edx)
  8b:	00 00                	add    %al,(%eax)
  8d:	0c 01                	or     $0x1,%al
		var->p = malloc(sizeof(unsigned int));
  8f:	01 49 13             	add    %ecx,0x13(%ecx)
  92:	01 13                	add    %edx,(%ebx)
  94:	00 00                	add    %al,(%eax)
  96:	0d 21 00 49 13       	or     $0x13490021,%eax
  9b:	2f                   	das    
  9c:	0b 00                	or     (%eax),%eax
	}

	return 0;
}
  9e:	00 0e                	add    %cl,(%esi)
  a0:	26 00 49 13          	add    %cl,%es:0x13(%ecx)
  a4:	00 00                	add    %al,(%eax)
  a6:	0f 04                	(bad)  

	return 0;
}

int oct64_set(struct conf_var *var, const char *s)
{
  a8:	01 0b                	add    %ecx,(%ebx)
  aa:	0b 3a                	or     (%edx),%edi
  ac:	0b 3b                	or     (%ebx),%edi
  ae:	0b 01                	or     (%ecx),%eax
	if (var->p == NULL) {
  b0:	13 00                	adc    (%eax),%eax
  b2:	00 10                	add    %dl,(%eax)
  b4:	28 00                	sub    %al,(%eax)
		var->p = malloc(sizeof(long long int));
  b6:	03 0e                	add    (%esi),%ecx
  b8:	1c 0d                	sbb    $0xd,%al
  ba:	00 00                	add    %al,(%eax)
  bc:	11 0d 00 03 08 3a    	adc    %ecx,0x3a080300
  c2:	0b 3b                	or     (%ebx),%edi
  c4:	0b 49 13             	or     0x13(%ecx),%ecx
	}

	return 0;
}
  c7:	38 0a                	cmp    %cl,(%edx)
  c9:	00 00                	add    %al,(%eax)
  cb:	12 15 01 27 0c 49    	adc    0x490c2701,%dl

	return 0;
}

int oct32_set(struct conf_var *var, const char *s)
{
  d1:	13 01                	adc    (%ecx),%eax
  d3:	13 00                	adc    (%eax),%eax
  d5:	00 13                	add    %dl,(%ebx)
	if (var->p == NULL) {
  d7:	05 00 49 13 00       	add    $0x134900,%eax
  dc:	00 14 2e             	add    %dl,(%esi,%ebp,1)
		var->p = malloc(sizeof(unsigned int));
  df:	01 3f                	add    %edi,(%edi)
  e1:	0c 03                	or     $0x3,%al
  e3:	0e                   	push   %cs
  e4:	3a 0b                	cmp    (%ebx),%cl
  e6:	3b 0b                	cmp    (%ebx),%ecx
  e8:	27                   	daa    
  e9:	0c 49                	or     $0x49,%al
  eb:	13 20                	adc    (%eax),%esp
	}

	return 0;
}
  ed:	0b 34 0c             	or     (%esp,%ecx,1),%esi
  f0:	01 13                	add    %edx,(%ebx)
  f2:	00 00                	add    %al,(%eax)
  f4:	15 05 00 03 0e       	adc    $0xe030005,%eax

	return 0;
}

int oct16_set(struct conf_var *var, const char *s)
{
  f9:	3a 0b                	cmp    (%ebx),%cl
  fb:	3b 0b                	cmp    (%ebx),%ecx
  fd:	49                   	dec    %ecx
	if (var->p == NULL) {
  fe:	13 00                	adc    (%eax),%eax
 100:	00 16                	add    %dl,(%esi)
 102:	18 00                	sbb    %al,(%eax)
		var->p = malloc(sizeof(short int));
 104:	00 00                	add    %al,(%eax)
 106:	17                   	pop    %ss
 107:	05 00 03 08 3a       	add    $0x3a080300,%eax
 10c:	0b 3b                	or     (%ebx),%edi
 10e:	0b 49 13             	or     0x13(%ecx),%ecx
 111:	00 00                	add    %al,(%eax)
	}

	return 0;
}
 113:	18 2e                	sbb    %ch,(%esi)
 115:	01 3f                	add    %edi,(%edi)
 117:	0c 03                	or     $0x3,%al
 119:	0e                   	push   %cs
 11a:	3a 0b                	cmp    (%ebx),%cl
 11c:	3b 05 27 0c 49 13    	cmp    0x13490c27,%eax

	return 0;
}

int oct8_set(struct conf_var *var, const char *s)
{
 122:	11 01                	adc    %eax,(%ecx)
 124:	12 01                	adc    (%ecx),%al
	if (var->p == NULL) {
 126:	40                   	inc    %eax
 127:	0a 01                	or     (%ecx),%al
 129:	13 00                	adc    (%eax),%eax
		var->p = malloc(sizeof(unsigned char));
 12b:	00 19                	add    %bl,(%ecx)
 12d:	05 00 03 08 3a       	add    $0x3a080300,%eax
 132:	0b 3b                	or     (%ebx),%edi
 134:	05 49 13 02 0a       	add    $0xa021349,%eax
 139:	00 00                	add    %al,(%eax)
	}

	return 0;
}
 13b:	1a 05 00 03 08 3a    	sbb    0x3a080300,%al
 141:	0b 3b                	or     (%ebx),%edi
 143:	05 49 13 00 00       	add    $0x1349,%eax

	return 0;
}

int bin64_set(struct conf_var *var, const char *s)
{
 148:	1b 2e                	sbb    (%esi),%ebp
 14a:	01 3f                	add    %edi,(%edi)
	if (var->p == NULL) {
 14c:	0c 03                	or     $0x3,%al
 14e:	0e                   	push   %cs
 14f:	3a 0b                	cmp    (%ebx),%cl
 151:	3b 05 27 0c 49 13    	cmp    0x13490c27,%eax
		var->p = malloc(sizeof(long long int));
 157:	11 01                	adc    %eax,(%ecx)
 159:	12 01                	adc    (%ecx),%al
 15b:	40                   	inc    %eax
 15c:	06                   	push   %es
 15d:	01 13                	add    %edx,(%ebx)
 15f:	00 00                	add    %al,(%eax)
	}

	return 0;
}
 161:	1c 1d                	sbb    $0x1d,%al
 163:	01 31                	add    %esi,(%ecx)
 165:	13 11                	adc    (%ecx),%edx
 167:	01 12                	add    %edx,(%edx)
 169:	01 58 0b             	add    %ebx,0xb(%eax)

	return 0;
}

int bin32_set(struct conf_var *var, const char *s)
{
 16c:	59                   	pop    %ecx
 16d:	05 00 00 1d 05       	add    $0x51d0000,%eax
 172:	00 31                	add    %dh,(%ecx)
	if (var->p == NULL) {
 174:	13 02                	adc    (%edx),%eax
 176:	06                   	push   %es
 177:	00 00                	add    %al,(%eax)
		var->p = malloc(sizeof(unsigned long));
 179:	1e                   	push   %ds
 17a:	34 00                	xor    $0x0,%al
 17c:	03 08                	add    (%eax),%ecx
 17e:	3a 0b                	cmp    (%ebx),%cl
 180:	3b 05 49 13 02 06    	cmp    0x6021349,%eax
 186:	00 00                	add    %al,(%eax)
	}
	return 0;
}
 188:	1f                   	pop    %ds
 189:	0b 01                	or     (%ecx),%eax
 18b:	11 01                	adc    %eax,(%ecx)
 18d:	12 01                	adc    (%ecx),%al
 18f:	00 00                	add    %al,(%eax)
 191:	20 34 00             	and    %dh,(%eax,%eax,1)

	return 0;
}

int bin16_set(struct conf_var *var, const char *s)
{
 194:	03 0e                	add    (%esi),%ecx
 196:	3a 0b                	cmp    (%ebx),%cl
 198:	3b 05 49 13 02 06    	cmp    0x6021349,%eax
	if (var->p == NULL) {
 19e:	00 00                	add    %al,(%eax)
		var->p = malloc(sizeof(short int));
 1a0:	21 0b                	and    %ecx,(%ebx)
 1a2:	01 55 06             	add    %edx,0x6(%ebp)
 1a5:	00 00                	add    %al,(%eax)
 1a7:	22 2e                	and    (%esi),%ch
 1a9:	01 03                	add    %eax,(%ebx)
 1ab:	0e                   	push   %cs
 1ac:	3a 0b                	cmp    (%ebx),%cl
 1ae:	3b 05 27 0c 49 13    	cmp    0x13490c27,%eax
	}

	return 0;
}
 1b4:	11 01                	adc    %eax,(%ecx)
 1b6:	12 01                	adc    (%ecx),%al
 1b8:	40                   	inc    %eax

	return 0;
}

int bin8_set(struct conf_var *var, const char *s)
{
 1b9:	06                   	push   %es
 1ba:	01 13                	add    %edx,(%ebx)
 1bc:	00 00                	add    %al,(%eax)
 1be:	23 05 00 03 08 3a    	and    0x3a080300,%eax
	if (var->p == NULL) {
 1c4:	0b 3b                	or     (%ebx),%edi
 1c6:	05 49 13 02 06       	add    $0x6021349,%eax
		var->p = malloc(sizeof(unsigned char));
 1cb:	00 00                	add    %al,(%eax)
 1cd:	24 05                	and    $0x5,%al
 1cf:	00 03                	add    %al,(%ebx)
 1d1:	0e                   	push   %cs
 1d2:	3a 0b                	cmp    (%ebx),%cl
 1d4:	3b 05 49 13 02 06    	cmp    0x6021349,%eax
	}

	return 0;
}
 1da:	00 00                	add    %al,(%eax)
 1dc:	25 34 00 03 08       	and    $0x8030034,%eax
{
	return write_section(stdout, root, NULL);
}

int void_get(struct conf_var *var, char *s)
{
 1e1:	3a 0b                	cmp    (%ebx),%cl
 1e3:	3b 05 49 13 02 0a    	cmp    0xa021349,%eax
	if (var->p == NULL) {
 1e9:	00 00                	add    %al,(%eax)
 1eb:	26                   	es
 1ec:	34 00                	xor    $0x0,%al
 1ee:	03 0e                	add    (%esi),%ecx
 1f0:	3a 0b                	cmp    (%ebx),%cl

#ifdef __va_arg_pack
__extern_always_inline int
__NTH (sprintf (char *__restrict __s, __const char *__restrict __fmt, ...))
{
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
 1f2:	3b 05 49 13 02 0a    	cmp    0xa021349,%eax
 1f8:	00 00                	add    %al,(%eax)
 1fa:	27                   	daa    
 1fb:	1d 01 31 13 11       	sbb    $0x11133101,%eax
 200:	01 12                	add    %edx,(%edx)
 202:	01 58 0b             	add    %ebx,0xb(%eax)
 205:	59                   	pop    %ecx
 206:	05 01 13 00 00       	add    $0x1301,%eax
 20b:	28 1d 01 31 13 52    	sub    %bl,0x52133101
 211:	01 55 06             	add    %edx,0x6(%ebp)
 214:	58                   	pop    %eax
 215:	0b 59 05             	or     0x5(%ecx),%ebx
 218:	01 13                	add    %edx,(%ebx)
 21a:	00 00                	add    %al,(%eax)
 21c:	29 21                	sub    %esp,(%ecx)
 21e:	00 49 13             	add    %cl,0x13(%ecx)
 221:	2f                   	das    
		sprintf(s, "NULL");
		return 0;
	}

	sprintf(s, "%p", var->p);
	return 1;
 222:	05 00 00 2a 2e       	add    $0x2e2a0000,%eax
}
 227:	01 3f                	add    %edi,(%edi)
 229:	0c 03                	or     $0x3,%al
	sscanf(s, "%p", &(var->p));
	return 1;
}

int int_get(struct conf_var *var, char *s)
{
 22b:	0e                   	push   %cs
 22c:	3a 0b                	cmp    (%ebx),%cl
 22e:	3b 0b                	cmp    (%ebx),%ecx
 230:	27                   	daa    
 231:	0c 49                	or     $0x49,%al
	if (var->p == NULL) {
 233:	13 11                	adc    (%ecx),%edx
 235:	01 12                	add    %edx,(%edx)
 237:	01 40 06             	add    %eax,0x6(%eax)
 23a:	01 13                	add    %edx,(%ebx)
 23c:	00 00                	add    %al,(%eax)
 23e:	2b 05 00 03 0e 3a    	sub    0x3a0e0300,%eax
 244:	0b 3b                	or     (%ebx),%edi
 246:	0b 49 13             	or     0x13(%ecx),%ecx
 249:	02 0a                	add    (%edx),%cl
 24b:	00 00                	add    %al,(%eax)
 24d:	2c 34                	sub    $0x34,%al
 24f:	00 03                	add    %al,(%ebx)
 251:	0e                   	push   %cs
 252:	3a 0b                	cmp    (%ebx),%cl
 254:	3b 0b                	cmp    (%ebx),%ecx
 256:	49                   	dec    %ecx
 257:	13 02                	adc    (%edx),%eax
 259:	06                   	push   %es
 25a:	00 00                	add    %al,(%eax)
 25c:	2d 34 00 03 0e       	sub    $0xe030034,%eax
 261:	3a 0b                	cmp    (%ebx),%cl
 263:	3b 0b                	cmp    (%ebx),%ecx
 265:	49                   	dec    %ecx
 266:	13 00                	adc    (%eax),%eax
 268:	00 2e                	add    %ch,(%esi)
 26a:	05 00 03 0e 3a       	add    $0x3a0e0300,%eax
		sprintf(s, "NULL");
		return 0;
	}

	sprintf(s, "%i", *(int *) (var->p));
	return 1;
 26f:	0b 3b                	or     (%ebx),%edi
 271:	0b 49 13             	or     0x13(%ecx),%ecx
}
 274:	02 06                	add    (%esi),%al
 276:	00 00                	add    %al,(%eax)

	return 1;
}

int uint_get(struct conf_var *var, char *s)
{
 278:	2f                   	das    
 279:	34 00                	xor    $0x0,%al
 27b:	03 08                	add    (%eax),%ecx
 27d:	3a 0b                	cmp    (%ebx),%cl
	if (var->p == NULL) {
 27f:	3b 0b                	cmp    (%ebx),%ecx
 281:	49                   	dec    %ecx
 282:	13 02                	adc    (%edx),%eax
 284:	06                   	push   %es
 285:	00 00                	add    %al,(%eax)
 287:	30 34 00             	xor    %dh,(%eax,%eax,1)
 28a:	03 08                	add    (%eax),%ecx
 28c:	3a 0b                	cmp    (%ebx),%cl
 28e:	3b 0b                	cmp    (%ebx),%ecx
 290:	49                   	dec    %ecx
 291:	13 02                	adc    (%edx),%eax
 293:	0a 00                	or     (%eax),%al
		sprintf(s, "NULL");
		return 0;
 295:	00 31                	add    %dh,(%ecx)
 297:	34 00                	xor    $0x0,%al
 299:	03 0e                	add    (%esi),%ecx
 29b:	3a 0b                	cmp    (%ebx),%cl
 29d:	3b 0b                	cmp    (%ebx),%ecx
 29f:	49                   	dec    %ecx
 2a0:	13 02                	adc    (%edx),%eax
 2a2:	0a 00                	or     (%eax),%al
 2a4:	00 32                	add    %dh,(%edx)
 2a6:	0b 01                	or     (%ecx),%eax
 2a8:	11 01                	adc    %eax,(%ecx)
 2aa:	12 01                	adc    (%ecx),%al
 2ac:	01 13                	add    %edx,(%ebx)
 2ae:	00 00                	add    %al,(%eax)
 2b0:	33 0b                	xor    (%ebx),%ecx
 2b2:	01 55 06             	add    %edx,0x6(%ebp)
 2b5:	01 13                	add    %edx,(%ebx)
 2b7:	00 00                	add    %al,(%eax)
 2b9:	34 1d                	xor    $0x1d,%al
 2bb:	01 31                	add    %esi,(%ecx)
	}

	sprintf(s, "%u", *(unsigned int *) (var->p));
	return 1;
 2bd:	13 11                	adc    (%ecx),%edx
 2bf:	01 12                	add    %edx,(%edx)
}
 2c1:	01 58 0b             	add    %ebx,0xb(%eax)
 2c4:	59                   	pop    %ecx

	return 1;
}

int float_get(struct conf_var *var, char *s)
{
 2c5:	0b 01                	or     (%ecx),%eax
 2c7:	13 00                	adc    (%eax),%eax
 2c9:	00 35 05 00 31 13    	add    %dh,0x13310005
	if (var->p == NULL) {
 2cf:	00 00                	add    %al,(%eax)
 2d1:	36                   	ss
 2d2:	1d 01 31 13 11       	sbb    $0x11133101,%eax
 2d7:	01 12                	add    %edx,(%edx)
 2d9:	01 58 0b             	add    %ebx,0xb(%eax)
 2dc:	59                   	pop    %ecx
 2dd:	0b 00                	or     (%eax),%eax
 2df:	00 37                	add    %dh,(%edi)
		sprintf(s, "NULL");
		return 0;
 2e1:	05 00 03 0e 3a       	add    $0x3a0e0300,%eax
 2e6:	0b 3b                	or     (%ebx),%edi
 2e8:	05 49 13 02 0a       	add    $0xa021349,%eax
 2ed:	00 00                	add    %al,(%eax)
 2ef:	38 34 00             	cmp    %dh,(%eax,%eax,1)
 2f2:	03 0e                	add    (%esi),%ecx
 2f4:	3a 0b                	cmp    (%ebx),%cl
 2f6:	3b 0b                	cmp    (%ebx),%ecx
 2f8:	49                   	dec    %ecx
 2f9:	13 3f                	adc    (%edi),%edi
 2fb:	0c 3c                	or     $0x3c,%al
 2fd:	0c 00                	or     $0x0,%al
 2ff:	00 39                	add    %bh,(%ecx)
 301:	34 00                	xor    $0x0,%al
 303:	03 0e                	add    (%esi),%ecx
 305:	3a 0b                	cmp    (%ebx),%cl
 307:	3b 0b                	cmp    (%ebx),%ecx
	}

	sprintf(s, "%f", *(double *) (var->p));
	return 1;
 309:	49                   	dec    %ecx
 30a:	13 3f                	adc    (%edi),%edi
 30c:	0c 02                	or     $0x2,%al
}
 30e:	0a 00                	or     (%eax),%al
 310:	00 00                	add    %al,(%eax)

Disassembly of section .debug_loc:

00000000 <.debug_loc>:
int bin64_get(struct conf_var *var, char *s)
{
	s = "";

	return 0;
}
       0:	0c 00                	or     $0x0,%al
       2:	00 00                	add    %al,(%eax)
       4:	0d 00 00 00 02       	or     $0x2000000,%eax
int oct32_get(struct conf_var *var, char *s)
{
	s = "";

	return 0;
}
       9:	00 74 04 0d          	add    %dh,0xd(%esp,%eax,1)

	return 0;
}

int ratio_set(struct conf_var *var, const char *s)
{
       d:	00 00                	add    %al,(%eax)
       f:	00 10                	add    %dl,(%eax)
      11:	00 00                	add    %al,(%eax)
      13:	00 02                	add    %al,(%edx)
	if (var->p == NULL) {
      15:	00 74 08 10          	add    %dh,0x10(%eax,%ecx,1)
      19:	00 00                	add    %al,(%eax)
		var->p = malloc(2 * sizeof(int));
      1b:	00 31                	add    %dh,(%ecx)
      1d:	00 00                	add    %al,(%eax)
      1f:	00 02                	add    %al,(%edx)
      21:	00 74 20 31          	add    %dh,0x31(%eax,%eiz,1)
      25:	00 00                	add    %al,(%eax)
      27:	00 32                	add    %dh,(%edx)
	}

	return 0;
}
      29:	00 00                	add    %al,(%eax)
      2b:	00 02                	add    %al,(%edx)
      2d:	00 74 08 32          	add    %dh,0x32(%eax,%ecx,1)
      31:	00 00                	add    %al,(%eax)

	return 0;
}

int cymk_set(struct conf_var *var, const char *s)
{
      33:	00 33                	add    %dh,(%ebx)
      35:	00 00                	add    %al,(%eax)
      37:	00 02                	add    %al,(%edx)
      39:	00 74 04 00          	add    %dh,0x0(%esp,%eax,1)
	if (var->p == NULL) {
      3d:	00 00                	add    %al,(%eax)
      3f:	00 00                	add    %al,(%eax)
		var->p = malloc(sizeof(unsigned int));
      41:	00 00                	add    %al,(%eax)
      43:	00 33                	add    %dh,(%ebx)
      45:	00 00                	add    %al,(%eax)
      47:	00 34 00             	add    %dh,(%eax,%eax,1)
      4a:	00 00                	add    %al,(%eax)
      4c:	02 00                	add    (%eax),%al
      4e:	74 04                	je     54 <.debug_loc+0x54>
	}

	return 0;
}
      50:	34 00                	xor    $0x0,%al
      52:	00 00                	add    %al,(%eax)
      54:	37                   	aaa    
      55:	00 00                	add    %al,(%eax)
      57:	00 02                	add    %al,(%edx)
      59:	00 74 08 37          	add    %dh,0x37(%eax,%ecx,1)

	return 0;
}

int rgbi_set(struct conf_var *var, const char *s)
{
      5d:	00 00                	add    %al,(%eax)
      5f:	00 58 00             	add    %bl,0x0(%eax)
	if (var->p == NULL) {
      62:	00 00                	add    %al,(%eax)
      64:	02 00                	add    (%eax),%al
      66:	74 20                	je     88 <.debug_loc+0x88>
		var->p = malloc(sizeof(unsigned int));
      68:	58                   	pop    %eax
      69:	00 00                	add    %al,(%eax)
      6b:	00 59 00             	add    %bl,0x0(%ecx)
      6e:	00 00                	add    %al,(%eax)
      70:	02 00                	add    (%eax),%al
      72:	74 08                	je     7c <.debug_loc+0x7c>
      74:	59                   	pop    %ecx
      75:	00 00                	add    %al,(%eax)
	}

	return 0;
}
      77:	00 5a 00             	add    %bl,0x0(%edx)
      7a:	00 00                	add    %al,(%eax)
      7c:	02 00                	add    (%eax),%al
      7e:	74 04                	je     84 <.debug_loc+0x84>
      80:	00 00                	add    %al,(%eax)

	return 0;
}

int rgb_set(struct conf_var *var, const char *s)
{
      82:	00 00                	add    %al,(%eax)
      84:	00 00                	add    %al,(%eax)
      86:	00 00                	add    %al,(%eax)
      88:	5a                   	pop    %edx
	if (var->p == NULL) {
      89:	00 00                	add    %al,(%eax)
      8b:	00 5b 00             	add    %bl,0x0(%ebx)
      8e:	00 00                	add    %al,(%eax)
		var->p = malloc(sizeof(unsigned int));
      90:	02 00                	add    (%eax),%al
      92:	74 04                	je     98 <.debug_loc+0x98>
      94:	5b                   	pop    %ebx
      95:	00 00                	add    %al,(%eax)
      97:	00 5e 00             	add    %bl,0x0(%esi)
      9a:	00 00                	add    %al,(%eax)
      9c:	02 00                	add    (%eax),%al
	}

	return 0;
}
      9e:	74 08                	je     a8 <.debug_loc+0xa8>
      a0:	5e                   	pop    %esi
      a1:	00 00                	add    %al,(%eax)
      a3:	00 7f 00             	add    %bh,0x0(%edi)
      a6:	00 00                	add    %al,(%eax)

	return 0;
}

int oct64_set(struct conf_var *var, const char *s)
{
      a8:	02 00                	add    (%eax),%al
      aa:	74 20                	je     cc <.debug_loc+0xcc>
      ac:	7f 00                	jg     ae <.debug_loc+0xae>
      ae:	00 00                	add    %al,(%eax)
	if (var->p == NULL) {
      b0:	80 00 00             	addb   $0x0,(%eax)
      b3:	00 02                	add    %al,(%edx)
      b5:	00 74 08 80          	add    %dh,-0x80(%eax,%ecx,1)
		var->p = malloc(sizeof(long long int));
      b9:	00 00                	add    %al,(%eax)
      bb:	00 81 00 00 00 02    	add    %al,0x2000000(%ecx)
      c1:	00 74 04 00          	add    %dh,0x0(%esp,%eax,1)
	}

	return 0;
}
      c5:	00 00                	add    %al,(%eax)
      c7:	00 00                	add    %al,(%eax)
      c9:	00 00                	add    %al,(%eax)
      cb:	00 81 00 00 00 82    	add    %al,-0x7e000000(%ecx)

	return 0;
}

int oct32_set(struct conf_var *var, const char *s)
{
      d1:	00 00                	add    %al,(%eax)
      d3:	00 02                	add    %al,(%edx)
      d5:	00 74 04 82          	add    %dh,-0x7e(%esp,%eax,1)
	if (var->p == NULL) {
      d9:	00 00                	add    %al,(%eax)
      db:	00 85 00 00 00 02    	add    %al,0x2000000(%ebp)
		var->p = malloc(sizeof(unsigned int));
      e1:	00 74 08 85          	add    %dh,-0x7b(%eax,%ecx,1)
      e5:	00 00                	add    %al,(%eax)
      e7:	00 a6 00 00 00 02    	add    %ah,0x2000000(%esi)
	}

	return 0;
}
      ed:	00 74 20 a6          	add    %dh,-0x5a(%eax,%eiz,1)
      f1:	00 00                	add    %al,(%eax)
      f3:	00 a7 00 00 00 02    	add    %ah,0x2000000(%edi)

	return 0;
}

int oct16_set(struct conf_var *var, const char *s)
{
      f9:	00 74 08 a7          	add    %dh,-0x59(%eax,%ecx,1)
      fd:	00 00                	add    %al,(%eax)
	if (var->p == NULL) {
      ff:	00 a8 00 00 00 02    	add    %ch,0x2000000(%eax)
		var->p = malloc(sizeof(short int));
     105:	00 74 04 00          	add    %dh,0x0(%esp,%eax,1)
     109:	00 00                	add    %al,(%eax)
     10b:	00 00                	add    %al,(%eax)
     10d:	00 00                	add    %al,(%eax)
     10f:	00 a8 00 00 00 a9    	add    %ch,-0x57000000(%eax)
	}

	return 0;
}
     115:	00 00                	add    %al,(%eax)
     117:	00 02                	add    %al,(%edx)
     119:	00 74 04 a9          	add    %dh,-0x57(%esp,%eax,1)

	return 0;
}

int oct8_set(struct conf_var *var, const char *s)
{
     11d:	00 00                	add    %al,(%eax)
     11f:	00 ac 00 00 00 02 00 	add    %ch,0x20000(%eax,%eax,1)
	if (var->p == NULL) {
     126:	74 08                	je     130 <.debug_loc+0x130>
     128:	ac                   	lods   %ds:(%esi),%al
     129:	00 00                	add    %al,(%eax)
		var->p = malloc(sizeof(unsigned char));
     12b:	00 cd                	add    %cl,%ch
     12d:	00 00                	add    %al,(%eax)
     12f:	00 02                	add    %al,(%edx)
     131:	00 74 20 cd          	add    %dh,-0x33(%eax,%eiz,1)
     135:	00 00                	add    %al,(%eax)
     137:	00 ce                	add    %cl,%dh
     139:	00 00                	add    %al,(%eax)
	}

	return 0;
}
     13b:	00 02                	add    %al,(%edx)
     13d:	00 74 08 ce          	add    %dh,-0x32(%eax,%ecx,1)
     141:	00 00                	add    %al,(%eax)
     143:	00 cf                	add    %cl,%bh

	return 0;
}

int bin64_set(struct conf_var *var, const char *s)
{
     145:	00 00                	add    %al,(%eax)
     147:	00 02                	add    %al,(%edx)
     149:	00 74 04 00          	add    %dh,0x0(%esp,%eax,1)
	if (var->p == NULL) {
     14d:	00 00                	add    %al,(%eax)
     14f:	00 00                	add    %al,(%eax)
     151:	00 00                	add    %al,(%eax)
		var->p = malloc(sizeof(long long int));
     153:	00 cf                	add    %cl,%bh
     155:	00 00                	add    %al,(%eax)
     157:	00 d0                	add    %dl,%al
     159:	00 00                	add    %al,(%eax)
     15b:	00 02                	add    %al,(%edx)
     15d:	00 74 04 d0          	add    %dh,-0x30(%esp,%eax,1)
	}

	return 0;
}
     161:	00 00                	add    %al,(%eax)
     163:	00 d3                	add    %dl,%bl
     165:	00 00                	add    %al,(%eax)
     167:	00 02                	add    %al,(%edx)
     169:	00 74 08 d3          	add    %dh,-0x2d(%eax,%ecx,1)

	return 0;
}

int bin32_set(struct conf_var *var, const char *s)
{
     16d:	00 00                	add    %al,(%eax)
     16f:	00 f4                	add    %dh,%ah
     171:	00 00                	add    %al,(%eax)
	if (var->p == NULL) {
     173:	00 02                	add    %al,(%edx)
     175:	00 74 20 f4          	add    %dh,-0xc(%eax,%eiz,1)
		var->p = malloc(sizeof(unsigned long));
     179:	00 00                	add    %al,(%eax)
     17b:	00 f5                	add    %dh,%ch
     17d:	00 00                	add    %al,(%eax)
     17f:	00 02                	add    %al,(%edx)
     181:	00 74 08 f5          	add    %dh,-0xb(%eax,%ecx,1)
     185:	00 00                	add    %al,(%eax)
     187:	00 f6                	add    %dh,%dh
	}
	return 0;
}
     189:	00 00                	add    %al,(%eax)
     18b:	00 02                	add    %al,(%edx)
     18d:	00 74 04 00          	add    %dh,0x0(%esp,%eax,1)
     191:	00 00                	add    %al,(%eax)

	return 0;
}

int bin16_set(struct conf_var *var, const char *s)
{
     193:	00 00                	add    %al,(%eax)
     195:	00 00                	add    %al,(%eax)
     197:	00 f6                	add    %dh,%dh
     199:	00 00                	add    %al,(%eax)
	if (var->p == NULL) {
     19b:	00 f7                	add    %dh,%bh
     19d:	00 00                	add    %al,(%eax)
     19f:	00 02                	add    %al,(%edx)
		var->p = malloc(sizeof(short int));
     1a1:	00 74 04 f7          	add    %dh,-0x9(%esp,%eax,1)
     1a5:	00 00                	add    %al,(%eax)
     1a7:	00 fa                	add    %bh,%dl
     1a9:	00 00                	add    %al,(%eax)
     1ab:	00 02                	add    %al,(%edx)
     1ad:	00 74 08 fa          	add    %dh,-0x6(%eax,%ecx,1)
	}

	return 0;
}
     1b1:	00 00                	add    %al,(%eax)
     1b3:	00 1b                	add    %bl,(%ebx)
     1b5:	01 00                	add    %eax,(%eax)
     1b7:	00 02                	add    %al,(%edx)

	return 0;
}

int bin8_set(struct conf_var *var, const char *s)
{
     1b9:	00 74 20 1b          	add    %dh,0x1b(%eax,%eiz,1)
     1bd:	01 00                	add    %eax,(%eax)
     1bf:	00 1c 01             	add    %bl,(%ecx,%eax,1)
	if (var->p == NULL) {
     1c2:	00 00                	add    %al,(%eax)
     1c4:	02 00                	add    (%eax),%al
     1c6:	74 08                	je     1d0 <.debug_loc+0x1d0>
		var->p = malloc(sizeof(unsigned char));
     1c8:	1c 01                	sbb    $0x1,%al
     1ca:	00 00                	add    %al,(%eax)
     1cc:	1d 01 00 00 02       	sbb    $0x2000001,%eax
     1d1:	00 74 04 00          	add    %dh,0x0(%esp,%eax,1)
     1d5:	00 00                	add    %al,(%eax)
	}

	return 0;
}
     1d7:	00 00                	add    %al,(%eax)
     1d9:	00 00                	add    %al,(%eax)
     1db:	00 1d 01 00 00 1e    	add    %bl,0x1e000001
{
	return write_section(stdout, root, NULL);
}

int void_get(struct conf_var *var, char *s)
{
     1e1:	01 00                	add    %eax,(%eax)
     1e3:	00 02                	add    %al,(%edx)
     1e5:	00 74 04 1e          	add    %dh,0x1e(%esp,%eax,1)
	if (var->p == NULL) {
     1e9:	01 00                	add    %eax,(%eax)
     1eb:	00 21                	add    %ah,(%ecx)
     1ed:	01 00                	add    %eax,(%eax)
     1ef:	00 02                	add    %al,(%edx)
     1f1:	00 74 08 21          	add    %dh,0x21(%eax,%ecx,1)
     1f5:	01 00                	add    %eax,(%eax)
     1f7:	00 42 01             	add    %al,0x1(%edx)
     1fa:	00 00                	add    %al,(%eax)
		sprintf(s, "NULL");
		return 0;
     1fc:	02 00                	add    (%eax),%al
     1fe:	74 20                	je     220 <.debug_loc+0x220>
     200:	42                   	inc    %edx
     201:	01 00                	add    %eax,(%eax)
     203:	00 43 01             	add    %al,0x1(%ebx)
     206:	00 00                	add    %al,(%eax)
     208:	02 00                	add    (%eax),%al
     20a:	74 08                	je     214 <.debug_loc+0x214>
     20c:	43                   	inc    %ebx
     20d:	01 00                	add    %eax,(%eax)
     20f:	00 44 01 00          	add    %al,0x0(%ecx,%eax,1)
     213:	00 02                	add    %al,(%edx)
     215:	00 74 04 00          	add    %dh,0x0(%esp,%eax,1)
     219:	00 00                	add    %al,(%eax)
     21b:	00 00                	add    %al,(%eax)
     21d:	00 00                	add    %al,(%eax)
     21f:	00 44 01 00          	add    %al,0x0(%ecx,%eax,1)
	}

	sprintf(s, "%p", var->p);
	return 1;
     223:	00 45 01             	add    %al,0x1(%ebp)
     226:	00 00                	add    %al,(%eax)
}
     228:	02 00                	add    (%eax),%al
     22a:	74 04                	je     230 <.debug_loc+0x230>
	sscanf(s, "%p", &(var->p));
	return 1;
}

int int_get(struct conf_var *var, char *s)
{
     22c:	45                   	inc    %ebp
     22d:	01 00                	add    %eax,(%eax)
     22f:	00 48 01             	add    %cl,0x1(%eax)
	if (var->p == NULL) {
     232:	00 00                	add    %al,(%eax)
     234:	02 00                	add    (%eax),%al
     236:	74 08                	je     240 <.debug_loc+0x240>
     238:	48                   	dec    %eax
     239:	01 00                	add    %eax,(%eax)
     23b:	00 69 01             	add    %ch,0x1(%ecx)
     23e:	00 00                	add    %al,(%eax)
     240:	02 00                	add    (%eax),%al
     242:	74 20                	je     264 <.debug_loc+0x264>
     244:	69 01 00 00 6a 01    	imul   $0x16a0000,(%ecx),%eax
     24a:	00 00                	add    %al,(%eax)
     24c:	02 00                	add    (%eax),%al
     24e:	74 08                	je     258 <.debug_loc+0x258>
     250:	6a 01                	push   $0x1
     252:	00 00                	add    %al,(%eax)
     254:	6b 01 00             	imul   $0x0,(%ecx),%eax
     257:	00 02                	add    %al,(%edx)
     259:	00 74 04 00          	add    %dh,0x0(%esp,%eax,1)
     25d:	00 00                	add    %al,(%eax)
     25f:	00 00                	add    %al,(%eax)
     261:	00 00                	add    %al,(%eax)
     263:	00 6b 01             	add    %ch,0x1(%ebx)
     266:	00 00                	add    %al,(%eax)
     268:	6c                   	insb   (%dx),%es:(%edi)
     269:	01 00                	add    %eax,(%eax)
     26b:	00 02                	add    %al,(%edx)
     26d:	00 74 04 6c          	add    %dh,0x6c(%esp,%eax,1)
		sprintf(s, "NULL");
		return 0;
	}

	sprintf(s, "%i", *(int *) (var->p));
	return 1;
     271:	01 00                	add    %eax,(%eax)
     273:	00 6f 01             	add    %ch,0x1(%edi)
}
     276:	00 00                	add    %al,(%eax)

	return 1;
}

int uint_get(struct conf_var *var, char *s)
{
     278:	02 00                	add    (%eax),%al
     27a:	74 08                	je     284 <.debug_loc+0x284>
     27c:	6f                   	outsl  %ds:(%esi),(%dx)
     27d:	01 00                	add    %eax,(%eax)
	if (var->p == NULL) {
     27f:	00 90 01 00 00 02    	add    %dl,0x2000001(%eax)
     285:	00 74 20 90          	add    %dh,-0x70(%eax,%eiz,1)
     289:	01 00                	add    %eax,(%eax)
     28b:	00 91 01 00 00 02    	add    %dl,0x2000001(%ecx)
     291:	00 74 08 91          	add    %dh,-0x6f(%eax,%ecx,1)
		sprintf(s, "NULL");
		return 0;
     295:	01 00                	add    %eax,(%eax)
     297:	00 92 01 00 00 02    	add    %dl,0x2000001(%edx)
     29d:	00 74 04 00          	add    %dh,0x0(%esp,%eax,1)
     2a1:	00 00                	add    %al,(%eax)
     2a3:	00 00                	add    %al,(%eax)
     2a5:	00 00                	add    %al,(%eax)
     2a7:	00 92 01 00 00 93    	add    %dl,-0x6cffffff(%edx)
     2ad:	01 00                	add    %eax,(%eax)
     2af:	00 02                	add    %al,(%edx)
     2b1:	00 74 04 93          	add    %dh,-0x6d(%esp,%eax,1)
     2b5:	01 00                	add    %eax,(%eax)
     2b7:	00 96 01 00 00 02    	add    %dl,0x2000001(%esi)
	}

	sprintf(s, "%u", *(unsigned int *) (var->p));
	return 1;
     2bd:	00 74 08 96          	add    %dh,-0x6a(%eax,%ecx,1)
}
     2c1:	01 00                	add    %eax,(%eax)
     2c3:	00 b7 01 00 00 02    	add    %dh,0x2000001(%edi)

	return 1;
}

int float_get(struct conf_var *var, char *s)
{
     2c9:	00 74 20 b7          	add    %dh,-0x49(%eax,%eiz,1)
	if (var->p == NULL) {
     2cd:	01 00                	add    %eax,(%eax)
     2cf:	00 b8 01 00 00 02    	add    %bh,0x2000001(%eax)
     2d5:	00 74 08 b8          	add    %dh,-0x48(%eax,%ecx,1)
     2d9:	01 00                	add    %eax,(%eax)
     2db:	00 b9 01 00 00 02    	add    %bh,0x2000001(%ecx)
		sprintf(s, "NULL");
		return 0;
     2e1:	00 74 04 00          	add    %dh,0x0(%esp,%eax,1)
     2e5:	00 00                	add    %al,(%eax)
     2e7:	00 00                	add    %al,(%eax)
     2e9:	00 00                	add    %al,(%eax)
     2eb:	00 b9 01 00 00 ba    	add    %bh,-0x45ffffff(%ecx)
     2f1:	01 00                	add    %eax,(%eax)
     2f3:	00 02                	add    %al,(%edx)
     2f5:	00 74 04 ba          	add    %dh,-0x46(%esp,%eax,1)
     2f9:	01 00                	add    %eax,(%eax)
     2fb:	00 bd 01 00 00 02    	add    %bh,0x2000001(%ebp)
     301:	00 74 08 bd          	add    %dh,-0x43(%eax,%ecx,1)
     305:	01 00                	add    %eax,(%eax)
     307:	00 de                	add    %bl,%dh
	}

	sprintf(s, "%f", *(double *) (var->p));
	return 1;
     309:	01 00                	add    %eax,(%eax)
     30b:	00 02                	add    %al,(%edx)
     30d:	00 74 20 de          	add    %dh,-0x22(%eax,%eiz,1)
}
     311:	01 00                	add    %eax,(%eax)
	sscanf(s, "%lf", (double *) (var->p));
	return 1;
}

int string_get(struct conf_var *var, char *s)
{
     313:	00 df                	add    %bl,%bh
     315:	01 00                	add    %eax,(%eax)
     317:	00 02                	add    %al,(%edx)
	char * cp;			/* source */

	if (var->p == NULL) {
     319:	00 74 08 df          	add    %dh,-0x21(%eax,%ecx,1)
     31d:	01 00                	add    %eax,(%eax)
     31f:	00 e0                	add    %ah,%al
     321:	01 00                	add    %eax,(%eax)
     323:	00 02                	add    %al,(%edx)
     325:	00 74 04 00          	add    %dh,0x0(%esp,%eax,1)
     329:	00 00                	add    %al,(%eax)
     32b:	00 00                	add    %al,(%eax)
     32d:	00 00                	add    %al,(%eax)
		sprintf(s, "NULL");
		return 0;
     32f:	00 e0                	add    %ah,%al
     331:	01 00                	add    %eax,(%eax)
     333:	00 e3                	add    %ah,%bl
     335:	01 00                	add    %eax,(%eax)
     337:	00 02                	add    %al,(%edx)
     339:	00 74 04 e3          	add    %dh,-0x1d(%esp,%eax,1)
     33d:	01 00                	add    %eax,(%eax)
     33f:	00 2a                	add    %ch,(%edx)
     341:	02 00                	add    (%eax),%al
     343:	00 02                	add    %al,(%edx)
     345:	00 74 30 2a          	add    %dh,0x2a(%eax,%esi,1)
     349:	02 00                	add    (%eax),%al
     34b:	00 2b                	add    %ch,(%ebx)
     34d:	02 00                	add    (%eax),%al
     34f:	00 02                	add    %al,(%edx)
     351:	00 74 04 00          	add    %dh,0x0(%esp,%eax,1)
	}

	cp = (char *)(var->p);
	sprintf(s, "\"%s\"", cp);

	return 1;
     355:	00 00                	add    %al,(%eax)
     357:	00 00                	add    %al,(%eax)
}
     359:	00 00                	add    %al,(%eax)
     35b:	00 fe                	add    %bh,%dh

	return 1;
}

int bool_get(struct conf_var *var, char *s)
{
     35d:	01 00                	add    %eax,(%eax)
     35f:	00 27                	add    %ah,(%edi)
	if ((*(int *) (var->p)) == 0)
     361:	02 00                	add    (%eax),%al
     363:	00 06                	add    %al,(%esi)
     365:	00 03                	add    %al,(%ebx)
     367:	00 00                	add    %al,(%eax)	367: R_386_32	.rodata.str1.1
     369:	00 00                	add    %al,(%eax)
     36b:	9f                   	lahf   
     36c:	00 00                	add    %al,(%eax)
     36e:	00 00                	add    %al,(%eax)
     370:	00 00                	add    %al,(%eax)
     372:	00 00                	add    %al,(%eax)
     374:	fe 01                	incb   (%ecx)
     376:	00 00                	add    %al,(%eax)
     378:	27                   	daa    
     379:	02 00                	add    (%eax),%al
     37b:	00 02                	add    %al,(%edx)
     37d:	00 91 04 00 00 00    	add    %dl,0x4(%ecx)
     383:	00 00                	add    %al,(%eax)
		sprintf(s, "False");
	else
		sprintf(s, "True");
	return 1;
}
     385:	00 00                	add    %al,(%eax)
     387:	00 2b                	add    %ch,(%ebx)
     389:	02 00                	add    (%eax),%al

	return 0;
}

int char_get(struct conf_var *var, char *s)
{
     38b:	00 2e                	add    %ch,(%esi)
     38d:	02 00                	add    (%eax),%al
     38f:	00 02                	add    %al,(%edx)
     391:	00 74 04 2e          	add    %dh,0x2e(%esp,%eax,1)
	if (var->p == NULL) {
     395:	02 00                	add    (%eax),%al
     397:	00 77 02             	add    %dh,0x2(%edi)
     39a:	00 00                	add    %al,(%eax)
     39c:	02 00                	add    (%eax),%al
     39e:	74 30                	je     3d0 <.debug_loc+0x3d0>
     3a0:	77 02                	ja     3a4 <.debug_loc+0x3a4>
     3a2:	00 00                	add    %al,(%eax)
     3a4:	78 02                	js     3a8 <.debug_loc+0x3a8>
     3a6:	00 00                	add    %al,(%eax)
		sprintf(s, "NULL");
		return 0;
     3a8:	02 00                	add    (%eax),%al
	}

	//printf("*** %s: var '%s' = '%c'\n", __FUNCTION__, var->name, *(char *)(var->p));

	sprintf(s, "%c", *(char *) (var->p));
     3aa:	74 04                	je     3b0 <.debug_loc+0x3b0>
     3ac:	00 00                	add    %al,(%eax)
     3ae:	00 00                	add    %al,(%eax)
     3b0:	00 00                	add    %al,(%eax)
     3b2:	00 00                	add    %al,(%eax)
     3b4:	49                   	dec    %ecx
     3b5:	02 00                	add    (%eax),%al
     3b7:	00 74 02 00          	add    %dh,0x0(%edx,%eax,1)
     3bb:	00 06                	add    %al,(%esi)
     3bd:	00 03                	add    %al,(%ebx)
     3bf:	03 00                	add    (%eax),%eax	3bf: R_386_32	.rodata.str1.1
     3c1:	00 00                	add    %al,(%eax)
     3c3:	9f                   	lahf   
     3c4:	00 00                	add    %al,(%eax)
     3c6:	00 00                	add    %al,(%eax)
     3c8:	00 00                	add    %al,(%eax)
     3ca:	00 00                	add    %al,(%eax)
     3cc:	49                   	dec    %ecx
     3cd:	02 00                	add    (%eax),%al
     3cf:	00 74 02 00          	add    %dh,0x0(%edx,%eax,1)
	return 1;
     3d3:	00 02                	add    %al,(%edx)
}
     3d5:	00 91 04 00 00 00    	add    %dl,0x4(%ecx)
	sscanf(cp, "%c", (char *) (var->p));
	return 1;
}

int hex8_get(struct conf_var *var, char *s)
{
     3db:	00 00                	add    %al,(%eax)
     3dd:	00 00                	add    %al,(%eax)
     3df:	00 78 02             	add    %bh,0x2(%eax)
	if (var->p == NULL) {
     3e2:	00 00                	add    %al,(%eax)
     3e4:	7b 02                	jnp    3e8 <.debug_loc+0x3e8>
     3e6:	00 00                	add    %al,(%eax)
     3e8:	02 00                	add    (%eax),%al
     3ea:	74 04                	je     3f0 <.debug_loc+0x3f0>
     3ec:	7b 02                	jnp    3f0 <.debug_loc+0x3f0>
     3ee:	00 00                	add    %al,(%eax)
     3f0:	c4 02                	les    (%edx),%eax
     3f2:	00 00                	add    %al,(%eax)
     3f4:	02 00                	add    (%eax),%al
		sprintf(s, "NULL");
		return 0;
     3f6:	74 30                	je     428 <.debug_loc+0x428>
	}

	sprintf(s, "0x%02X", *(unsigned char *) (var->p));
     3f8:	c4 02                	les    (%edx),%eax
     3fa:	00 00                	add    %al,(%eax)
     3fc:	c5 02                	lds    (%edx),%eax
     3fe:	00 00                	add    %al,(%eax)
     400:	02 00                	add    (%eax),%al
     402:	74 04                	je     408 <.debug_loc+0x408>
     404:	00 00                	add    %al,(%eax)
     406:	00 00                	add    %al,(%eax)
     408:	00 00                	add    %al,(%eax)
     40a:	00 00                	add    %al,(%eax)
     40c:	96                   	xchg   %eax,%esi
     40d:	02 00                	add    (%eax),%al
     40f:	00 c1                	add    %al,%cl
     411:	02 00                	add    (%eax),%al
     413:	00 06                	add    %al,(%esi)
     415:	00 03                	add    %al,(%ebx)
     417:	06                   	push   %es	417: R_386_32	.rodata.str1.1
     418:	00 00                	add    %al,(%eax)
     41a:	00 9f 00 00 00 00    	add    %bl,0x0(%edi)
	return 1;
     420:	00 00                	add    %al,(%eax)
     422:	00 00                	add    %al,(%eax)
}
     424:	96                   	xchg   %eax,%esi
     425:	02 00                	add    (%eax),%al
	sscanf(s, "%X", (unsigned int *) (var->p));
	return 1;
}

int hex16_get(struct conf_var *var, char *s)
{
     427:	00 c1                	add    %al,%cl
     429:	02 00                	add    (%eax),%al
     42b:	00 02                	add    %al,(%edx)
     42d:	00 91 04 00 00 00    	add    %dl,0x4(%ecx)
	if (var->p == NULL) {
     433:	00 00                	add    %al,(%eax)
     435:	00 00                	add    %al,(%eax)
     437:	00 c5                	add    %al,%ch
     439:	02 00                	add    (%eax),%al
     43b:	00 c8                	add    %cl,%al
     43d:	02 00                	add    (%eax),%al
     43f:	00 02                	add    %al,(%edx)
     441:	00 74 04 c8          	add    %dh,-0x38(%esp,%eax,1)
     445:	02 00                	add    (%eax),%al
     447:	00 11                	add    %dl,(%ecx)
     449:	03 00                	add    (%eax),%eax
     44b:	00 02                	add    %al,(%edx)
     44d:	00 74 30 11          	add    %dh,0x11(%eax,%esi,1)
     451:	03 00                	add    (%eax),%eax
     453:	00 12                	add    %dl,(%edx)
     455:	03 00                	add    (%eax),%eax
     457:	00 02                	add    %al,(%edx)
     459:	00 74 04 00          	add    %dh,0x0(%esp,%eax,1)
     45d:	00 00                	add    %al,(%eax)
     45f:	00 00                	add    %al,(%eax)
     461:	00 00                	add    %al,(%eax)
     463:	00 e3                	add    %ah,%bl
     465:	02 00                	add    (%eax),%al
     467:	00 0e                	add    %cl,(%esi)
     469:	03 00                	add    (%eax),%eax
		sprintf(s, "NULL");
		return 0;
	}

	sprintf(s, "0x%04X", *(unsigned int *) (var->p));
	return 1;
     46b:	00 06                	add    %al,(%esi)
     46d:	00 03                	add    %al,(%ebx)
     46f:	09 00                	or     %eax,(%eax)	46f: R_386_32	.rodata.str1.1
}
     471:	00 00                	add    %al,(%eax)
     473:	9f                   	lahf   
	sscanf(s, "%X", (unsigned int *) (var->p));
	return 1;
}

int hex32_get(struct conf_var *var, char *s)
{
     474:	00 00                	add    %al,(%eax)
     476:	00 00                	add    %al,(%eax)
     478:	00 00                	add    %al,(%eax)
     47a:	00 00                	add    %al,(%eax)
	if (var->p == NULL) {
     47c:	e3 02                	jecxz  480 <.debug_loc+0x480>
     47e:	00 00                	add    %al,(%eax)
     480:	0e                   	push   %cs
     481:	03 00                	add    (%eax),%eax
     483:	00 02                	add    %al,(%edx)
     485:	00 91 04 00 00 00    	add    %dl,0x4(%ecx)
     48b:	00 00                	add    %al,(%eax)
     48d:	00 00                	add    %al,(%eax)
     48f:	00 12                	add    %dl,(%edx)
		sprintf(s, "NULL");
		return 0;
     491:	03 00                	add    (%eax),%eax
     493:	00 15 03 00 00 02    	add    %dl,0x2000003
     499:	00 74 04 15          	add    %dh,0x15(%esp,%eax,1)
     49d:	03 00                	add    (%eax),%eax
     49f:	00 5c 03 00          	add    %bl,0x0(%ebx,%eax,1)
     4a3:	00 02                	add    %al,(%edx)
     4a5:	00 74 30 5c          	add    %dh,0x5c(%eax,%esi,1)
     4a9:	03 00                	add    (%eax),%eax
     4ab:	00 5d 03             	add    %bl,0x3(%ebp)
     4ae:	00 00                	add    %al,(%eax)
     4b0:	02 00                	add    (%eax),%al
     4b2:	74 04                	je     4b8 <.debug_loc+0x4b8>
     4b4:	00 00                	add    %al,(%eax)
     4b6:	00 00                	add    %al,(%eax)
	}

	sprintf(s, "0x%08X", *(unsigned int *) (var->p));
	return 1;
     4b8:	00 00                	add    %al,(%eax)
     4ba:	00 00                	add    %al,(%eax)
     4bc:	30 03                	xor    %al,(%ebx)
}
     4be:	00 00                	add    %al,(%eax)
     4c0:	53                   	push   %ebx
	sscanf(s, "%X", (unsigned int *) (var->p));
	return 1;
}

int hex64_get(struct conf_var *var, char *s)
{
     4c1:	03 00                	add    (%eax),%eax
     4c3:	00 05 00 91 00 06    	add    %al,0x6009100
	if (var->p == NULL) {
     4c9:	23 08                	and    (%eax),%ecx
     4cb:	00 00                	add    %al,(%eax)
     4cd:	00 00                	add    %al,(%eax)
     4cf:	00 00                	add    %al,(%eax)
     4d1:	00 00                	add    %al,(%eax)
     4d3:	30 03                	xor    %al,(%ebx)
     4d5:	00 00                	add    %al,(%eax)
     4d7:	59                   	pop    %ecx
     4d8:	03 00                	add    (%eax),%eax
     4da:	00 06                	add    %al,(%esi)
     4dc:	00 03                	add    %al,(%ebx)
		sprintf(s, "NULL");
		return 0;
     4de:	0c 00                	or     $0x0,%al	4de: R_386_32	.rodata.str1.1
     4e0:	00 00                	add    %al,(%eax)
     4e2:	9f                   	lahf   
     4e3:	00 00                	add    %al,(%eax)
     4e5:	00 00                	add    %al,(%eax)
     4e7:	00 00                	add    %al,(%eax)
     4e9:	00 00                	add    %al,(%eax)
     4eb:	30 03                	xor    %al,(%ebx)
     4ed:	00 00                	add    %al,(%eax)
     4ef:	59                   	pop    %ecx
     4f0:	03 00                	add    (%eax),%eax
     4f2:	00 02                	add    %al,(%edx)
     4f4:	00 91 04 00 00 00    	add    %dl,0x4(%ecx)
     4fa:	00 00                	add    %al,(%eax)
     4fc:	00 00                	add    %al,(%eax)
     4fe:	00 8b 03 00 00 8e    	add    %cl,-0x71fffffd(%ebx)
     504:	03 00                	add    (%eax),%eax
     506:	00 02                	add    %al,(%edx)
     508:	00 74 04 8e          	add    %dh,-0x72(%esp,%eax,1)
     50c:	03 00                	add    (%eax),%eax
	}

	sprintf(s, "0x%016llX", *(unsigned long long int *) (var->p));

	return 1;
     50e:	00 d8                	add    %bl,%al
     510:	03 00                	add    (%eax),%eax
}
     512:	00 02                	add    %al,(%edx)
     514:	00 74 30 d8          	add    %dh,-0x28(%eax,%esi,1)

	return 1;
}

int bin8_get(struct conf_var *var, char *s)
{
     518:	03 00                	add    (%eax),%eax
     51a:	00 d9                	add    %bl,%cl
	if (var->p == NULL) {
     51c:	03 00                	add    (%eax),%eax
     51e:	00 02                	add    %al,(%edx)
     520:	00 74 04 00          	add    %dh,0x0(%esp,%eax,1)
     524:	00 00                	add    %al,(%eax)
     526:	00 00                	add    %al,(%eax)
     528:	00 00                	add    %al,(%eax)
     52a:	00 a9 03 00 00 d5    	add    %ch,-0x2afffffd(%ecx)
		return 0;
	}
	s = "";

	return 0;
}
     530:	03 00                	add    (%eax),%eax
     532:	00 06                	add    %al,(%esi)
     534:	00 03                	add    %al,(%ebx)

	return 0;
}

int bin16_get(struct conf_var *var, char *s)
{
     536:	11 00                	adc    %eax,(%eax)	536: R_386_32	.rodata.str1.1
     538:	00 00                	add    %al,(%eax)
	if (var->p == NULL) {
     53a:	9f                   	lahf   
     53b:	00 00                	add    %al,(%eax)
     53d:	00 00                	add    %al,(%eax)
     53f:	00 00                	add    %al,(%eax)
     541:	00 00                	add    %al,(%eax)
     543:	a9 03 00 00 d5       	test   $0xd5000003,%eax
     548:	03 00                	add    (%eax),%eax
     54a:	00 02                	add    %al,(%edx)
     54c:	00 91 04 00 00 00    	add    %dl,0x4(%ecx)
		return 0;
	}
	s = "";

	return 0;
}
     552:	00 00                	add    %al,(%eax)

	return 0;
}

int bin32_get(struct conf_var *var, char *s)
{
     554:	00 00                	add    %al,(%eax)
     556:	00 d9                	add    %bl,%cl
	if (var->p == NULL) {
     558:	03 00                	add    (%eax),%eax
     55a:	00 dc                	add    %bl,%ah
     55c:	03 00                	add    (%eax),%eax
     55e:	00 02                	add    %al,(%edx)
     560:	00 74 04 dc          	add    %dh,-0x24(%esp,%eax,1)
     564:	03 00                	add    (%eax),%eax
     566:	00 26                	add    %ah,(%esi)
     568:	04 00                	add    $0x0,%al
     56a:	00 02                	add    %al,(%edx)
		return 0;
	}
	s = "";

	return 0;
}
     56c:	00 74 30 26          	add    %dh,0x26(%eax,%esi,1)
     570:	04 00                	add    $0x0,%al

	return 0;
}

int oct8_get(struct conf_var *var, char *s)
{
     572:	00 27                	add    %ah,(%edi)
     574:	04 00                	add    $0x0,%al
	if (var->p == NULL) {
     576:	00 02                	add    %al,(%edx)
     578:	00 74 04 00          	add    %dh,0x0(%esp,%eax,1)
     57c:	00 00                	add    %al,(%eax)
     57e:	00 00                	add    %al,(%eax)
     580:	00 00                	add    %al,(%eax)
     582:	00 f7                	add    %dh,%bh
     584:	03 00                	add    (%eax),%eax
     586:	00 23                	add    %ah,(%ebx)
     588:	04 00                	add    $0x0,%al
		return 0;
	}
	s = "";

	return 0;
}
     58a:	00 06                	add    %al,(%esi)
     58c:	00 03                	add    %al,(%ebx)
     58e:	14 00                	adc    $0x0,%al	58e: R_386_32	.rodata.str1.1

	return 0;
}

int oct16_get(struct conf_var *var, char *s)
{
     590:	00 00                	add    %al,(%eax)
     592:	9f                   	lahf   
	if (var->p == NULL) {
     593:	00 00                	add    %al,(%eax)
     595:	00 00                	add    %al,(%eax)
     597:	00 00                	add    %al,(%eax)
     599:	00 00                	add    %al,(%eax)
     59b:	f7 03 00 00 23 04    	testl  $0x4230000,(%ebx)
     5a1:	00 00                	add    %al,(%eax)
     5a3:	02 00                	add    (%eax),%al
     5a5:	91                   	xchg   %eax,%ecx
     5a6:	04 00                	add    $0x0,%al
		return 0;
	}
	s = "";

	return 0;
}
     5a8:	00 00                	add    %al,(%eax)
     5aa:	00 00                	add    %al,(%eax)
     5ac:	00 00                	add    %al,(%eax)

	return 0;
}

int oct64_get(struct conf_var *var, char *s)
{
     5ae:	00 27                	add    %ah,(%edi)
     5b0:	04 00                	add    $0x0,%al
	if (var->p == NULL) {
     5b2:	00 2a                	add    %ch,(%edx)
     5b4:	04 00                	add    $0x0,%al
     5b6:	00 02                	add    %al,(%edx)
     5b8:	00 74 04 2a          	add    %dh,0x2a(%esp,%eax,1)
     5bc:	04 00                	add    $0x0,%al
     5be:	00 73 04             	add    %dh,0x4(%ebx)
     5c1:	00 00                	add    %al,(%eax)
     5c3:	02 00                	add    (%eax),%al
		return 0;
	}
	s = "";

	return 0;
}
     5c5:	74 30                	je     5f7 <.debug_loc+0x5f7>
     5c7:	73 04                	jae    5cd <.debug_loc+0x5cd>
     5c9:	00 00                	add    %al,(%eax)

	return 0;
}

int rgb_get(struct conf_var *var, char *s)
{
     5cb:	74 04                	je     5d1 <.debug_loc+0x5d1>
     5cd:	00 00                	add    %al,(%eax)
	if (var->p == NULL) {
     5cf:	02 00                	add    (%eax),%al
     5d1:	74 04                	je     5d7 <.debug_loc+0x5d7>
     5d3:	00 00                	add    %al,(%eax)
     5d5:	00 00                	add    %al,(%eax)
     5d7:	00 00                	add    %al,(%eax)
     5d9:	00 00                	add    %al,(%eax)
     5db:	45                   	inc    %ebp
     5dc:	04 00                	add    $0x0,%al
     5de:	00 70 04             	add    %dh,0x4(%eax)
     5e1:	00 00                	add    %al,(%eax)
		return 0;
	}
	s = "";

	return 0;
}
     5e3:	06                   	push   %es
     5e4:	00 03                	add    %al,(%ebx)
     5e6:	1b 00                	sbb    (%eax),%eax	5e6: R_386_32	.rodata.str1.1
     5e8:	00 00                	add    %al,(%eax)

	return 0;
}

int rgbi_get(struct conf_var *var, char *s)
{
     5ea:	9f                   	lahf   
     5eb:	00 00                	add    %al,(%eax)
	if (var->p == NULL) {
     5ed:	00 00                	add    %al,(%eax)
     5ef:	00 00                	add    %al,(%eax)
     5f1:	00 00                	add    %al,(%eax)
     5f3:	45                   	inc    %ebp
     5f4:	04 00                	add    $0x0,%al
     5f6:	00 70 04             	add    %dh,0x4(%eax)
     5f9:	00 00                	add    %al,(%eax)
     5fb:	02 00                	add    (%eax),%al
     5fd:	91                   	xchg   %eax,%ecx
     5fe:	04 00                	add    $0x0,%al
     600:	00 00                	add    %al,(%eax)
		return 0;
	}
	s = "";

	return 0;
}
     602:	00 00                	add    %al,(%eax)
     604:	00 00                	add    %al,(%eax)
     606:	00 74 04 00          	add    %dh,0x0(%esp,%eax,1)

	return 0;
}

int cymk_get(struct conf_var *var, char *s)
{
     60a:	00 77 04             	add    %dh,0x4(%edi)
	if (var->p == NULL) {
     60d:	00 00                	add    %al,(%eax)
     60f:	02 00                	add    (%eax),%al
     611:	74 04                	je     617 <.debug_loc+0x617>
     613:	77 04                	ja     619 <.debug_loc+0x619>
     615:	00 00                	add    %al,(%eax)
     617:	c0 04 00 00          	rolb   $0x0,(%eax,%eax,1)
     61b:	02 00                	add    (%eax),%al
     61d:	74 30                	je     64f <.debug_loc+0x64f>
		return 0;
	}
	s = "";

	return 0;
}
     61f:	c0 04 00 00          	rolb   $0x0,(%eax,%eax,1)
     623:	c1 04 00 00          	roll   $0x0,(%eax,%eax,1)

	return 0;
}

int ratio_get(struct conf_var *var, char *s)
{
     627:	02 00                	add    (%eax),%al
	if (var->p == NULL) {
     629:	74 04                	je     62f <.debug_loc+0x62f>
     62b:	00 00                	add    %al,(%eax)
     62d:	00 00                	add    %al,(%eax)
     62f:	00 00                	add    %al,(%eax)
     631:	00 00                	add    %al,(%eax)
     633:	92                   	xchg   %eax,%edx
     634:	04 00                	add    $0x0,%al
     636:	00 bd 04 00 00 06    	add    %bh,0x6000004(%ebp)
     63c:	00 03                	add    %al,(%ebx)
		return 0;
	}
	s = "";

	return 0;
}
     63e:	22 00                	and    (%eax),%al	63e: R_386_32	.rodata.str1.1
     640:	00 00                	add    %al,(%eax)
     642:	9f                   	lahf   

	return 1;
}

int hex64_set(struct conf_var *var, const char *s)
{
     643:	00 00                	add    %al,(%eax)
     645:	00 00                	add    %al,(%eax)
     647:	00 00                	add    %al,(%eax)
     649:	00 00                	add    %al,(%eax)
	if (var->p == NULL) {
     64b:	92                   	xchg   %eax,%edx
     64c:	04 00                	add    $0x0,%al
     64e:	00 bd 04 00 00 02    	add    %bh,0x2000004(%ebp)
		var->p = malloc(sizeof(unsigned long long int));
     654:	00 91 04 00 00 00    	add    %dl,0x4(%ecx)
     65a:	00 00                	add    %al,(%eax)
     65c:	00 00                	add    %al,(%eax)
     65e:	00 c1                	add    %al,%cl
	}

	sscanf(s, "%llX", (unsigned long long int *) (var->p));
     660:	04 00                	add    $0x0,%al
     662:	00 c2                	add    %al,%dl
     664:	04 00                	add    $0x0,%al
     666:	00 02                	add    %al,(%edx)
     668:	00 74 04 c2          	add    %dh,-0x3e(%esp,%eax,1)
     66c:	04 00                	add    $0x0,%al
     66e:	00 c5                	add    %al,%ch
     670:	04 00                	add    $0x0,%al
     672:	00 02                	add    %al,(%edx)
     674:	00 74 08 c5          	add    %dh,-0x3b(%eax,%ecx,1)
     678:	04 00                	add    $0x0,%al
     67a:	00 15 05 00 00 02    	add    %dl,0x2000005

	return 1;
}
     680:	00 74 30 15          	add    %dh,0x15(%eax,%esi,1)
     684:	05 00 00 16 05       	add    $0x5160000,%eax
	sprintf(s, "0x%08X", *(unsigned int *) (var->p));
	return 1;
}

int hex32_set(struct conf_var *var, const char *s)
{
     689:	00 00                	add    %al,(%eax)
     68b:	02 00                	add    (%eax),%al
	if (var->p == NULL) {
     68d:	74 08                	je     697 <.debug_loc+0x697>
     68f:	16                   	push   %ss
     690:	05 00 00 17 05       	add    $0x5170000,%eax
		var->p = malloc(sizeof(unsigned int));
     695:	00 00                	add    %al,(%eax)
     697:	02 00                	add    (%eax),%al
     699:	74 04                	je     69f <.debug_loc+0x69f>
     69b:	00 00                	add    %al,(%eax)
     69d:	00 00                	add    %al,(%eax)
     69f:	00 00                	add    %al,(%eax)
     6a1:	00 00                	add    %al,(%eax)
	}

	sscanf(s, "%X", (unsigned int *) (var->p));
     6a3:	e0 04                	loopne 6a9 <.debug_loc+0x6a9>
     6a5:	00 00                	add    %al,(%eax)
     6a7:	12 05 00 00 06 00    	adc    0x60000,%al
     6ad:	03 29                	add    (%ecx),%ebp	6ae: R_386_32	.rodata.str1.1
     6af:	00 00                	add    %al,(%eax)
     6b1:	00 9f 00 00 00 00    	add    %bl,0x0(%edi)
     6b7:	00 00                	add    %al,(%eax)
     6b9:	00 00                	add    %al,(%eax)
     6bb:	e0 04                	loopne 6c1 <.debug_loc+0x6c1>
	return 1;
}
     6bd:	00 00                	add    %al,(%eax)
     6bf:	12 05 00 00 02 00    	adc    0x20000,%al
     6c5:	91                   	xchg   %eax,%ecx
     6c6:	04 00                	add    $0x0,%al
	sprintf(s, "0x%04X", *(unsigned int *) (var->p));
	return 1;
}

int hex16_set(struct conf_var *var, const char *s)
{
     6c8:	00 00                	add    %al,(%eax)
     6ca:	00 00                	add    %al,(%eax)
     6cc:	00 00                	add    %al,(%eax)
     6ce:	00 43 06             	add    %al,0x6(%ebx)
	if (var->p == NULL) {
     6d1:	00 00                	add    %al,(%eax)
     6d3:	44                   	inc    %esp
     6d4:	06                   	push   %es
		var->p = malloc(sizeof(unsigned int));
     6d5:	00 00                	add    %al,(%eax)
     6d7:	02 00                	add    (%eax),%al
     6d9:	74 04                	je     6df <.debug_loc+0x6df>
     6db:	44                   	inc    %esp
     6dc:	06                   	push   %es
     6dd:	00 00                	add    %al,(%eax)
     6df:	47                   	inc    %edi
     6e0:	06                   	push   %es
     6e1:	00 00                	add    %al,(%eax)
     6e3:	02 00                	add    (%eax),%al
	}
	sscanf(s, "%X", (unsigned int *) (var->p));
     6e5:	74 08                	je     6ef <.debug_loc+0x6ef>
     6e7:	47                   	inc    %edi
     6e8:	06                   	push   %es
     6e9:	00 00                	add    %al,(%eax)
     6eb:	83 06 00             	addl   $0x0,(%esi)
     6ee:	00 02                	add    %al,(%edx)
     6f0:	00 74 20 83          	add    %dh,-0x7d(%eax,%eiz,1)
     6f4:	06                   	push   %es
     6f5:	00 00                	add    %al,(%eax)
     6f7:	84 06                	test   %al,(%esi)
     6f9:	00 00                	add    %al,(%eax)
     6fb:	02 00                	add    (%eax),%al
     6fd:	74 08                	je     707 <.debug_loc+0x707>
	return 1;
}
     6ff:	84 06                	test   %al,(%esi)
     701:	00 00                	add    %al,(%eax)
     703:	85 06                	test   %eax,(%esi)
     705:	00 00                	add    %al,(%eax)
     707:	02 00                	add    (%eax),%al
	sprintf(s, "0x%02X", *(unsigned char *) (var->p));
	return 1;
}

int hex8_set(struct conf_var *var, const char *s)
{
     709:	74 04                	je     70f <.debug_loc+0x70f>
     70b:	00 00                	add    %al,(%eax)
     70d:	00 00                	add    %al,(%eax)
     70f:	00 00                	add    %al,(%eax)
	if (var->p == NULL) {
     711:	00 00                	add    %al,(%eax)
     713:	85 06                	test   %eax,(%esi)
     715:	00 00                	add    %al,(%eax)
		var->p = malloc(sizeof(unsigned int));
     717:	86 06                	xchg   %al,(%esi)
     719:	00 00                	add    %al,(%eax)
     71b:	02 00                	add    (%eax),%al
     71d:	74 04                	je     723 <.debug_loc+0x723>
     71f:	86 06                	xchg   %al,(%esi)
     721:	00 00                	add    %al,(%eax)
     723:	89 06                	mov    %eax,(%esi)
     725:	00 00                	add    %al,(%eax)
	}
	sscanf(s, "%X", (unsigned int *) (var->p));
     727:	02 00                	add    (%eax),%al
     729:	74 08                	je     733 <.debug_loc+0x733>
     72b:	89 06                	mov    %eax,(%esi)
     72d:	00 00                	add    %al,(%eax)
     72f:	c5 06                	lds    (%esi),%eax
     731:	00 00                	add    %al,(%eax)
     733:	02 00                	add    (%eax),%al
     735:	74 20                	je     757 <.debug_loc+0x757>
     737:	c5 06                	lds    (%esi),%eax
     739:	00 00                	add    %al,(%eax)
     73b:	c6 06 00             	movb   $0x0,(%esi)
     73e:	00 02                	add    %al,(%edx)
     740:	00 74 08 c6          	add    %dh,-0x3a(%eax,%ecx,1)
	return 1;
}
     744:	06                   	push   %es
     745:	00 00                	add    %al,(%eax)
     747:	c7 06 00 00 02 00    	movl   $0x20000,(%esi)
	sprintf(s, "%f", *(double *) (var->p));
	return 1;
}

int float_set(struct conf_var *var, const char *s)
{
     74d:	74 04                	je     753 <.debug_loc+0x753>
     74f:	00 00                	add    %al,(%eax)
     751:	00 00                	add    %al,(%eax)
	if (var->p == NULL) {
     753:	00 00                	add    %al,(%eax)
     755:	00 00                	add    %al,(%eax)
     757:	c7 06 00 00 c8 06    	movl   $0x6c80000,(%esi)
		var->p = malloc(sizeof(double));
     75d:	00 00                	add    %al,(%eax)
     75f:	02 00                	add    (%eax),%al
     761:	74 04                	je     767 <.debug_loc+0x767>
     763:	c8 06 00 00          	enter  $0x6,$0x0
     767:	cb                   	lret   
	}
	sscanf(s, "%lf", (double *) (var->p));
     768:	06                   	push   %es
     769:	00 00                	add    %al,(%eax)
     76b:	02 00                	add    (%eax),%al
     76d:	74 08                	je     777 <.debug_loc+0x777>
     76f:	cb                   	lret   
     770:	06                   	push   %es
     771:	00 00                	add    %al,(%eax)
     773:	07                   	pop    %es
     774:	07                   	pop    %es
     775:	00 00                	add    %al,(%eax)
     777:	02 00                	add    (%eax),%al
     779:	74 20                	je     79b <.debug_loc+0x79b>
     77b:	07                   	pop    %es
     77c:	07                   	pop    %es
     77d:	00 00                	add    %al,(%eax)
     77f:	08 07                	or     %al,(%edi)
     781:	00 00                	add    %al,(%eax)
	return 1;
}
     783:	02 00                	add    (%eax),%al
     785:	74 08                	je     78f <.debug_loc+0x78f>
     787:	08 07                	or     %al,(%edi)
     789:	00 00                	add    %al,(%eax)
     78b:	09 07                	or     %eax,(%edi)
	sprintf(s, "%p", var->p);
	return 1;
}

int void_set(struct conf_var *var, const char *s)
{
     78d:	00 00                	add    %al,(%eax)
     78f:	02 00                	add    (%eax),%al
	sscanf(s, "%p", &(var->p));
     791:	74 04                	je     797 <.debug_loc+0x797>
     793:	00 00                	add    %al,(%eax)
     795:	00 00                	add    %al,(%eax)
     797:	00 00                	add    %al,(%eax)
     799:	00 00                	add    %al,(%eax)
     79b:	09 07                	or     %eax,(%edi)
     79d:	00 00                	add    %al,(%eax)
     79f:	0a 07                	or     (%edi),%al
     7a1:	00 00                	add    %al,(%eax)
     7a3:	02 00                	add    (%eax),%al
     7a5:	74 04                	je     7ab <.debug_loc+0x7ab>
     7a7:	0a 07                	or     (%edi),%al
     7a9:	00 00                	add    %al,(%eax)
     7ab:	0d 07 00 00 02       	or     $0x2000007,%eax
	return 1;
}
     7b0:	00 74 08 0d          	add    %dh,0xd(%eax,%ecx,1)
     7b4:	07                   	pop    %es
     7b5:	00 00                	add    %al,(%eax)
     7b7:	49                   	dec    %ecx
	sprintf(s, "%c", *(char *) (var->p));
	return 1;
}

int char_set(struct conf_var *var, const char *s)
{
     7b8:	07                   	pop    %es
     7b9:	00 00                	add    %al,(%eax)
     7bb:	02 00                	add    (%eax),%al
     7bd:	74 20                	je     7df <.debug_loc+0x7df>
     7bf:	49                   	dec    %ecx
     7c0:	07                   	pop    %es
	char *cp;			/* source */

	if (var->p == NULL) {
     7c1:	00 00                	add    %al,(%eax)
     7c3:	4a                   	dec    %edx
     7c4:	07                   	pop    %es
     7c5:	00 00                	add    %al,(%eax)
		var->p = malloc(sizeof(char));
     7c7:	02 00                	add    (%eax),%al
     7c9:	74 08                	je     7d3 <.debug_loc+0x7d3>
     7cb:	4a                   	dec    %edx
     7cc:	07                   	pop    %es
     7cd:	00 00                	add    %al,(%eax)
     7cf:	4b                   	dec    %ebx
     7d0:	07                   	pop    %es
     7d1:	00 00                	add    %al,(%eax)
     7d3:	02 00                	add    (%eax),%al
     7d5:	74 04                	je     7db <.debug_loc+0x7db>
	}

	cp = (char *) s;
	LTRIM(cp);
     7d7:	00 00                	add    %al,(%eax)
     7d9:	00 00                	add    %al,(%eax)
     7db:	00 00                	add    %al,(%eax)
     7dd:	00 00                	add    %al,(%eax)
     7df:	4b                   	dec    %ebx
     7e0:	07                   	pop    %es
     7e1:	00 00                	add    %al,(%eax)
     7e3:	4c                   	dec    %esp
     7e4:	07                   	pop    %es
     7e5:	00 00                	add    %al,(%eax)
     7e7:	02 00                	add    (%eax),%al
     7e9:	74 04                	je     7ef <.debug_loc+0x7ef>
     7eb:	4c                   	dec    %esp
     7ec:	07                   	pop    %es
     7ed:	00 00                	add    %al,(%eax)
     7ef:	4f                   	dec    %edi
     7f0:	07                   	pop    %es
     7f1:	00 00                	add    %al,(%eax)
     7f3:	02 00                	add    (%eax),%al
     7f5:	74 08                	je     7ff <.debug_loc+0x7ff>

	//printf("*** %s: var '%s' source='%s'\n", __FUNCTION__, var->name, cp);

	sscanf(cp, "%c", (char *) (var->p));
     7f7:	4f                   	dec    %edi
     7f8:	07                   	pop    %es
     7f9:	00 00                	add    %al,(%eax)
     7fb:	8b 07                	mov    (%edi),%eax
     7fd:	00 00                	add    %al,(%eax)
     7ff:	02 00                	add    (%eax),%al
     801:	74 20                	je     823 <.debug_loc+0x823>
     803:	8b 07                	mov    (%edi),%eax
     805:	00 00                	add    %al,(%eax)
     807:	8c 07                	mov    %es,(%edi)
     809:	00 00                	add    %al,(%eax)
     80b:	02 00                	add    (%eax),%al
     80d:	74 08                	je     817 <.debug_loc+0x817>
	return 1;
}
     80f:	8c 07                	mov    %es,(%edi)
     811:	00 00                	add    %al,(%eax)
     813:	8d 07                	lea    (%edi),%eax
     815:	00 00                	add    %al,(%eax)
     817:	02 00                	add    (%eax),%al
		sprintf(s, "True");
	return 1;
}

int bool_set(struct conf_var *var, const char *s)
{
     819:	74 04                	je     81f <.debug_loc+0x81f>
     81b:	00 00                	add    %al,(%eax)
     81d:	00 00                	add    %al,(%eax)
     81f:	00 00                	add    %al,(%eax)
     821:	00 00                	add    %al,(%eax)
	char *cp;			/* source */

	if (var->p == NULL) {
     823:	8d 07                	lea    (%edi),%eax
     825:	00 00                	add    %al,(%eax)
     827:	90                   	nop
		var->p = malloc(sizeof(int));
     828:	07                   	pop    %es
     829:	00 00                	add    %al,(%eax)
     82b:	02 00                	add    (%eax),%al
     82d:	74 04                	je     833 <.debug_loc+0x833>
     82f:	90                   	nop
     830:	07                   	pop    %es
     831:	00 00                	add    %al,(%eax)
     833:	b7 07                	mov    $0x7,%bh
     835:	00 00                	add    %al,(%eax)
	}

	cp = (char *) s;
	LTRIM(cp);
     837:	02 00                	add    (%eax),%al
     839:	74 20                	je     85b <.debug_loc+0x85b>
     83b:	b7 07                	mov    $0x7,%bh
     83d:	00 00                	add    %al,(%eax)
     83f:	b8 07 00 00 02       	mov    $0x2000007,%eax
     844:	00 74 04 00          	add    %dh,0x0(%esp,%eax,1)
     848:	00 00                	add    %al,(%eax)
     84a:	00 00                	add    %al,(%eax)
     84c:	00 00                	add    %al,(%eax)
     84e:	00 b8 07 00 00 b9    	add    %bh,-0x46fffff9(%eax)
     854:	07                   	pop    %es
     855:	00 00                	add    %al,(%eax)
     857:	02 00                	add    (%eax),%al

	if (!strncasecmp(cp, "TRUE", 4) ||
     859:	74 04                	je     85f <.debug_loc+0x85f>
     85b:	b9 07 00 00 ba       	mov    $0xba000007,%ecx
     860:	07                   	pop    %es
     861:	00 00                	add    %al,(%eax)
     863:	02 00                	add    (%eax),%al
     865:	74 08                	je     86f <.debug_loc+0x86f>
     867:	ba 07 00 00 bd       	mov    $0xbd000007,%edx
     86c:	07                   	pop    %es
     86d:	00 00                	add    %al,(%eax)
     86f:	02 00                	add    (%eax),%al
     871:	74 0c                	je     87f <.debug_loc+0x87f>
     873:	bd 07 00 00 16       	mov    $0x16000007,%ebp
		!strncasecmp(cp, "YES", 3) ||
     878:	08 00                	or     %al,(%eax)
     87a:	00 02                	add    %al,(%edx)
     87c:	00 74 20 16          	add    %dh,0x16(%eax,%eiz,1)
     880:	08 00                	or     %al,(%eax)
     882:	00 17                	add    %dl,(%edi)
     884:	08 00                	or     %al,(%eax)
     886:	00 02                	add    %al,(%edx)
     888:	00 74 0c 17          	add    %dh,0x17(%esp,%ecx,1)
	}

	cp = (char *) s;
	LTRIM(cp);

	if (!strncasecmp(cp, "TRUE", 4) ||
     88c:	08 00                	or     %al,(%eax)
     88e:	00 18                	add    %bl,(%eax)
		!strncasecmp(cp, "YES", 3) ||
		!strncasecmp(cp, "ON", 2) || !strncasecmp(cp, "1", 1)) {
     890:	08 00                	or     %al,(%eax)
     892:	00 02                	add    %al,(%edx)
     894:	00 74 08 18          	add    %dh,0x18(%eax,%ecx,1)
     898:	08 00                	or     %al,(%eax)
     89a:	00 19                	add    %bl,(%ecx)
     89c:	08 00                	or     %al,(%eax)
     89e:	00 02                	add    %al,(%edx)
     8a0:	00 74 04 00          	add    %dh,0x0(%esp,%eax,1)
     8a4:	00 00                	add    %al,(%eax)
     8a6:	00 00                	add    %al,(%eax)

	cp = (char *) s;
	LTRIM(cp);

	if (!strncasecmp(cp, "TRUE", 4) ||
		!strncasecmp(cp, "YES", 3) ||
     8a8:	00 00                	add    %al,(%eax)
     8aa:	00 d6                	add    %dl,%dh
		!strncasecmp(cp, "ON", 2) || !strncasecmp(cp, "1", 1)) {
     8ac:	07                   	pop    %es
     8ad:	00 00                	add    %al,(%eax)
     8af:	f7 07 00 00 02 00    	testl  $0x20000,(%edi)
     8b5:	91                   	xchg   %eax,%ecx
     8b6:	04 f7                	add    $0xf7,%al
     8b8:	07                   	pop    %es
     8b9:	00 00                	add    %al,(%eax)
     8bb:	0d 08 00 00 01       	or     $0x1000008,%eax
     8c0:	00 50 00             	add    %dl,0x0(%eax)
     8c3:	00 00                	add    %al,(%eax)
     8c5:	00 00                	add    %al,(%eax)
     8c7:	00 00                	add    %al,(%eax)

		*((int *) var->p) = 1;
     8c9:	00 d6                	add    %dl,%dh
     8cb:	07                   	pop    %es
     8cc:	00 00                	add    %al,(%eax)
     8ce:	e3 07                	jecxz  8d7 <.debug_loc+0x8d7>
     8d0:	00 00                	add    %al,(%eax)
		return 1;
     8d2:	02 00                	add    (%eax),%al
     8d4:	91                   	xchg   %eax,%ecx
     8d5:	04 e3                	add    $0xe3,%al
     8d7:	07                   	pop    %es
     8d8:	00 00                	add    %al,(%eax)
     8da:	0d 08 00 00 01       	or     $0x1000008,%eax
	}

	if (!strncasecmp(cp, "FALSE", 5) ||
     8df:	00 50 00             	add    %dl,0x0(%eax)
     8e2:	00 00                	add    %al,(%eax)
     8e4:	00 00                	add    %al,(%eax)
     8e6:	00 00                	add    %al,(%eax)
     8e8:	00 19                	add    %bl,(%ecx)
     8ea:	08 00                	or     %al,(%eax)
     8ec:	00 1a                	add    %bl,(%edx)
     8ee:	08 00                	or     %al,(%eax)
     8f0:	00 02                	add    %al,(%edx)
     8f2:	00 74 04 1a          	add    %dh,0x1a(%esp,%eax,1)
     8f6:	08 00                	or     %al,(%eax)
		!strncasecmp(cp, "NO", 2) ||
     8f8:	00 1b                	add    %bl,(%ebx)
     8fa:	08 00                	or     %al,(%eax)
     8fc:	00 02                	add    %al,(%edx)
     8fe:	00 74 08 1b          	add    %dh,0x1b(%eax,%ecx,1)
     902:	08 00                	or     %al,(%eax)
     904:	00 1e                	add    %bl,(%esi)
     906:	08 00                	or     %al,(%eax)
     908:	00 02                	add    %al,(%edx)
     90a:	00 74 0c 1e          	add    %dh,0x1e(%esp,%ecx,1)
     90e:	08 00                	or     %al,(%eax)

		*((int *) var->p) = 1;
		return 1;
	}

	if (!strncasecmp(cp, "FALSE", 5) ||
     910:	00 63 09             	add    %ah,0x9(%ebx)
		!strncasecmp(cp, "NO", 2) ||
		!strncasecmp(cp, "OFF", 3) || !strncasecmp(cp, "0", 1)) {
     913:	00 00                	add    %al,(%eax)
     915:	02 00                	add    (%eax),%al
     917:	74 20                	je     939 <.debug_loc+0x939>
     919:	63 09                	arpl   %cx,(%ecx)
     91b:	00 00                	add    %al,(%eax)
     91d:	64 09 00             	or     %eax,%fs:(%eax)
     920:	00 02                	add    %al,(%edx)
     922:	00 74 0c 64          	add    %dh,0x64(%esp,%ecx,1)
     926:	09 00                	or     %eax,(%eax)
     928:	00 65 09             	add    %ah,0x9(%ebp)
		*((int *) var->p) = 1;
		return 1;
	}

	if (!strncasecmp(cp, "FALSE", 5) ||
		!strncasecmp(cp, "NO", 2) ||
     92b:	00 00                	add    %al,(%eax)
     92d:	02 00                	add    (%eax),%al
		!strncasecmp(cp, "OFF", 3) || !strncasecmp(cp, "0", 1)) {
     92f:	74 08                	je     939 <.debug_loc+0x939>
     931:	65 09 00             	or     %eax,%gs:(%eax)
     934:	00 66 09             	add    %ah,0x9(%esi)
     937:	00 00                	add    %al,(%eax)
     939:	02 00                	add    (%eax),%al
     93b:	74 04                	je     941 <.debug_loc+0x941>
     93d:	00 00                	add    %al,(%eax)
     93f:	00 00                	add    %al,(%eax)
     941:	00 00                	add    %al,(%eax)
     943:	00 00                	add    %al,(%eax)
     945:	37                   	aaa    
     946:	08 00                	or     %al,(%eax)
     948:	00 58 08             	add    %bl,0x8(%eax)

		*((int *) var->p) = 0;
		return 1;
	}

	return 0;
     94b:	00 00                	add    %al,(%eax)
     94d:	02 00                	add    (%eax),%al
		return 1;
	}

	if (!strncasecmp(cp, "FALSE", 5) ||
		!strncasecmp(cp, "NO", 2) ||
		!strncasecmp(cp, "OFF", 3) || !strncasecmp(cp, "0", 1)) {
     94f:	91                   	xchg   %eax,%ecx
     950:	04 58                	add    $0x58,%al

		*((int *) var->p) = 0;
     952:	08 00                	or     %al,(%eax)
     954:	00 64 09 00          	add    %ah,0x0(%ecx,%ecx,1)
     958:	00 01                	add    %al,(%ecx)
     95a:	00 53 00             	add    %dl,0x0(%ebx)
		return 1;
     95d:	00 00                	add    %al,(%eax)
     95f:	00 00                	add    %al,(%eax)
	}

	return 0;
}
     961:	00 00                	add    %al,(%eax)
     963:	00 37                	add    %dh,(%edi)
     965:	08 00                	or     %al,(%eax)

	return 1;
}

int string_set(struct conf_var *var, const char *s)
{
     967:	00 44 08 00          	add    %al,0x0(%eax,%ecx,1)
     96b:	00 02                	add    %al,(%edx)
     96d:	00 91 04 44 08 00    	add    %dl,0x84404(%ecx)
     973:	00 64 09 00          	add    %ah,0x0(%ecx,%ecx,1)
	char *cp;			/* source */
	int len;
	char quote;
	char *ep;

	if ((!s) || (!var))
     977:	00 01                	add    %al,(%ecx)
     979:	00 53 00             	add    %dl,0x0(%ebx)
     97c:	00 00                	add    %al,(%eax)
     97e:	00 00                	add    %al,(%eax)
     980:	00 00                	add    %al,(%eax)
     982:	00 66 09             	add    %ah,0x9(%esi)
		return 0;

	cp = (char *) s;
	LTRIM(cp);
     985:	00 00                	add    %al,(%eax)
     987:	67 09 00             	or     %eax,(%bx,%si)
     98a:	00 02                	add    %al,(%edx)
     98c:	00 74 04 67          	add    %dh,0x67(%esp,%eax,1)
     990:	09 00                	or     %eax,(%eax)
     992:	00 68 09             	add    %ch,0x9(%eax)
     995:	00 00                	add    %al,(%eax)
     997:	02 00                	add    (%eax),%al
     999:	74 08                	je     9a3 <.debug_loc+0x9a3>
     99b:	68 09 00 00 69       	push   $0x69000009
     9a0:	09 00                	or     %eax,(%eax)
     9a2:	00 02                	add    %al,(%edx)
     9a4:	00 74 0c 69          	add    %dh,0x69(%esp,%ecx,1)
     9a8:	09 00                	or     %eax,(%eax)
	if ((*cp == '"') || (*cp == '\'')) {
     9aa:	00 6c 09 00          	add    %ch,0x0(%ecx,%ecx,1)
     9ae:	00 02                	add    %al,(%edx)
     9b0:	00 74 10 6c          	add    %dh,0x6c(%eax,%edx,1)
		quote = *cp;
		cp++;
     9b4:	09 00                	or     %eax,(%eax)
		if ((ep = strchr(cp, quote)) != NULL)
     9b6:	00 56 0a             	add    %dl,0xa(%esi)
     9b9:	00 00                	add    %al,(%eax)
     9bb:	02 00                	add    (%eax),%al
     9bd:	74 20                	je     9df <.debug_loc+0x9df>
     9bf:	56                   	push   %esi
     9c0:	0a 00                	or     (%eax),%al
     9c2:	00 57 0a             	add    %dl,0xa(%edi)
			len = ep - cp;
     9c5:	00 00                	add    %al,(%eax)
     9c7:	02 00                	add    (%eax),%al
	cp = (char *) s;
	LTRIM(cp);
	if ((*cp == '"') || (*cp == '\'')) {
		quote = *cp;
		cp++;
		if ((ep = strchr(cp, quote)) != NULL)
     9c9:	74 10                	je     9db <.debug_loc+0x9db>
     9cb:	57                   	push   %edi

# ifdef __va_arg_pack
__extern_always_inline int
fprintf (FILE *__restrict __stream, __const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
     9cc:	0a 00                	or     (%eax),%al
     9ce:	00 58 0a             	add    %bl,0xa(%eax)
     9d1:	00 00                	add    %al,(%eax)
     9d3:	02 00                	add    (%eax),%al
     9d5:	74 0c                	je     9e3 <.debug_loc+0x9e3>
     9d7:	58                   	pop    %eax
     9d8:	0a 00                	or     (%eax),%al
     9da:	00 59 0a             	add    %bl,0xa(%ecx)
     9dd:	00 00                	add    %al,(%eax)
     9df:	02 00                	add    (%eax),%al
     9e1:	74 08                	je     9eb <.debug_loc+0x9eb>
     9e3:	59                   	pop    %ecx
     9e4:	0a 00                	or     (%eax),%al
     9e6:	00 5a 0a             	add    %bl,0xa(%edx)
     9e9:	00 00                	add    %al,(%eax)
     9eb:	02 00                	add    (%eax),%al
     9ed:	74 04                	je     9f3 <.debug_loc+0x9f3>
     9ef:	00 00                	add    %al,(%eax)
			len = ep - cp;
		else {
#ifdef DEBUG
			fprintf(stderr, "Unterminated string.\n");
#endif
			len = 0;
     9f1:	00 00                	add    %al,(%eax)
     9f3:	00 00                	add    %al,(%eax)
     9f5:	00 00                	add    %al,(%eax)
     9f7:	a9 09 00 00 b5       	test   $0xb5000009,%eax
		}

	} else {
		len = strlen(cp);
     9fc:	09 00                	or     %eax,(%eax)
     9fe:	00 01                	add    %al,(%ecx)
     a00:	00 52 b5             	add    %dl,-0x4b(%edx)
     a03:	09 00                	or     %eax,(%eax)
     a05:	00 f8                	add    %bh,%al
     a07:	09 00                	or     %eax,(%eax)
     a09:	00 01                	add    %al,(%ecx)
     a0b:	00 56 f8             	add    %dl,-0x8(%esi)
	}

	if (var->p == NULL) {
     a0e:	09 00                	or     %eax,(%eax)
     a10:	00 fa                	add    %bh,%dl
     a12:	09 00                	or     %eax,(%eax)
		var->p = malloc(len + 1);
     a14:	00 01                	add    %al,(%ecx)
     a16:	00 52 0d             	add    %dl,0xd(%edx)
     a19:	0a 00                	or     (%eax),%al
     a1b:	00 40 0a             	add    %al,0xa(%eax)
     a1e:	00 00                	add    %al,(%eax)
     a20:	01 00                	add    %eax,(%eax)
	}

	if (var->len > 0)
     a22:	56                   	push   %esi
     a23:	40                   	inc    %eax
     a24:	0a 00                	or     (%eax),%al
     a26:	00 4e 0a             	add    %cl,0xa(%esi)
		len = MIN(len, var->len);
     a29:	00 00                	add    %al,(%eax)
     a2b:	05 00 91 00 06       	add    $0x6009100,%eax

__extern_always_inline char *
__NTH (strncpy (char *__restrict __dest, __const char *__restrict __src,
		size_t __len))
{
  return __builtin___strncpy_chk (__dest, __src, __len, __bos (__dest));
     a30:	23 08                	and    (%eax),%ecx
     a32:	00 00                	add    %al,(%eax)
     a34:	00 00                	add    %al,(%eax)
     a36:	00 00                	add    %al,(%eax)
     a38:	00 00                	add    %al,(%eax)
     a3a:	f1                   	icebp  
     a3b:	09 00                	or     %eax,(%eax)
     a3d:	00 f8                	add    %bh,%al
     a3f:	09 00                	or     %eax,(%eax)

	strncpy((char *) (var->p), cp, len);
	cp = (char *)(var->p);
	cp[len] = '\0';
     a41:	00 02                	add    %al,(%edx)
     a43:	00 30                	add    %dh,(%eax)
     a45:	9f                   	lahf   
     a46:	0b 0a                	or     (%edx),%ecx

	return 1;
     a48:	00 00                	add    %al,(%eax)
     a4a:	0d 0a 00 00 03       	or     $0x300000a,%eax
	int len;
	char quote;
	char *ep;

	if ((!s) || (!var))
		return 0;
     a4f:	00 71 7f             	add    %dh,0x7f(%ecx)
     a52:	9f                   	lahf   
	strncpy((char *) (var->p), cp, len);
	cp = (char *)(var->p);
	cp[len] = '\0';

	return 1;
}
     a53:	0d 0a 00 00 4e       	or     $0x4e00000a,%eax
     a58:	0a 00                	or     (%eax),%al
	sprintf(s, "%u", *(unsigned int *) (var->p));
	return 1;
}

int uint_set(struct conf_var *var, const char *s)
{
     a5a:	00 01                	add    %al,(%ecx)
     a5c:	00 57 00             	add    %dl,0x0(%edi)
     a5f:	00 00                	add    %al,(%eax)
     a61:	00 00                	add    %al,(%eax)
	unsigned int *p;

	if (var->p == NULL) {
     a63:	00 00                	add    %al,(%eax)
     a65:	00 b2 09 00 00 c3    	add    %dh,-0x3cfffff7(%edx)
		var->p = malloc(sizeof(unsigned int));
     a6b:	09 00                	or     %eax,(%eax)
     a6d:	00 02                	add    %al,(%edx)
     a6f:	00 72 00             	add    %dh,0x0(%edx)
     a72:	00 00                	add    %al,(%eax)
     a74:	00 00                	add    %al,(%eax)
     a76:	00 00                	add    %al,(%eax)
	}

	p = (unsigned int *) var->p;
     a78:	00 00                	add    %al,(%eax)

	*p = strtoul(s, NULL, 0);
     a7a:	c4 09                	les    (%ecx),%ecx
     a7c:	00 00                	add    %al,(%eax)
     a7e:	d1 09                	rorl   (%ecx)
     a80:	00 00                	add    %al,(%eax)
     a82:	01 00                	add    %eax,(%eax)
     a84:	50                   	push   %eax
     a85:	00 00                	add    %al,(%eax)
     a87:	00 00                	add    %al,(%eax)
     a89:	00 00                	add    %al,(%eax)
     a8b:	00 00                	add    %al,(%eax)
     a8d:	8f 09                	(bad)  
     a8f:	00 00                	add    %al,(%eax)
     a91:	c3                   	ret    
     a92:	09 00                	or     %eax,(%eax)
     a94:	00 01                	add    %al,(%ecx)
     a96:	00 52 c3             	add    %dl,-0x3d(%edx)

	return 1;
}
     a99:	09 00                	or     %eax,(%eax)
     a9b:	00 f8                	add    %bh,%al
     a9d:	09 00                	or     %eax,(%eax)
     a9f:	00 03                	add    %al,(%ebx)
     aa1:	00 76 7f             	add    %dh,0x7f(%esi)
	sprintf(s, "%i", *(int *) (var->p));
	return 1;
}

int int_set(struct conf_var *var, const char *s)
{
     aa4:	9f                   	lahf   
     aa5:	f8                   	clc    
     aa6:	09 00                	or     %eax,(%eax)
     aa8:	00 06                	add    %al,(%esi)
	int *p;

	if (var->p == NULL) {
     aaa:	0a 00                	or     (%eax),%al
     aac:	00 01                	add    %al,(%ecx)
     aae:	00 52 00             	add    %dl,0x0(%edx)
		var->p = malloc(sizeof(int));
     ab1:	00 00                	add    %al,(%eax)
     ab3:	00 00                	add    %al,(%eax)
     ab5:	00 00                	add    %al,(%eax)
     ab7:	00 5a 0a             	add    %bl,0xa(%edx)
     aba:	00 00                	add    %al,(%eax)
     abc:	5b                   	pop    %ebx
     abd:	0a 00                	or     (%eax),%al
	}

	p = (int *) var->p;
     abf:	00 02                	add    %al,(%edx)
     ac1:	00 74 04 5b          	add    %dh,0x5b(%esp,%eax,1)

	*p = strtol(s, NULL, 0);
     ac5:	0a 00                	or     (%eax),%al
     ac7:	00 5e 0a             	add    %bl,0xa(%esi)
     aca:	00 00                	add    %al,(%eax)
     acc:	02 00                	add    (%eax),%al
     ace:	74 08                	je     ad8 <.debug_loc+0xad8>
     ad0:	5e                   	pop    %esi
     ad1:	0a 00                	or     (%eax),%al
     ad3:	00 a0 0a 00 00 02    	add    %ah,0x200000a(%eax)
     ad9:	00 74 20 a0          	add    %dh,-0x60(%eax,%eiz,1)
     add:	0a 00                	or     (%eax),%al
     adf:	00 a1 0a 00 00 02    	add    %ah,0x200000a(%ecx)

	return 1;
}
     ae5:	00 74 08 a1          	add    %dh,-0x5f(%eax,%ecx,1)
     ae9:	0a 00                	or     (%eax),%al
/*
* Recursive writes a section into a stream
*
*/
static int write_section(FILE * f, struct conf_var *section, char *branch)
{
     aeb:	00 a2 0a 00 00 02    	add    %ah,0x200000a(%edx)
     af1:	00 74 04 00          	add    %dh,0x0(%esp,%eax,1)
     af5:	00 00                	add    %al,(%eax)
     af7:	00 00                	add    %al,(%eax)
     af9:	00 00                	add    %al,(%eax)
     afb:	00 7a 0a             	add    %bh,0xa(%edx)
     afe:	00 00                	add    %al,(%eax)
     b00:	95                   	xchg   %eax,%ebp
     b01:	0a 00                	or     (%eax),%al
     b03:	00 05 00 91 00 06    	add    %al,0x6009100
	struct conf_var *queue[1024];
	int head = 0;
	int tail = 0;

	if (section == NULL)
		return 0;
     b09:	23 08                	and    (%eax),%ecx
     b0b:	95                   	xchg   %eax,%ebp
     b0c:	0a 00                	or     (%eax),%al
     b0e:	00 a1 0a 00 00 01    	add    %ah,0x100000a(%ecx)
	/* define a queue for sections */
	struct conf_var *queue[1024];
	int head = 0;
	int tail = 0;

	if (section == NULL)
     b14:	00 53 00             	add    %dl,0x0(%ebx)
		return 0;

	entry = section;
	while (entry->name != NULL) {
     b17:	00 00                	add    %al,(%eax)
     b19:	00 00                	add    %al,(%eax)
     b1b:	00 00                	add    %al,(%eax)
     b1d:	00 a2 0a 00 00 a3    	add    %ah,-0x5cfffff6(%edx)
     b23:	0a 00                	or     (%eax),%al
     b25:	00 02                	add    %al,(%edx)
     b27:	00 74 04 a3          	add    %dh,-0x5d(%esp,%eax,1)

		if (entry->type == CONF_TYPE(CONF_SECTION)) {
			queue[tail++] = (struct conf_var *) entry;
		} else {
			if (entry->type->t_get(entry, buf)) {
     b2b:	0a 00                	or     (%eax),%al
     b2d:	00 a6 0a 00 00 02    	add    %ah,0x200000a(%esi)
     b33:	00 74 08 a6          	add    %dh,-0x5a(%eax,%ecx,1)
     b37:	0a 00                	or     (%eax),%al
     b39:	00 e8                	add    %ch,%al
     b3b:	0a 00                	or     (%eax),%al
     b3d:	00 02                	add    %al,(%edx)
		return 0;

	entry = section;
	while (entry->name != NULL) {

		if (entry->type == CONF_TYPE(CONF_SECTION)) {
     b3f:	00 74 20 e8          	add    %dh,-0x18(%eax,%eiz,1)
     b43:	0a 00                	or     (%eax),%al
     b45:	00 e9                	add    %ch,%cl
     b47:	0a 00                	or     (%eax),%al
			queue[tail++] = (struct conf_var *) entry;
     b49:	00 02                	add    %al,(%edx)
     b4b:	00 74 08 e9          	add    %dh,-0x17(%eax,%ecx,1)
     b4f:	0a 00                	or     (%eax),%al
     b51:	00 ea                	add    %ch,%dl
		} else {
			if (entry->type->t_get(entry, buf)) {
     b53:	0a 00                	or     (%eax),%al
     b55:	00 02                	add    %al,(%edx)
     b57:	00 74 04 00          	add    %dh,0x0(%esp,%eax,1)
     b5b:	00 00                	add    %al,(%eax)
     b5d:	00 00                	add    %al,(%eax)
     b5f:	00 00                	add    %al,(%eax)
				fprintf(f, "%s = %s\n", entry->name, buf);
     b61:	00 c2                	add    %al,%dl
     b63:	0a 00                	or     (%eax),%al
     b65:	00 dd                	add    %bl,%ch
     b67:	0a 00                	or     (%eax),%al
     b69:	00 05 00 91 00 06    	add    %al,0x6009100
     b6f:	23 08                	and    (%eax),%ecx
     b71:	dd 0a                	fisttpll (%edx)
     b73:	00 00                	add    %al,(%eax)
     b75:	e9 0a 00 00 01       	jmp    1000b84 <ipport_set+0xfff8c1>
     b7a:	00 53 00             	add    %dl,0x0(%ebx)
     b7d:	00 00                	add    %al,(%eax)
     b7f:	00 00                	add    %al,(%eax)
     b81:	00 00                	add    %al,(%eax)
     b83:	00 ea                	add    %ch,%dl
     b85:	0a 00                	or     (%eax),%al
     b87:	00 eb                	add    %ch,%bl
     b89:	0a 00                	or     (%eax),%al
     b8b:	00 02                	add    %al,(%edx)
     b8d:	00 74 04 eb          	add    %dh,-0x15(%esp,%eax,1)
     b91:	0a 00                	or     (%eax),%al
     b93:	00 ec                	add    %ch,%ah
     b95:	0a 00                	or     (%eax),%al
     b97:	00 02                	add    %al,(%edx)
     b99:	00 74 08 ec          	add    %dh,-0x14(%eax,%ecx,1)
     b9d:	0a 00                	or     (%eax),%al
     b9f:	00 ed                	add    %ch,%ch
     ba1:	0a 00                	or     (%eax),%al
     ba3:	00 02                	add    %al,(%edx)
     ba5:	00 74 0c ed          	add    %dh,-0x13(%esp,%ecx,1)
     ba9:	0a 00                	or     (%eax),%al
     bab:	00 ee                	add    %ch,%dh
     bad:	0a 00                	or     (%eax),%al
     baf:	00 02                	add    %al,(%edx)
     bb1:	00 74 10 ee          	add    %dh,-0x12(%eax,%edx,1)
				/* Assuming the above failure means configuration stub. */
				fprintf(f, "%s = %s\n", entry->name, STUB_STRING);
			}
			count++;
		}
		entry++;
     bb5:	0a 00                	or     (%eax),%al
     bb7:	00 f4                	add    %dh,%ah

	if (section == NULL)
		return 0;

	entry = section;
	while (entry->name != NULL) {
     bb9:	0a 00                	or     (%eax),%al
     bbb:	00 02                	add    %al,(%edx)
     bbd:	00 74 14 f4          	add    %dh,-0xc(%esp,%edx,1)
     bc1:	0a 00                	or     (%eax),%al
     bc3:	00 b6 0c 00 00 03    	add    %dh,0x300000c(%esi)
			count++;
		}
		entry++;
	}

	for (head = 0; head < tail; head++) {
     bc9:	00 74 e0 30          	add    %dh,0x30(%eax,%eiz,8)
     bcd:	b6 0c                	mov    $0xc,%dh
     bcf:	00 00                	add    %al,(%eax)
     bd1:	b7 0c                	mov    $0xc,%bh
     bd3:	00 00                	add    %al,(%eax)
     bd5:	02 00                	add    (%eax),%al
     bd7:	74 14                	je     bed <.debug_loc+0xbed>
		entry = queue[head];
     bd9:	b7 0c                	mov    $0xc,%bh
     bdb:	00 00                	add    %al,(%eax)
		if (head != 0)
     bdd:	b8 0c 00 00 02       	mov    $0x200000c,%eax
     be2:	00 74 10 b8          	add    %dh,-0x48(%eax,%edx,1)
     be6:	0c 00                	or     $0x0,%al
     be8:	00 b9 0c 00 00 02    	add    %bh,0x200000c(%ecx)
     bee:	00 74 0c b9          	add    %dh,-0x47(%esp,%ecx,1)
     bf2:	0c 00                	or     $0x0,%al
     bf4:	00 ba 0c 00 00 02    	add    %bh,0x200000c(%edx)
			fprintf(f, "\n");
		if ((branch != NULL) && (*branch != '\0'))
     bfa:	00 74 08 ba          	add    %dh,-0x46(%eax,%ecx,1)
     bfe:	0c 00                	or     $0x0,%al

#ifdef __va_arg_pack
__extern_always_inline int
__NTH (sprintf (char *__restrict __s, __const char *__restrict __fmt, ...))
{
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
     c00:	00 bb 0c 00 00 02    	add    %bh,0x200000c(%ebx)
     c06:	00 74 04 00          	add    %dh,0x0(%esp,%eax,1)
     c0a:	00 00                	add    %al,(%eax)
     c0c:	00 00                	add    %al,(%eax)
     c0e:	00 00                	add    %al,(%eax)
     c10:	00 ea                	add    %ch,%dl
     c12:	0a 00                	or     (%eax),%al
     c14:	00 07                	add    %al,(%edi)
     c16:	0b 00                	or     (%eax),%eax
     c18:	00 01                	add    %al,(%ecx)
     c1a:	00 50 07             	add    %dl,0x7(%eax)
     c1d:	0b 00                	or     (%eax),%eax
     c1f:	00 bb 0c 00 00 03    	add    %bh,0x300000c(%ebx)
     c25:	00 91 c0 4f 00 00    	add    %dl,0x4fc0(%ecx)
#endif

__extern_always_inline char *
__NTH (strcpy (char *__restrict __dest, __const char *__restrict __src))
{
  return __builtin___strcpy_chk (__dest, __src, __bos (__dest));
     c2b:	00 00                	add    %al,(%eax)
     c2d:	00 00                	add    %al,(%eax)
     c2f:	00 00                	add    %al,(%eax)
     c31:	ea 0a 00 00 3f 0b 00 	ljmp   $0xb,$0x3f00000a
     c38:	00 01                	add    %al,(%ecx)
			sprintf(buf, "%s/%s", branch, entry->name);
		else
			strcpy(buf, entry->name);
     c3a:	00 52 00             	add    %dl,0x0(%edx)
     c3d:	00 00                	add    %al,(%eax)
     c3f:	00 00                	add    %al,(%eax)
		fprintf(f, "[%s]\n", buf);
     c41:	00 00                	add    %al,(%eax)
     c43:	00 ea                	add    %ch,%dl

# ifdef __va_arg_pack
__extern_always_inline int
fprintf (FILE *__restrict __stream, __const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
     c45:	0a 00                	or     (%eax),%al
     c47:	00 3f                	add    %bh,(%edi)
     c49:	0b 00                	or     (%eax),%eax
     c4b:	00 01                	add    %al,(%ecx)
     c4d:	00 51 3f             	add    %dl,0x3f(%ecx)
     c50:	0b 00                	or     (%eax),%eax
     c52:	00 80 0c 00 00 03    	add    %al,0x300000c(%eax)
     c58:	00 91 cc 4f 96 0c    	add    %dl,0xc964fcc(%ecx)
     c5e:	00 00                	add    %al,(%eax)
     c60:	ab                   	stos   %eax,%es:(%edi)
		count += write_section(f, (struct conf_var *) entry->p, buf);
     c61:	0c 00                	or     $0x0,%al
     c63:	00 03                	add    %al,(%ebx)
     c65:	00 91 cc 4f 00 00    	add    %dl,0x4fcc(%ecx)
     c6b:	00 00                	add    %al,(%eax)
     c6d:	00 00                	add    %al,(%eax)
     c6f:	00 00                	add    %al,(%eax)
     c71:	07                   	pop    %es
     c72:	0b 00                	or     (%eax),%eax
			count++;
		}
		entry++;
	}

	for (head = 0; head < tail; head++) {
     c74:	00 3f                	add    %bh,(%edi)
     c76:	0b 00                	or     (%eax),%eax
     c78:	00 02                	add    %al,(%edx)
     c7a:	00 30                	add    %dh,(%eax)
     c7c:	9f                   	lahf   
     c7d:	b5 0b                	mov    $0xb,%ch
     c7f:	00 00                	add    %al,(%eax)
		fprintf(f, "[%s]\n", buf);
		count += write_section(f, (struct conf_var *) entry->p, buf);
	}

	return count;
}
     c81:	d9 0b                	(bad)  (%ebx)
     c83:	00 00                	add    %al,(%eax)
     c85:	01 00                	add    %eax,(%eax)
     c87:	57                   	push   %edi
     c88:	d9 0b                	(bad)  (%ebx)
     c8a:	00 00                	add    %al,(%eax)
     c8c:	80 0c 00 00          	orb    $0x0,(%eax,%eax,1)
     c90:	03 00                	add    (%eax),%eax
     c92:	91                   	xchg   %eax,%ecx
     c93:	c4 4f 96             	les    -0x6a(%edi),%ecx
		}
		entry++;
	}

	for (head = 0; head < tail; head++) {
		entry = queue[head];
     c96:	0c 00                	or     $0x0,%al
     c98:	00 a6 0c 00 00 01    	add    %ah,0x100000c(%esi)
     c9e:	00 57 a6             	add    %dl,-0x5a(%edi)
		if (head != 0)
			fprintf(f, "\n");
		if ((branch != NULL) && (*branch != '\0'))
			sprintf(buf, "%s/%s", branch, entry->name);
     ca1:	0c 00                	or     $0x0,%al
     ca3:	00 ab 0c 00 00 03    	add    %ch,0x300000c(%ebx)
     ca9:	00 91 c4 4f 00 00    	add    %dl,0x4fc4(%ecx)
		fprintf(f, "[%s]\n", buf);
		count += write_section(f, (struct conf_var *) entry->p, buf);
	}

	return count;
}
     caf:	00 00                	add    %al,(%eax)
     cb1:	00 00                	add    %al,(%eax)
     cb3:	00 00                	add    %al,(%eax)
     cb5:	17                   	pop    %ss
     cb6:	0b 00                	or     (%eax),%eax
     cb8:	00 3f                	add    %bh,(%edi)
     cba:	0b 00                	or     (%eax),%eax
	/* {CONF_IPPORT, "ip_port", ipport_get, ipport_set} */
	{CONF_IPPORT, "ip_port", string_get, string_set}
};

struct conf_var *var_lookup(struct conf_var *section, const char *name)
{
     cbc:	00 01                	add    %al,(%ecx)
     cbe:	00 52 3f             	add    %dl,0x3f(%edx)
     cc1:	0b 00                	or     (%eax),%eax
     cc3:	00 d9                	add    %bl,%cl
     cc5:	0b 00                	or     (%eax),%eax
     cc7:	00 01                	add    %al,(%ecx)
	struct conf_var *entry;

	if ((name == NULL) || (*name == '\0')) {
     cc9:	00 53 d9             	add    %dl,-0x27(%ebx)
		//      fprintf(stderr, "name invalid\n");
		return NULL;
     ccc:	0b 00                	or     (%eax),%eax
     cce:	00 dd                	add    %bl,%ch
     cd0:	0b 00                	or     (%eax),%eax

struct conf_var *var_lookup(struct conf_var *section, const char *name)
{
	struct conf_var *entry;

	if ((name == NULL) || (*name == '\0')) {
     cd2:	00 01                	add    %al,(%ecx)
     cd4:	00 56 dd             	add    %dl,-0x23(%esi)
		//      fprintf(stderr, "name invalid\n");
		return NULL;
	}

	if ((entry = section) == NULL) {
     cd7:	0b 00                	or     (%eax),%eax
     cd9:	00 f4                	add    %dh,%ah
		//      fprintf(stderr, "section invalid\n");
		return NULL;
	}

	while (entry->name != NULL) {
     cdb:	0b 00                	or     (%eax),%eax
     cdd:	00 0b                	add    %cl,(%ebx)
     cdf:	00 73 00             	add    %dh,0x0(%ebx)
		if (strcmp(entry->name, name) == 0)
     ce2:	32 24 91             	xor    (%ecx,%edx,4),%ah
     ce5:	00 22                	add    %ah,(%edx)
     ce7:	0a 24 18             	or     (%eax,%ebx,1),%ah
     cea:	1c f4                	sbb    $0xf4,%al
     cec:	0b 00                	or     (%eax),%eax
     cee:	00 80 0c 00 00 01    	add    %al,0x100000c(%eax)
			return entry;
		entry++;
     cf4:	00 56 96             	add    %dl,-0x6a(%esi)
	if ((entry = section) == NULL) {
		//      fprintf(stderr, "section invalid\n");
		return NULL;
	}

	while (entry->name != NULL) {
     cf7:	0c 00                	or     $0x0,%al
     cf9:	00 9a 0c 00 00 01    	add    %bl,0x100000c(%edx)
			return entry;
		entry++;
	}

//      fprintf(stderr, "name not found\n");
	return NULL;
     cff:	00 53 9a             	add    %dl,-0x66(%ebx)
{
	struct conf_var *entry;

	if ((name == NULL) || (*name == '\0')) {
		//      fprintf(stderr, "name invalid\n");
		return NULL;
     d02:	0c 00                	or     $0x0,%al
     d04:	00 ab 0c 00 00 03    	add    %ch,0x300000c(%ebx)
	}

	if ((entry = section) == NULL) {
		//      fprintf(stderr, "section invalid\n");
		return NULL;
     d0a:	00 91 dc 4f 00 00    	add    %dl,0x4fdc(%ecx)
		entry++;
	}

//      fprintf(stderr, "name not found\n");
	return NULL;
}
     d10:	00 00                	add    %al,(%eax)
     d12:	00 00                	add    %al,(%eax)
     d14:	00 00                	add    %al,(%eax)

int var_set(struct conf_var *section, const char *name, const char *value)
{
     d16:	07                   	pop    %es
     d17:	0b 00                	or     (%eax),%eax
     d19:	00 d9                	add    %bl,%cl
     d1b:	0b 00                	or     (%eax),%eax
     d1d:	00 02                	add    %al,(%edx)
	struct conf_var *entry;

	entry = var_lookup(section, name);
     d1f:	00 30                	add    %dh,(%eax)
     d21:	9f                   	lahf   
     d22:	d9 0b                	(bad)  (%ebx)
     d24:	00 00                	add    %al,(%eax)
     d26:	e1 0b                	loope  d33 <.debug_loc+0xd33>
     d28:	00 00                	add    %al,(%eax)
     d2a:	01 00                	add    %eax,(%eax)
     d2c:	53                   	push   %ebx
     d2d:	76 0c                	jbe    d3b <.debug_loc+0xd3b>
     d2f:	00 00                	add    %al,(%eax)
     d31:	80 0c 00 00          	orb    $0x0,(%eax,%eax,1)
	if (entry == NULL)
     d35:	01 00                	add    %eax,(%eax)
		return -1;

	/* Assuming NULL set as a stub configuration. */
	if (value == NULL)
		value = STUB_STRING;
     d37:	53                   	push   %ebx
     d38:	96                   	xchg   %eax,%esi
     d39:	0c 00                	or     $0x0,%al
     d3b:	00 ab 0c 00 00 02    	add    %ch,0x200000c(%ebx)
	
	if (entry->type->t_set(entry, value))
     d41:	00 30                	add    %dh,(%eax)
     d43:	9f                   	lahf   
     d44:	00 00                	add    %al,(%eax)
     d46:	00 00                	add    %al,(%eax)
     d48:	00 00                	add    %al,(%eax)
     d4a:	00 00                	add    %al,(%eax)
     d4c:	07                   	pop    %es
		return 0;
     d4d:	0b 00                	or     (%eax),%eax
     d4f:	00 3f                	add    %bh,(%edi)
     d51:	0b 00                	or     (%eax),%eax
     d53:	00 02                	add    %al,(%edx)
{
	struct conf_var *entry;

	entry = var_lookup(section, name);
	if (entry == NULL)
		return -1;
     d55:	00 30                	add    %dh,(%eax)
     d57:	9f                   	lahf   
     d58:	50                   	push   %eax
	
	if (entry->type->t_set(entry, value))
		return 0;

	return -1;
}
     d59:	0b 00                	or     (%eax),%eax
     d5b:	00 52 0b             	add    %dl,0xb(%edx)

int var_get(struct conf_var *section, const char *name, char *value)
{
     d5e:	00 00                	add    %al,(%eax)
     d60:	01 00                	add    %eax,(%eax)
     d62:	55                   	push   %ebp
     d63:	b5 0b                	mov    $0xb,%ch
     d65:	00 00                	add    %al,(%eax)
	struct conf_var *entry;

	if (value == NULL)
     d67:	c9                   	leave  
     d68:	0b 00                	or     (%eax),%eax
		return -1;

	entry = var_lookup(section, name);
     d6a:	00 01                	add    %al,(%ecx)
     d6c:	00 55 c9             	add    %dl,-0x37(%ebp)
     d6f:	0b 00                	or     (%eax),%eax
     d71:	00 80 0c 00 00 03    	add    %al,0x300000c(%eax)
     d77:	00 91 c8 4f 96 0c    	add    %dl,0xc964fc8(%ecx)
     d7d:	00 00                	add    %al,(%eax)
	if (entry == NULL)
     d7f:	ab                   	stos   %eax,%es:(%edi)
     d80:	0c 00                	or     $0x0,%al
		return -1;

	if (entry->type->t_get(entry, value))
     d82:	00 03                	add    %al,(%ebx)
     d84:	00 91 c8 4f 00 00    	add    %dl,0x4fc8(%ecx)
     d8a:	00 00                	add    %al,(%eax)
     d8c:	00 00                	add    %al,(%eax)
     d8e:	00 00                	add    %al,(%eax)
		return 0;
     d90:	60                   	pusha  
     d91:	0b 00                	or     (%eax),%eax
     d93:	00 88 0b 00 00 06    	add    %cl,0x600000b(%eax)
     d99:	00 03                	add    %al,(%ebx)
     d9b:	72 00                	jb     d9d <.debug_loc+0xd9d>	d9b: R_386_32	.rodata.str1.1
     d9d:	00 00                	add    %al,(%eax)
     d9f:	9f                   	lahf   
     da0:	00 00                	add    %al,(%eax)
     da2:	00 00                	add    %al,(%eax)
     da4:	00 00                	add    %al,(%eax)
     da6:	00 00                	add    %al,(%eax)
     da8:	60                   	pusha  
	else {
		strcpy(value, STUB_STRING);
		return 0;
     da9:	0b 00                	or     (%eax),%eax
int var_get(struct conf_var *section, const char *name, char *value)
{
	struct conf_var *entry;

	if (value == NULL)
		return -1;
     dab:	00 88 0b 00 00 03    	add    %cl,0x300000b(%eax)
     db1:	00 91 c0 4f 00 00    	add    %dl,0x4fc0(%ecx)
		strcpy(value, STUB_STRING);
		return 0;
	}

	return -1;
}
     db7:	00 00                	add    %al,(%eax)
     db9:	00 00                	add    %al,(%eax)
     dbb:	00 00                	add    %al,(%eax)
     dbd:	88 0b                	mov    %cl,(%ebx)

int conf_load(const char *path, struct conf_var *root)
{
     dbf:	00 00                	add    %al,(%eax)
     dc1:	b2 0b                	mov    $0xb,%dl
     dc3:	00 00                	add    %al,(%eax)
     dc5:	06                   	push   %es
     dc6:	00 03                	add    %al,(%ebx)
     dc8:	72 00                	jb     dca <.debug_loc+0xdca>	dc8: R_386_32	.rodata.str1.1
     dca:	00 00                	add    %al,(%eax)
     dcc:	9f                   	lahf   
     dcd:	00 00                	add    %al,(%eax)
     dcf:	00 00                	add    %al,(%eax)
     dd1:	00 00                	add    %al,(%eax)
     dd3:	00 00                	add    %al,(%eax)
     dd5:	88 0b                	mov    %cl,(%ebx)
     dd7:	00 00                	add    %al,(%eax)
     dd9:	b2 0b                	mov    $0xb,%dl
     ddb:	00 00                	add    %al,(%eax)
     ddd:	03 00                	add    (%eax),%eax
     ddf:	91                   	xchg   %eax,%ecx
     de0:	c0 4f 00 00          	rorb   $0x0,0x0(%edi)
     de4:	00 00                	add    %al,(%eax)
     de6:	00 00                	add    %al,(%eax)
     de8:	00 00                	add    %al,(%eax)
     dea:	ff 0b                	decl   (%ebx)
     dec:	00 00                	add    %al,(%eax)
			"int load_conf(const char *path, struct conf_var *root)\n"
			"path = %p \"%s\",\nroot = %p\n{\n",
			path, path, root);
	#endif

	if (!(f = fopen(path, "r"))) {
     dee:	2b 0c 00             	sub    (%eax,%eax,1),%ecx
     df1:	00 06                	add    %al,(%esi)
     df3:	00 03                	add    %al,(%ebx)
     df5:	7b 00                	jnp    df7 <.debug_loc+0xdf7>	df5: R_386_32	.rodata.str1.1
     df7:	00 00                	add    %al,(%eax)
     df9:	9f                   	lahf   
     dfa:	00 00                	add    %al,(%eax)
     dfc:	00 00                	add    %al,(%eax)
     dfe:	00 00                	add    %al,(%eax)
     e00:	00 00                	add    %al,(%eax)
     e02:	ff 0b                	decl   (%ebx)
     e04:	00 00                	add    %al,(%eax)
     e06:	2b 0c 00             	sub    (%eax,%eax,1),%ecx
     e09:	00 01                	add    %al,(%ecx)
     e0b:	00 57 00             	add    %dl,0x0(%edi)
     e0e:	00 00                	add    %al,(%eax)
     e10:	00 00                	add    %al,(%eax)
     e12:	00 00                	add    %al,(%eax)
     e14:	00 2b                	add    %ch,(%ebx)
     e16:	0c 00                	or     $0x0,%al
     e18:	00 40 0c             	add    %al,0xc(%eax)
     e1b:	00 00                	add    %al,(%eax)
     e1d:	02 00                	add    (%eax),%al
     e1f:	76 00                	jbe    e21 <.debug_loc+0xe21>
     e21:	00 00                	add    %al,(%eax)
     e23:	00 00                	add    %al,(%eax)
     e25:	00 00                	add    %al,(%eax)
     e27:	00 00                	add    %al,(%eax)
     e29:	2b 0c 00             	sub    (%eax,%eax,1),%ecx
     e2c:	00 41 0c             	add    %al,0xc(%ecx)
     e2f:	00 00                	add    %al,(%eax)
     e31:	01 00                	add    %eax,(%eax)
			"\tif (!(f = fopen(path, \"r\"))) {\n\t\treturn -1;\n\t};\n"
			"\tsection = root;\n\twhile (fgets(buf, 1024, f)) {\n");
	#endif
	
	while (fgets(buf, 1024, f)) {
		line++;
     e33:	57                   	push   %edi
     e34:	00 00                	add    %al,(%eax)
     e36:	00 00                	add    %al,(%eax)
		
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tcp = buf;\t(buf: %p)\n", buf);
		#endif

		LTRIM(cp);
     e38:	00 00                	add    %al,(%eax)
     e3a:	00 00                	add    %al,(%eax)
     e3c:	d9 0b                	(bad)  (%ebx)
     e3e:	00 00                	add    %al,(%eax)
     e40:	f5                   	cmc    
     e41:	0b 00                	or     (%eax),%eax
		line++;
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tline++\t(interaction#: %i)\n", line);
		#endif

		cp = buf;
     e43:	00 06                	add    %al,(%esi)
     e45:	00 03                	add    %al,(%ebx)
		
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tcp = buf;\t(buf: %p)\n", buf);
		#endif

		LTRIM(cp);
     e47:	81 00 00 00 9f 41    	addl   $0x419f0000,(%eax)	e47: R_386_32	.rodata.str1.1
     e4d:	0c 00                	or     $0x0,%al
     e4f:	00 80 0c 00 00 06    	add    %al,0x600000c(%eax)
     e55:	00 03                	add    %al,(%ebx)
     e57:	81 00 00 00 9f 00    	addl   $0x9f0000,(%eax)	e57: R_386_32	.rodata.str1.1
     e5d:	00 00                	add    %al,(%eax)
     e5f:	00 00                	add    %al,(%eax)
     e61:	00 00                	add    %al,(%eax)
		RTRIM(cp);
     e63:	00 d9                	add    %bl,%cl
     e65:	0b 00                	or     (%eax),%eax
     e67:	00 f5                	add    %dh,%ch
     e69:	0b 00                	or     (%eax),%eax
     e6b:	00 03                	add    %al,(%ebx)
     e6d:	00 91 c0 4f 41 0c    	add    %dl,0xc414fc0(%ecx)
     e73:	00 00                	add    %al,(%eax)
     e75:	80 0c 00 00          	orb    $0x0,(%eax,%eax,1)
     e79:	03 00                	add    (%eax),%eax
     e7b:	91                   	xchg   %eax,%ecx
     e7c:	c0 4f 00 00          	rorb   $0x0,0x0(%edi)
     e80:	00 00                	add    %al,(%eax)
     e82:	00 00                	add    %al,(%eax)
     e84:	00 00                	add    %al,(%eax)
     e86:	bb 0c 00 00 bc       	mov    $0xbc00000c,%ebx
     e8b:	0c 00                	or     $0x0,%al
     e8d:	00 02                	add    %al,(%edx)
     e8f:	00 74 04 bc          	add    %dh,-0x44(%esp,%eax,1)
     e93:	0c 00                	or     $0x0,%al
     e95:	00 bd 0c 00 00 02    	add    %bh,0x200000c(%ebp)
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tLTRIM(cp);\n\t\tRTRIM(cp);\t(cp: %p,", cp);
		fprintf(stderr," *cp: %c)\n", *cp);
		#endif

		if ((*cp == '\0') || (*cp == '#') || (*cp == ';') || (*cp == '\n'))
     e9b:	00 74 08 bd          	add    %dh,-0x43(%eax,%ecx,1)
     e9f:	0c 00                	or     $0x0,%al
     ea1:	00 c0                	add    %al,%al
     ea3:	0c 00                	or     $0x0,%al
     ea5:	00 02                	add    %al,(%edx)
     ea7:	00 74 0c c0          	add    %dh,-0x40(%esp,%ecx,1)
     eab:	0c 00                	or     $0x0,%al
     ead:	00 13                	add    %dl,(%ebx)
     eaf:	0d 00 00 02 00       	or     $0x20000,%eax
     eb4:	74 20                	je     ed6 <.debug_loc+0xed6>
     eb6:	13 0d 00 00 14 0d    	adc    0xd140000,%ecx
			continue;

		if (*cp == '[') {
     ebc:	00 00                	add    %al,(%eax)
     ebe:	02 00                	add    (%eax),%al
     ec0:	74 0c                	je     ece <.debug_loc+0xece>
     ec2:	14 0d                	adc    $0xd,%al
     ec4:	00 00                	add    %al,(%eax)

			cp++;
			LTRIM(cp);
     ec6:	15 0d 00 00 02       	adc    $0x200000d,%eax
     ecb:	00 74 08 15          	add    %dh,0x15(%eax,%ecx,1)
     ecf:	0d 00 00 16 0d       	or     $0xd160000,%eax
     ed4:	00 00                	add    %al,(%eax)
     ed6:	02 00                	add    (%eax),%al
     ed8:	74 04                	je     ede <.debug_loc+0xede>
     eda:	00 00                	add    %al,(%eax)
     edc:	00 00                	add    %al,(%eax)
     ede:	00 00                	add    %al,(%eax)
     ee0:	00 00                	add    %al,(%eax)
     ee2:	d6                   	(bad)  
     ee3:	0c 00                	or     $0x0,%al
     ee5:	00 e2                	add    %ah,%dl
     ee7:	0c 00                	or     $0x0,%al
     ee9:	00 02                	add    %al,(%edx)
     eeb:	00 91 00 e2 0c 00    	add    %dl,0xce200(%ecx)

			if ((ep = strchr(cp, ']')) != NULL)
     ef1:	00 00                	add    %al,(%eax)
     ef3:	0d 00 00 01 00       	or     $0x10000,%eax
     ef8:	53                   	push   %ebx
     ef9:	09 0d 00 00 0e 0d    	or     %ecx,0xd0e0000
     eff:	00 00                	add    %al,(%eax)
     f01:	02 00                	add    (%eax),%al
     f03:	91                   	xchg   %eax,%ecx
				*ep = '\0';
     f04:	00 00                	add    %al,(%eax)
     f06:	00 00                	add    %al,(%eax)
			else {
				fprintf(stderr, "%s:%d: parse error.\n", path, line);
				ignore = 1;
				continue;
			}
			RTRIM(cp);
     f08:	00 00                	add    %al,(%eax)
     f0a:	00 00                	add    %al,(%eax)
     f0c:	00 16                	add    %dl,(%esi)
     f0e:	0d 00 00 17 0d       	or     $0xd170000,%eax
     f13:	00 00                	add    %al,(%eax)
     f15:	02 00                	add    (%eax),%al
     f17:	74 04                	je     f1d <.debug_loc+0xf1d>
     f19:	17                   	pop    %ss
     f1a:	0d 00 00 1a 0d       	or     $0xd1a0000,%eax
     f1f:	00 00                	add    %al,(%eax)
     f21:	02 00                	add    (%eax),%al
     f23:	74 08                	je     f2d <.debug_loc+0xf2d>
     f25:	1a 0d 00 00 5c 0d    	sbb    0xd5c0000,%cl
     f2b:	00 00                	add    %al,(%eax)
     f2d:	02 00                	add    (%eax),%al
     f2f:	74 20                	je     f51 <.debug_loc+0xf51>
     f31:	5c                   	pop    %esp
     f32:	0d 00 00 5d 0d       	or     $0xd5d0000,%eax
     f37:	00 00                	add    %al,(%eax)
     f39:	02 00                	add    (%eax),%al
     f3b:	74 08                	je     f45 <.debug_loc+0xf45>
     f3d:	5d                   	pop    %ebp
     f3e:	0d 00 00 5e 0d       	or     $0xd5e0000,%eax
     f43:	00 00                	add    %al,(%eax)
     f45:	02 00                	add    (%eax),%al
     f47:	74 04                	je     f4d <.debug_loc+0xf4d>
     f49:	00 00                	add    %al,(%eax)
     f4b:	00 00                	add    %al,(%eax)
     f4d:	00 00                	add    %al,(%eax)
     f4f:	00 00                	add    %al,(%eax)
     f51:	16                   	push   %ss
     f52:	0d 00 00 40 0d       	or     $0xd400000,%eax
     f57:	00 00                	add    %al,(%eax)
     f59:	02 00                	add    (%eax),%al
     f5b:	91                   	xchg   %eax,%ecx
     f5c:	08 40 0d             	or     %al,0xd(%eax)

			if ((ep = strchr(cp, ']')) != NULL)
				*ep = '\0';
			else {
				fprintf(stderr, "%s:%d: parse error.\n", path, line);
				ignore = 1;
     f5f:	00 00                	add    %al,(%eax)
     f61:	54                   	push   %esp
     f62:	0d 00 00 01 00       	or     $0x10000,%eax
				continue;
     f67:	53                   	push   %ebx
     f68:	54                   	push   %esp
     f69:	0d 00 00 59 0d       	or     $0xd590000,%eax
			}
			RTRIM(cp);
     f6e:	00 00                	add    %al,(%eax)
     f70:	02 00                	add    (%eax),%al
     f72:	91                   	xchg   %eax,%ecx
     f73:	08 00                	or     %al,(%eax)
     f75:	00 00                	add    %al,(%eax)
     f77:	00 00                	add    %al,(%eax)
     f79:	00 00                	add    %al,(%eax)
     f7b:	00 32                	add    %dh,(%edx)
     f7d:	0d 00 00 4c 0d       	or     $0xd4c0000,%eax

			/* search for a valid section entry, in the root section */
			entry = var_lookup(root, cp);
     f82:	00 00                	add    %al,(%eax)
     f84:	01 00                	add    %eax,(%eax)
     f86:	50                   	push   %eax
     f87:	54                   	push   %esp
     f88:	0d 00 00 59 0d       	or     $0xd590000,%eax
     f8d:	00 00                	add    %al,(%eax)
     f8f:	01 00                	add    %eax,(%eax)
     f91:	50                   	push   %eax
			if (entry == NULL) {
     f92:	00 00                	add    %al,(%eax)
     f94:	00 00                	add    %al,(%eax)
     f96:	00 00                	add    %al,(%eax)
     f98:	00 00                	add    %al,(%eax)
     f9a:	5e                   	pop    %esi
     f9b:	0d 00 00 5f 0d       	or     $0xd5f0000,%eax
     fa0:	00 00                	add    %al,(%eax)
     fa2:	02 00                	add    (%eax),%al
     fa4:	74 04                	je     faa <.debug_loc+0xfaa>
     fa6:	5f                   	pop    %edi
     fa7:	0d 00 00 62 0d       	or     $0xd620000,%eax
     fac:	00 00                	add    %al,(%eax)
     fae:	02 00                	add    (%eax),%al
     fb0:	74 08                	je     fba <.debug_loc+0xfba>
     fb2:	62 0d 00 00 bc 0d    	bound  %ecx,0xdbc0000
     fb8:	00 00                	add    %al,(%eax)
     fba:	02 00                	add    (%eax),%al
     fbc:	74 20                	je     fde <.debug_loc+0xfde>
     fbe:	bc 0d 00 00 bd       	mov    $0xbd00000d,%esp
     fc3:	0d 00 00 02 00       	or     $0x20000,%eax
				/* section not found */
				fprintf(stderr, "%s:%d: section unknown '%s'\n",
						path, line, cp);
				ignore = 1;
     fc8:	74 08                	je     fd2 <.debug_loc+0xfd2>
     fca:	bd 0d 00 00 be       	mov    $0xbe00000d,%ebp
				continue;
     fcf:	0d 00 00 02 00       	or     $0x20000,%eax
			}
			if (entry->type != CONF_TYPE(CONF_SECTION)) {
     fd4:	74 04                	je     fda <.debug_loc+0xfda>
     fd6:	00 00                	add    %al,(%eax)
     fd8:	00 00                	add    %al,(%eax)
     fda:	00 00                	add    %al,(%eax)
     fdc:	00 00                	add    %al,(%eax)
     fde:	7e 0d                	jle    fed <.debug_loc+0xfed>
     fe0:	00 00                	add    %al,(%eax)
     fe2:	8e 0d 00 00 01 00    	mov    0x10000,%cs
     fe8:	50                   	push   %eax
     fe9:	b2 0d                	mov    $0xd,%dl
     feb:	00 00                	add    %al,(%eax)
     fed:	b7 0d                	mov    $0xd,%bh
     fef:	00 00                	add    %al,(%eax)
     ff1:	01 00                	add    %eax,(%eax)
     ff3:	50                   	push   %eax
     ff4:	00 00                	add    %al,(%eax)
     ff6:	00 00                	add    %al,(%eax)
     ff8:	00 00                	add    %al,(%eax)
     ffa:	00 00                	add    %al,(%eax)
     ffc:	be 0d 00 00 bf       	mov    $0xbf00000d,%esi
    1001:	0d 00 00 02 00       	or     $0x20000,%eax
    1006:	74 04                	je     100c <.debug_loc+0x100c>
    1008:	bf 0d 00 00 c0       	mov    $0xc000000d,%edi
    100d:	0d 00 00 02 00       	or     $0x20000,%eax
				fprintf(stderr, "%s:%d: not a section '%s'\n", path, line,
						cp);
				ignore = 1;
			}

			section = (struct conf_var *) entry->p;
    1012:	74 08                	je     101c <.debug_loc+0x101c>
    1014:	c0 0d 00 00 c1 0d 00 	rorb   $0x0,0xdc10000
			ignore = 0;
    101b:	00 02                	add    %al,(%edx)
			continue;
    101d:	00 74 0c c1          	add    %dh,-0x3f(%esp,%ecx,1)
    1021:	0d 00 00 c2 0d       	or     $0xdc20000,%eax
		}

		if (ignore)
    1026:	00 00                	add    %al,(%eax)
    1028:	02 00                	add    (%eax),%al
    102a:	74 10                	je     103c <.debug_loc+0x103c>
    102c:	c2 0d 00             	ret    $0xd

		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tfor (ap = cp; (*cp != '\\0') && (*cp != '='); cp++);"
				"\t(*cp: %c, conf.c, 255)", *cp);
		#endif
		for (ap = cp; (*cp != '\0') && (*cp != '='); cp++);
    102f:	00 c8                	add    %cl,%al
    1031:	0d 00 00 02 00       	or     $0x20000,%eax
    1036:	74 14                	je     104c <.debug_loc+0x104c>
    1038:	c8 0d 00 00          	enter  $0xd,$0x0
    103c:	1f                   	pop    %ds
    103d:	12 00                	adc    (%eax),%al
    103f:	00 03                	add    %al,(%ebx)
    1041:	00 74 f0 10          	add    %dh,0x10(%eax,%esi,8)
    1045:	1f                   	pop    %ds
    1046:	12 00                	adc    (%eax),%al
    1048:	00 20                	add    %ah,(%eax)

		#ifdef _CONF_DEBUG
		fprintf(stderr,"\n\t\tif (*cp == '\\0') {...}\t(cp: %p, *cp: %c)",cp,*cp);
		#endif
		if (*cp == '\0') {
    104a:	12 00                	adc    (%eax),%al
    104c:	00 02                	add    %al,(%edx)
    104e:	00 74 14 20          	add    %dh,0x20(%esp,%edx,1)
    1052:	12 00                	adc    (%eax),%al
    1054:	00 21                	add    %ah,(%ecx)
    1056:	12 00                	adc    (%eax),%al
    1058:	00 02                	add    %al,(%edx)
    105a:	00 74 10 21          	add    %dh,0x21(%eax,%edx,1)
    105e:	12 00                	adc    (%eax),%al
    1060:	00 22                	add    %ah,(%edx)
    1062:	12 00                	adc    (%eax),%al
    1064:	00 02                	add    %al,(%edx)
    1066:	00 74 0c 22          	add    %dh,0x22(%esp,%ecx,1)
    106a:	12 00                	adc    (%eax),%al
    106c:	00 23                	add    %ah,(%ebx)
    106e:	12 00                	adc    (%eax),%al
    1070:	00 02                	add    %al,(%edx)
    1072:	00 74 08 23          	add    %dh,0x23(%eax,%ecx,1)
    1076:	12 00                	adc    (%eax),%al
    1078:	00 24 12             	add    %ah,(%edx,%edx,1)
    107b:	00 00                	add    %al,(%eax)
    107d:	02 00                	add    (%eax),%al
			fprintf(stderr, "%s:%d: parse error.\n", path, line);
			continue;
    107f:	74 04                	je     1085 <.debug_loc+0x1085>
    1081:	00 00                	add    %al,(%eax)
    1083:	00 00                	add    %al,(%eax)

		cp--;
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\n\t\tcp--\t(cp: %p)\n\t*cp = '\\0';", cp);
		#endif
		*cp = '\0';
    1085:	00 00                	add    %al,(%eax)
    1087:	00 00                	add    %al,(%eax)
		cp++;
		cp++;
    1089:	05 0e 00 00 11       	add    $0x1100000e,%eax
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\n\t\tcp++;\n\tcp++;\t(cp: %p)\n", cp);
		#endif


		LTRIM(ap);
    108e:	0e                   	push   %cs
    108f:	00 00                	add    %al,(%eax)
    1091:	01 00                	add    %eax,(%eax)
    1093:	50                   	push   %eax
    1094:	11 0e                	adc    %ecx,(%esi)
    1096:	00 00                	add    %al,(%eax)
    1098:	24 12                	and    $0x12,%al
    109a:	00 00                	add    %al,(%eax)
    109c:	03 00                	add    (%eax),%eax
    109e:	91                   	xchg   %eax,%ecx
    109f:	b8 6f 00 00 00       	mov    $0x6f,%eax
    10a4:	00 00                	add    %al,(%eax)
    10a6:	00 00                	add    %al,(%eax)
    10a8:	00 32                	add    %dh,(%edx)
    10aa:	0e                   	push   %cs
    10ab:	00 00                	add    %al,(%eax)
    10ad:	f8                   	clc    
    10ae:	11 00                	adc    %eax,(%eax)
    10b0:	00 03                	add    %al,(%ebx)
    10b2:	00 91 c4 6f 00 00    	add    %dl,0x6fc4(%ecx)
    10b8:	00 00                	add    %al,(%eax)
    10ba:	00 00                	add    %al,(%eax)
    10bc:	00 00                	add    %al,(%eax)
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tLTRIM(ap);\t(ap: %p, *ap: %c)\n", ap, *ap);
		#endif
		strcpy(name, ap);
    10be:	37                   	aaa    
    10bf:	0e                   	push   %cs
    10c0:	00 00                	add    %al,(%eax)
    10c2:	62 0e                	bound  %ecx,(%esi)
    10c4:	00 00                	add    %al,(%eax)
    10c6:	04 00                	add    $0x0,%al
    10c8:	91                   	xchg   %eax,%ecx
    10c9:	dc 6f 9f             	fsubrl -0x61(%edi)
    10cc:	62 0e                	bound  %ecx,(%esi)
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tstrcpy(name, ap);\t(ap[]: %s\n", ap);
		#endif

		RTRIM(cp);
    10ce:	00 00                	add    %al,(%eax)
    10d0:	c6                   	(bad)  
    10d1:	0e                   	push   %cs
    10d2:	00 00                	add    %al,(%eax)
    10d4:	01 00                	add    %eax,(%eax)
    10d6:	52                   	push   %edx
    10d7:	c6                   	(bad)  
    10d8:	0e                   	push   %cs
    10d9:	00 00                	add    %al,(%eax)
    10db:	d0 0e                	rorb   (%esi)
    10dd:	00 00                	add    %al,(%eax)
    10df:	03 00                	add    (%eax),%eax
    10e1:	72 01                	jb     10e4 <.debug_loc+0x10e4>
    10e3:	9f                   	lahf   
    10e4:	d0 0e                	rorb   (%esi)
    10e6:	00 00                	add    %al,(%eax)
    10e8:	f0 0e                	lock push %cs
    10ea:	00 00                	add    %al,(%eax)
    10ec:	03 00                	add    (%eax),%eax
    10ee:	76 01                	jbe    10f1 <.debug_loc+0x10f1>
    10f0:	9f                   	lahf   
    10f1:	f0 0e                	lock push %cs
    10f3:	00 00                	add    %al,(%eax)
    10f5:	22 10                	and    (%eax),%dl
    10f7:	00 00                	add    %al,(%eax)
    10f9:	01 00                	add    %eax,(%eax)
    10fb:	55                   	push   %ebp
    10fc:	22 10                	and    (%eax),%dl
    10fe:	00 00                	add    %al,(%eax)
    1100:	37                   	aaa    
    1101:	10 00                	adc    %al,(%eax)
    1103:	00 01                	add    %al,(%ecx)
    1105:	00 56 37             	add    %dl,0x37(%esi)
    1108:	10 00                	adc    %al,(%eax)
    110a:	00 48 10             	add    %cl,0x10(%eax)
    110d:	00 00                	add    %al,(%eax)
    110f:	01 00                	add    %eax,(%eax)
    1111:	55                   	push   %ebp
    1112:	48                   	dec    %eax
    1113:	10 00                	adc    %al,(%eax)
    1115:	00 4a 10             	add    %cl,0x10(%edx)
		strcpy(value, cp);
    1118:	00 00                	add    %al,(%eax)
    111a:	01 00                	add    %eax,(%eax)
    111c:	56                   	push   %esi
    111d:	4a                   	dec    %edx
    111e:	10 00                	adc    %al,(%eax)
    1120:	00 84 10 00 00 01 00 	add    %al,0x10000(%eax,%edx,1)
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tRTRIM(cp);\n\t\tstrcpy(value, cp);\t(cp[]: %s)\n",cp);
		#endif

		entry = var_lookup(section, name);
    1127:	55                   	push   %ebp
    1128:	84 10                	test   %dl,(%eax)
    112a:	00 00                	add    %al,(%eax)
    112c:	88 10                	mov    %dl,(%eax)
    112e:	00 00                	add    %al,(%eax)
    1130:	03 00                	add    (%eax),%eax
    1132:	75 7f                	jne    11b3 <.debug_loc+0x11b3>
    1134:	9f                   	lahf   
    1135:	88 10                	mov    %dl,(%eax)
    1137:	00 00                	add    %al,(%eax)
    1139:	db 10                	fistl  (%eax)
    113b:	00 00                	add    %al,(%eax)
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tentry = var_lookup(section, name);\n");
		#endif

		if (entry == NULL) {
    113d:	01 00                	add    %eax,(%eax)
    113f:	55                   	push   %ebp
			fprintf(stderr, "%s:%d: symbol unknown '%s'\n", path, line, name);
    1140:	00 00                	add    %al,(%eax)
    1142:	00 00                	add    %al,(%eax)
    1144:	00 00                	add    %al,(%eax)
    1146:	00 00                	add    %al,(%eax)
    1148:	00 0f                	add    %cl,(%edi)
    114a:	00 00                	add    %al,(%eax)
    114c:	0e                   	push   %cs
    114d:	0f 00 00             	sldt   (%eax)
    1150:	01 00                	add    %eax,(%eax)
    1152:	50                   	push   %eax
    1153:	31 0f                	xor    %ecx,(%edi)
    1155:	00 00                	add    %al,(%eax)
    1157:	35 0f 00 00 01       	xor    $0x100000f,%eax
    115c:	00 50 00             	add    %dl,0x0(%eax)
    115f:	00 00                	add    %al,(%eax)
    1161:	00 00                	add    %al,(%eax)
    1163:	00 00                	add    %al,(%eax)
    1165:	00 b2 10 00 00 cc    	add    %dh,-0x33fffff0(%edx)
    116b:	10 00                	adc    %al,(%eax)
    116d:	00 01                	add    %al,(%ecx)
    116f:	00 50 00             	add    %dl,0x0(%eax)
    1172:	00 00                	add    %al,(%eax)
    1174:	00 00                	add    %al,(%eax)
    1176:	00 00                	add    %al,(%eax)
			continue;
    1178:	00 32                	add    %dh,(%edx)
		fprintf(stderr,"(entry: %p, entry->type: %p, entry->type->t_set: %p,"
				" value[]: %s)\n", entry, entry->type, entry->type->t_set, value);
		#endif

		/* set the variable */
		if (entry->type->t_set(entry, value))
    117a:	0e                   	push   %cs
    117b:	00 00                	add    %al,(%eax)
    117d:	f8                   	clc    
    117e:	11 00                	adc    %eax,(%eax)
    1180:	00 03                	add    %al,(%ebx)
    1182:	00 91 b0 6f 00 00    	add    %dl,0x6fb0(%ecx)
    1188:	00 00                	add    %al,(%eax)
    118a:	00 00                	add    %al,(%eax)
    118c:	00 00                	add    %al,(%eax)
    118e:	32 0e                	xor    (%esi),%cl
    1190:	00 00                	add    %al,(%eax)
			count++;
    1192:	15 10 00 00 03       	adc    $0x3000010,%eax
    1197:	00 91 cc 6f 15 10    	add    %dl,0x10156fcc(%ecx)
    119d:	00 00                	add    %al,(%eax)
    119f:	22 10                	and    (%eax),%dl
    11a1:	00 00                	add    %al,(%eax)
    11a3:	01 00                	add    %eax,(%eax)
    11a5:	53                   	push   %ebx
    11a6:	22 10                	and    (%eax),%dl
    11a8:	00 00                	add    %al,(%eax)
    11aa:	f8                   	clc    
    11ab:	11 00                	adc    %eax,(%eax)
    11ad:	00 03                	add    %al,(%ebx)
    11af:	00 91 cc 6f 00 00    	add    %dl,0x6fcc(%ecx)
    11b5:	00 00                	add    %al,(%eax)
    11b7:	00 00                	add    %al,(%eax)
    11b9:	00 00                	add    %al,(%eax)
    11bb:	92                   	xchg   %eax,%edx
    11bc:	0f 00 00             	sldt   (%eax)
    11bf:	a6                   	cmpsb  %es:(%edi),%ds:(%esi)
    11c0:	0f 00 00             	sldt   (%eax)
    11c3:	01 00                	add    %eax,(%eax)
    11c5:	50                   	push   %eax
	return __fgets_chk (__s, __bos (__s), __n, __stream);

      if ((size_t) __n > __bos (__s))
	return __fgets_chk_warn (__s, __bos (__s), __n, __stream);
    }
  return __fgets_alias (__s, __n, __stream);
    11c6:	a6                   	cmpsb  %es:(%edi),%ds:(%esi)
    11c7:	0f 00 00             	sldt   (%eax)
    11ca:	11 10                	adc    %edx,(%eax)
    11cc:	00 00                	add    %al,(%eax)
    11ce:	01 00                	add    %eax,(%eax)
    11d0:	53                   	push   %ebx
    11d1:	3c 11                	cmp    $0x11,%al
    11d3:	00 00                	add    %al,(%eax)
    11d5:	47                   	inc    %edi
	fprintf(stderr,
			"\tif (!(f = fopen(path, \"r\"))) {\n\t\treturn -1;\n\t};\n"
			"\tsection = root;\n\twhile (fgets(buf, 1024, f)) {\n");
	#endif
	
	while (fgets(buf, 1024, f)) {
    11d6:	11 00                	adc    %eax,(%eax)
    11d8:	00 01                	add    %al,(%ecx)
    11da:	00 50 7a             	add    %dl,0x7a(%eax)
    11dd:	11 00                	adc    %eax,(%eax)
    11df:	00 8d 11 00 00 01    	add    %cl,0x1000011(%ebp)
    11e5:	00 50 00             	add    %dl,0x0(%eax)
    11e8:	00 00                	add    %al,(%eax)
			fprintf(stderr, "%s:%d: parse error.\n", path, line);
		#ifdef _CONF_DEBUG
		fprintf(stderr,"\t\tif (entry->type->t_set(entry, value))\n");
		#endif
	}
	fclose(f);
    11ea:	00 00                	add    %al,(%eax)
    11ec:	00 00                	add    %al,(%eax)
    11ee:	00 ed                	add    %ch,%ch
    11f0:	0d 00 00 32 0e       	or     $0xe320000,%eax
    11f5:	00 00                	add    %al,(%eax)

	return count;
    11f7:	02 00                	add    (%eax),%al
			"path = %p \"%s\",\nroot = %p\n{\n",
			path, path, root);
	#endif

	if (!(f = fopen(path, "r"))) {
		return -1;
    11f9:	30 9f 32 0e 00 00    	xor    %bl,0xe32(%edi)
    11ff:	5e                   	pop    %esi
		#endif
	}
	fclose(f);

	return count;
}
    1200:	0f 00 00             	sldt   (%eax)
    1203:	03 00                	add    (%eax),%eax
    1205:	91                   	xchg   %eax,%ecx
    1206:	bc 6f 5e 0f 00       	mov    $0xf5e6f,%esp
    120b:	00 6b 0f             	add    %ch,0xf(%ebx)
    120e:	00 00                	add    %al,(%eax)
    1210:	02 00                	add    (%eax),%al
    1212:	31 9f 6b 0f 00 00    	xor    %ebx,0xf6b(%edi)
    1218:	c7                   	(bad)  
    1219:	0f 00 00             	sldt   (%eax)
    121c:	03 00                	add    (%eax),%eax
    121e:	91                   	xchg   %eax,%ecx
    121f:	bc 6f c7 0f 00       	mov    $0xfc76f,%esp

	return count;
}

int conf_save(const char *path, struct conf_var *root)
{
    1224:	00 d4                	add    %dl,%ah
    1226:	0f 00 00             	sldt   (%eax)
    1229:	02 00                	add    (%eax),%al
    122b:	31 9f d4 0f 00 00    	xor    %ebx,0xfd4(%edi)
	FILE *f;
	int count;

	if (!(f = fopen(path, "w+"))) {
    1231:	0e                   	push   %cs
    1232:	10 00                	adc    %al,(%eax)
    1234:	00 03                	add    %al,(%ebx)
    1236:	00 91 bc 6f 15 10    	add    %dl,0x10156fbc(%ecx)
    123c:	00 00                	add    %al,(%eax)
    123e:	22 10                	and    (%eax),%dl
    1240:	00 00                	add    %al,(%eax)
    1242:	02 00                	add    (%eax),%al
    1244:	30 9f 22 10 00 00    	xor    %bl,0x1022(%edi)
		return -1;
	};

	count = write_section(f, root, NULL);
    124a:	f8                   	clc    
    124b:	11 00                	adc    %eax,(%eax)
    124d:	00 03                	add    %al,(%ebx)
    124f:	00 91 bc 6f f8 11    	add    %dl,0x11f86fbc(%ecx)
    1255:	00 00                	add    %al,(%eax)
    1257:	00 12                	add    %dl,(%edx)

	fclose(f);
    1259:	00 00                	add    %al,(%eax)
    125b:	02 00                	add    (%eax),%al
    125d:	30 9f 00 00 00 00    	xor    %bl,0x0(%edi)
{
	FILE *f;
	int count;

	if (!(f = fopen(path, "w+"))) {
		return -1;
    1263:	00 00                	add    %al,(%eax)
    1265:	00 00                	add    %al,(%eax)
    1267:	37                   	aaa    
	count = write_section(f, root, NULL);

	fclose(f);

	return count;
}
    1268:	0e                   	push   %cs
    1269:	00 00                	add    %al,(%eax)
    126b:	48                   	dec    %eax
    126c:	0e                   	push   %cs
    126d:	00 00                	add    %al,(%eax)
    126f:	04 00                	add    $0x0,%al
    1271:	91                   	xchg   %eax,%ecx
    1272:	dc 6f 9f             	fsubrl -0x61(%edi)
    1275:	48                   	dec    %eax

int conf_dump(struct conf_var *root)
{
    1276:	0e                   	push   %cs
    1277:	00 00                	add    %al,(%eax)
	return write_section(stdout, root, NULL);
    1279:	70 0e                	jo     1289 <.debug_loc+0x1289>
    127b:	00 00                	add    %al,(%eax)
    127d:	01 00                	add    %eax,(%eax)
    127f:	52                   	push   %edx
    1280:	00 00                	add    %al,(%eax)
    1282:	00 00                	add    %al,(%eax)
    1284:	00 00                	add    %al,(%eax)
    1286:	00 00                	add    %al,(%eax)
    1288:	76 0e                	jbe    1298 <.debug_loc+0x1298>
    128a:	00 00                	add    %al,(%eax)
}
    128c:	95                   	xchg   %eax,%ebp
    128d:	0e                   	push   %cs
    128e:	00 00                	add    %al,(%eax)
int ipaddr_get(struct conf_var *var, char *s)
{
	s = "";

	return 0;
}
    1290:	01 00                	add    %eax,(%eax)
    1292:	50                   	push   %eax
    1293:	95                   	xchg   %eax,%ebp
    1294:	0e                   	push   %cs
    1295:	00 00                	add    %al,(%eax)

int ipaddr_set(struct conf_var *var, const char *s)
{
    1297:	9c                   	pushf  
    1298:	0e                   	push   %cs
    1299:	00 00                	add    %al,(%eax)
    129b:	03 00                	add    (%eax),%eax
    129d:	70 01                	jo     12a0 <.debug_loc+0x12a0>
	if (var->p == NULL) {
    129f:	9f                   	lahf   
    12a0:	00 00                	add    %al,(%eax)
    12a2:	00 00                	add    %al,(%eax)
		var->p = malloc(sizeof(unsigned int));
    12a4:	00 00                	add    %al,(%eax)
    12a6:	00 00                	add    %al,(%eax)
    12a8:	c9                   	leave  
    12a9:	0e                   	push   %cs
    12aa:	00 00                	add    %al,(%eax)
    12ac:	d0 0e                	rorb   (%esi)
    12ae:	00 00                	add    %al,(%eax)
    12b0:	03 00                	add    (%eax),%eax
    12b2:	72 01                	jb     12b5 <.debug_loc+0x12b5>
	}

	return 0;
}
    12b4:	9f                   	lahf   
    12b5:	d0 0e                	rorb   (%esi)
    12b7:	00 00                	add    %al,(%eax)
    12b9:	db 0e                	fisttpl (%esi)
    12bb:	00 00                	add    %al,(%eax)
int ipport_get(struct conf_var *var, char *s)
{
	s = "";

	return 0;
}
    12bd:	03 00                	add    (%eax),%eax
    12bf:	76 01                	jbe    12c2 <.debug_loc+0x12c2>
    12c1:	9f                   	lahf   
    12c2:	db 0e                	fisttpl (%esi)

int ipport_set(struct conf_var *var, const char *s)
{
    12c4:	00 00                	add    %al,(%eax)
    12c6:	04 0f                	add    $0xf,%al
    12c8:	00 00                	add    %al,(%eax)
    12ca:	01 00                	add    %eax,(%eax)
	if (var->p == NULL) {
    12cc:	55                   	push   %ebp
    12cd:	00 00                	add    %al,(%eax)
    12cf:	00 00                	add    %al,(%eax)
		var->p = malloc(sizeof(unsigned int));
    12d1:	00 00                	add    %al,(%eax)
    12d3:	00 00                	add    %al,(%eax)
    12d5:	1b 0f                	sbb    (%edi),%ecx
    12d7:	00 00                	add    %al,(%eax)
    12d9:	31 0f                	xor    %ecx,(%edi)
    12db:	00 00                	add    %al,(%eax)
    12dd:	01 00                	add    %eax,(%eax)
    12df:	50                   	push   %eax
	}

	return 0;
}
    12e0:	6b 0f 00             	imul   $0x0,(%edi),%ecx
    12e3:	00 7c 0f 00          	add    %bh,0x0(%edi,%ecx,1)
    12e7:	00 01                	add    %al,(%ecx)
    12e9:	00 50 7c             	add    %dl,0x7c(%eax)
    12ec:	0f 00 00             	sldt   (%eax)
    12ef:	88 0f                	mov    %cl,(%edi)
    12f1:	00 00                	add    %al,(%eax)
    12f3:	03 00                	add    (%eax),%eax
    12f5:	70 01                	jo     12f8 <.debug_loc+0x12f8>
    12f7:	9f                   	lahf   
    12f8:	00 00                	add    %al,(%eax)
    12fa:	00 00                	add    %al,(%eax)
    12fc:	00 00                	add    %al,(%eax)
    12fe:	00 00                	add    %al,(%eax)
    1300:	31 0f                	xor    %ecx,(%edi)
    1302:	00 00                	add    %al,(%eax)
    1304:	6b 0f 00             	imul   $0x0,(%edi),%ecx
    1307:	00 06                	add    %al,(%esi)
    1309:	00 03                	add    %al,(%ebx)
    130b:	89 00                	mov    %eax,(%eax)	130b: R_386_32	.rodata.str1.1
    130d:	00 00                	add    %al,(%eax)
    130f:	9f                   	lahf   
    1310:	00 00                	add    %al,(%eax)
    1312:	00 00                	add    %al,(%eax)
    1314:	00 00                	add    %al,(%eax)
    1316:	00 00                	add    %al,(%eax)
    1318:	96                   	xchg   %eax,%esi
    1319:	0f 00 00             	sldt   (%eax)
    131c:	d4 0f                	aam    $0xf
    131e:	00 00                	add    %al,(%eax)
    1320:	06                   	push   %es
    1321:	00 03                	add    %al,(%ebx)
    1323:	9e                   	sahf   	1323: R_386_32	.rodata.str1.1
    1324:	00 00                	add    %al,(%eax)
    1326:	00 9f 00 00 00 00    	add    %bl,0x0(%edi)
    132c:	00 00                	add    %al,(%eax)
    132e:	00 00                	add    %al,(%eax)
    1330:	dd 0f                	fisttpll (%edi)
    1332:	00 00                	add    %al,(%eax)
    1334:	0e                   	push   %cs
    1335:	10 00                	adc    %al,(%eax)
    1337:	00 06                	add    %al,(%esi)
    1339:	00 03                	add    %al,(%ebx)
    133b:	bb 00 00 00 9f       	mov    $0x9f000000,%ebx	133b: R_386_32	.rodata.str1.1
    1340:	00 00                	add    %al,(%eax)
    1342:	00 00                	add    %al,(%eax)
    1344:	00 00                	add    %al,(%eax)
    1346:	00 00                	add    %al,(%eax)
    1348:	52                   	push   %edx
    1349:	10 00                	adc    %al,(%eax)
    134b:	00 84 10 00 00 06 00 	add    %al,0x60000(%eax,%edx,1)
    1352:	03 89 00 00 00 9f    	add    -0x61000000(%ecx),%ecx	1353: R_386_32	.rodata.str1.1
    1358:	00 00                	add    %al,(%eax)
    135a:	00 00                	add    %al,(%eax)
    135c:	00 00                	add    %al,(%eax)
    135e:	00 00                	add    %al,(%eax)
    1360:	8b 10                	mov    (%eax),%edx
    1362:	00 00                	add    %al,(%eax)
    1364:	91                   	xchg   %eax,%ecx
    1365:	10 00                	adc    %al,(%eax)
    1367:	00 01                	add    %al,(%ecx)
    1369:	00 56 91             	add    %dl,-0x6f(%esi)
    136c:	10 00                	adc    %al,(%eax)
    136e:	00 9e 10 00 00 01    	add    %bl,0x1000010(%esi)
    1374:	00 52 9e             	add    %dl,-0x62(%edx)
    1377:	10 00                	adc    %al,(%eax)
    1379:	00 cc                	add    %cl,%ah
    137b:	10 00                	adc    %al,(%eax)
    137d:	00 01                	add    %al,(%ecx)
    137f:	00 50 00             	add    %dl,0x0(%eax)
    1382:	00 00                	add    %al,(%eax)
    1384:	00 00                	add    %al,(%eax)
    1386:	00 00                	add    %al,(%eax)
    1388:	00 b2 10 00 00 c6    	add    %dh,-0x39fffff0(%edx)
    138e:	11 00                	adc    %eax,(%eax)
    1390:	00 04 00             	add    %al,(%eax,%eax,1)
    1393:	91                   	xchg   %eax,%ecx
    1394:	dc 77 9f             	fdivl  -0x61(%edi)
    1397:	00 00                	add    %al,(%eax)
    1399:	00 00                	add    %al,(%eax)
    139b:	00 00                	add    %al,(%eax)
    139d:	00 00                	add    %al,(%eax)
    139f:	e1 10                	loope  13b1 <.debug_loc+0x13b1>
    13a1:	00 00                	add    %al,(%eax)
    13a3:	06                   	push   %es
    13a4:	11 00                	adc    %eax,(%eax)
    13a6:	00 01                	add    %al,(%ecx)
    13a8:	00 50 06             	add    %dl,0x6(%eax)
    13ab:	11 00                	adc    %eax,(%eax)
    13ad:	00 1d 11 00 00 03    	add    %bl,0x3000011
    13b3:	00 70 01             	add    %dh,0x1(%eax)
    13b6:	9f                   	lahf   
    13b7:	00 00                	add    %al,(%eax)
    13b9:	00 00                	add    %al,(%eax)
    13bb:	00 00                	add    %al,(%eax)
    13bd:	00 00                	add    %al,(%eax)
    13bf:	0a 11                	or     (%ecx),%dl
    13c1:	00 00                	add    %al,(%eax)
    13c3:	c6                   	(bad)  
    13c4:	11 00                	adc    %eax,(%eax)
    13c6:	00 01                	add    %al,(%ecx)
    13c8:	00 55 00             	add    %dl,0x0(%ebp)
    13cb:	00 00                	add    %al,(%eax)
    13cd:	00 00                	add    %al,(%eax)
    13cf:	00 00                	add    %al,(%eax)
    13d1:	00 0a                	add    %cl,(%edx)
    13d3:	11 00                	adc    %eax,(%eax)
    13d5:	00 c6                	add    %al,%dh
    13d7:	11 00                	adc    %eax,(%eax)
    13d9:	00 04 00             	add    %al,(%eax,%eax,1)
    13dc:	91                   	xchg   %eax,%ecx
    13dd:	dc 7b 9f             	fdivrl -0x61(%ebx)
    13e0:	00 00                	add    %al,(%eax)
    13e2:	00 00                	add    %al,(%eax)
    13e4:	00 00                	add    %al,(%eax)
    13e6:	00 00                	add    %al,(%eax)
    13e8:	40                   	inc    %eax
    13e9:	11 00                	adc    %eax,(%eax)
    13eb:	00 7a 11             	add    %bh,0x11(%edx)
    13ee:	00 00                	add    %al,(%eax)
    13f0:	06                   	push   %es
    13f1:	00 03                	add    %al,(%ebx)
    13f3:	d6                   	(bad)  	13f3: R_386_32	.rodata.str1.1
    13f4:	00 00                	add    %al,(%eax)
    13f6:	00 9f 00 00 00 00    	add    %bl,0x0(%edi)
    13fc:	00 00                	add    %al,(%eax)
    13fe:	00 00                	add    %al,(%eax)
    1400:	99                   	cltd   
    1401:	11 00                	adc    %eax,(%eax)
    1403:	00 c6                	add    %al,%dh
    1405:	11 00                	adc    %eax,(%eax)
    1407:	00 06                	add    %al,(%esi)
    1409:	00 03                	add    %al,(%ebx)
    140b:	89 00                	mov    %eax,(%eax)	140b: R_386_32	.rodata.str1.1
    140d:	00 00                	add    %al,(%eax)
    140f:	9f                   	lahf   
    1410:	00 00                	add    %al,(%eax)
    1412:	00 00                	add    %al,(%eax)
    1414:	00 00                	add    %al,(%eax)
    1416:	00 00                	add    %al,(%eax)
    1418:	32 0e                	xor    (%esi),%cl
    141a:	00 00                	add    %al,(%eax)
    141c:	f8                   	clc    
    141d:	11 00                	adc    %eax,(%eax)
    141f:	00 03                	add    %al,(%ebx)
    1421:	00 91 b8 6f 00 00    	add    %dl,0x6fb8(%ecx)
    1427:	00 00                	add    %al,(%eax)
    1429:	00 00                	add    %al,(%eax)
    142b:	00 00                	add    %al,(%eax)
    142d:	32 0e                	xor    (%esi),%cl
    142f:	00 00                	add    %al,(%eax)
    1431:	f8                   	clc    
    1432:	11 00                	adc    %eax,(%eax)
    1434:	00 04 00             	add    %al,(%eax,%eax,1)
    1437:	0a 00                	or     (%eax),%al
    1439:	04 9f                	add    $0x9f,%al
    143b:	00 00                	add    %al,(%eax)
    143d:	00 00                	add    %al,(%eax)
    143f:	00 00                	add    %al,(%eax)
    1441:	00 00                	add    %al,(%eax)
    1443:	32 0e                	xor    (%esi),%cl
    1445:	00 00                	add    %al,(%eax)
    1447:	da 11                	ficoml (%ecx)
    1449:	00 00                	add    %al,(%eax)
    144b:	04 00                	add    $0x0,%al
    144d:	91                   	xchg   %eax,%ecx
    144e:	dc 6f 9f             	fsubrl -0x61(%edi)
    1451:	da 11                	ficoml (%ecx)
    1453:	00 00                	add    %al,(%eax)
    1455:	e1 11                	loope  1468 <.debug_loc+0x1468>
    1457:	00 00                	add    %al,(%eax)
    1459:	01 00                	add    %eax,(%eax)
    145b:	52                   	push   %edx
    145c:	e1 11                	loope  146f <.debug_loc+0x146f>
    145e:	00 00                	add    %al,(%eax)
    1460:	f8                   	clc    
    1461:	11 00                	adc    %eax,(%eax)
    1463:	00 04 00             	add    %al,(%eax,%eax,1)
    1466:	91                   	xchg   %eax,%ecx
    1467:	dc 6f 9f             	fsubrl -0x61(%edi)
    146a:	00 00                	add    %al,(%eax)
    146c:	00 00                	add    %al,(%eax)
    146e:	00 00                	add    %al,(%eax)
    1470:	00 00                	add    %al,(%eax)
    1472:	24 12                	and    $0x12,%al
    1474:	00 00                	add    %al,(%eax)
    1476:	27                   	daa    
    1477:	12 00                	adc    (%eax),%al
    1479:	00 02                	add    %al,(%edx)
    147b:	00 74 04 27          	add    %dh,0x27(%esp,%eax,1)
    147f:	12 00                	adc    (%eax),%al
    1481:	00 75 12             	add    %dh,0x12(%ebp)
    1484:	00 00                	add    %al,(%eax)
    1486:	02 00                	add    (%eax),%al
    1488:	74 20                	je     14aa <.debug_loc+0x14aa>
    148a:	75 12                	jne    149e <.debug_loc+0x149e>
    148c:	00 00                	add    %al,(%eax)
    148e:	76 12                	jbe    14a2 <.debug_loc+0x14a2>
    1490:	00 00                	add    %al,(%eax)
    1492:	02 00                	add    (%eax),%al
    1494:	74 04                	je     149a <.debug_loc+0x149a>
    1496:	00 00                	add    %al,(%eax)
    1498:	00 00                	add    %al,(%eax)
    149a:	00 00                	add    %al,(%eax)
    149c:	00 00                	add    %al,(%eax)
    149e:	45                   	inc    %ebp
    149f:	12 00                	adc    (%eax),%al
    14a1:	00 56 12             	add    %dl,0x12(%esi)
    14a4:	00 00                	add    %al,(%eax)
    14a6:	01 00                	add    %eax,(%eax)
    14a8:	50                   	push   %eax
    14a9:	56                   	push   %esi
    14aa:	12 00                	adc    (%eax),%al
    14ac:	00 6e 12             	add    %ch,0x12(%esi)
    14af:	00 00                	add    %al,(%eax)
    14b1:	01 00                	add    %eax,(%eax)
    14b3:	53                   	push   %ebx
    14b4:	00 00                	add    %al,(%eax)
    14b6:	00 00                	add    %al,(%eax)
    14b8:	00 00                	add    %al,(%eax)
    14ba:	00 00                	add    %al,(%eax)
    14bc:	59                   	pop    %ecx
    14bd:	12 00                	adc    (%eax),%al
    14bf:	00 60 12             	add    %ah,0x12(%eax)
    14c2:	00 00                	add    %al,(%eax)
    14c4:	01 00                	add    %eax,(%eax)
    14c6:	50                   	push   %eax
    14c7:	60                   	pusha  
    14c8:	12 00                	adc    (%eax),%al
    14ca:	00 63 12             	add    %ah,0x12(%ebx)
    14cd:	00 00                	add    %al,(%eax)
    14cf:	01 00                	add    %eax,(%eax)
    14d1:	56                   	push   %esi
    14d2:	00 00                	add    %al,(%eax)
    14d4:	00 00                	add    %al,(%eax)
    14d6:	00 00                	add    %al,(%eax)
    14d8:	00 00                	add    %al,(%eax)
    14da:	76 12                	jbe    14ee <.debug_loc+0x14ee>
    14dc:	00 00                	add    %al,(%eax)
    14de:	79 12                	jns    14f2 <.debug_loc+0x14f2>
    14e0:	00 00                	add    %al,(%eax)
    14e2:	02 00                	add    (%eax),%al
    14e4:	74 04                	je     14ea <.debug_loc+0x14ea>
    14e6:	79 12                	jns    14fa <.debug_loc+0x14fa>
    14e8:	00 00                	add    %al,(%eax)
    14ea:	8f                   	(bad)  
    14eb:	12 00                	adc    (%eax),%al
    14ed:	00 02                	add    %al,(%edx)
    14ef:	00 74 10 8f          	add    %dh,-0x71(%eax,%edx,1)
    14f3:	12 00                	adc    (%eax),%al
    14f5:	00 90 12 00 00 02    	add    %dl,0x2000012(%eax)
    14fb:	00 74 04 00          	add    %dh,0x0(%esp,%eax,1)
    14ff:	00 00                	add    %al,(%eax)
    1501:	00 00                	add    %al,(%eax)
    1503:	00 00                	add    %al,(%eax)
    1505:	00 96 12 00 00 97    	add    %dl,-0x68ffffee(%esi)
    150b:	12 00                	adc    (%eax),%al
    150d:	00 02                	add    %al,(%edx)
    150f:	00 74 04 97          	add    %dh,-0x69(%esp,%eax,1)
    1513:	12 00                	adc    (%eax),%al
    1515:	00 9a 12 00 00 02    	add    %bl,0x2000012(%edx)
    151b:	00 74 08 9a          	add    %dh,-0x66(%eax,%ecx,1)
    151f:	12 00                	adc    (%eax),%al
    1521:	00 bb 12 00 00 02    	add    %bh,0x2000012(%ebx)
    1527:	00 74 20 bb          	add    %dh,-0x45(%eax,%eiz,1)
    152b:	12 00                	adc    (%eax),%al
    152d:	00 bc 12 00 00 02 00 	add    %bh,0x20000(%edx,%edx,1)
    1534:	74 08                	je     153e <.debug_loc+0x153e>
    1536:	bc 12 00 00 bd       	mov    $0xbd000012,%esp
    153b:	12 00                	adc    (%eax),%al
    153d:	00 02                	add    %al,(%edx)
    153f:	00 74 04 00          	add    %dh,0x0(%esp,%eax,1)
    1543:	00 00                	add    %al,(%eax)
    1545:	00 00                	add    %al,(%eax)
    1547:	00 00                	add    %al,(%eax)
    1549:	00 c3                	add    %al,%bl
    154b:	12 00                	adc    (%eax),%al
    154d:	00 c4                	add    %al,%ah
    154f:	12 00                	adc    (%eax),%al
    1551:	00 02                	add    %al,(%edx)
    1553:	00 74 04 c4          	add    %dh,-0x3c(%esp,%eax,1)
    1557:	12 00                	adc    (%eax),%al
    1559:	00 c7                	add    %al,%bh
    155b:	12 00                	adc    (%eax),%al
    155d:	00 02                	add    %al,(%edx)
    155f:	00 74 08 c7          	add    %dh,-0x39(%eax,%ecx,1)
    1563:	12 00                	adc    (%eax),%al
    1565:	00 e8                	add    %ch,%al
    1567:	12 00                	adc    (%eax),%al
    1569:	00 02                	add    %al,(%edx)
    156b:	00 74 20 e8          	add    %dh,-0x18(%eax,%eiz,1)
    156f:	12 00                	adc    (%eax),%al
    1571:	00 e9                	add    %ch,%cl
    1573:	12 00                	adc    (%eax),%al
    1575:	00 02                	add    %al,(%edx)
    1577:	00 74 08 e9          	add    %dh,-0x17(%eax,%ecx,1)
    157b:	12 00                	adc    (%eax),%al
    157d:	00 ea                	add    %ch,%dl
    157f:	12 00                	adc    (%eax),%al
    1581:	00 02                	add    %al,(%edx)
    1583:	00 74 04 00          	add    %dh,0x0(%esp,%eax,1)
    1587:	00 00                	add    %al,(%eax)
    1589:	00 00                	add    %al,(%eax)
    158b:	00 00                	add    %al,(%eax)
    158d:	00                   	.byte 0x0

Disassembly of section .debug_aranges:

00000000 <.debug_aranges>:
int bin64_get(struct conf_var *var, char *s)
{
	s = "";

	return 0;
}
   0:	1c 00                	sbb    $0x0,%al
   2:	00 00                	add    %al,(%eax)
   4:	02 00                	add    (%eax),%al
int oct32_get(struct conf_var *var, char *s)
{
	s = "";

	return 0;
}
   6:	00 00                	add    %al,(%eax)	6: R_386_32	.debug_info
   8:	00 00                	add    %al,(%eax)
   a:	04 00                	add    $0x0,%al

	return 0;
}

int ratio_set(struct conf_var *var, const char *s)
{
   c:	00 00                	add    %al,(%eax)
   e:	00 00                	add    %al,(%eax)
  10:	00 00                	add    %al,(%eax)	10: R_386_32	.text
  12:	00 00                	add    %al,(%eax)
	if (var->p == NULL) {
  14:	ea 12 00 00 00 00 00 	ljmp   $0x0,$0x12
		var->p = malloc(2 * sizeof(int));
  1b:	00 00                	add    %al,(%eax)
  1d:	00 00                	add    %al,(%eax)
  1f:	00                   	.byte 0x0

Disassembly of section .debug_ranges:

00000000 <.debug_ranges>:
int bin64_get(struct conf_var *var, char *s)
{
	s = "";

	return 0;
}
   0:	84 09                	test   %cl,(%ecx)
   2:	00 00                	add    %al,(%eax)
   4:	a9 09 00 00 f1       	test   $0xf1000009,%eax
int oct32_get(struct conf_var *var, char *s)
{
	s = "";

	return 0;
}
   9:	09 00                	or     %eax,(%eax)
   b:	00 f8                	add    %bh,%al

	return 0;
}

int ratio_set(struct conf_var *var, const char *s)
{
   d:	09 00                	or     %eax,(%eax)
   f:	00 00                	add    %al,(%eax)
  11:	00 00                	add    %al,(%eax)
  13:	00 00                	add    %al,(%eax)
	if (var->p == NULL) {
  15:	00 00                	add    %al,(%eax)
  17:	00 ff                	add    %bh,%bh
  19:	0b 00                	or     (%eax),%eax
		var->p = malloc(2 * sizeof(int));
  1b:	00 2b                	add    %ch,(%ebx)
  1d:	0c 00                	or     $0x0,%al
  1f:	00 9f 0c 00 00 ab    	add    %bl,-0x54fffff4(%edi)
  25:	0c 00                	or     $0x0,%al
  27:	00 00                	add    %al,(%eax)
	}

	return 0;
}
  29:	00 00                	add    %al,(%eax)
  2b:	00 00                	add    %al,(%eax)
  2d:	00 00                	add    %al,(%eax)
  2f:	00 07                	add    %al,(%edi)
  31:	0f 00 00             	sldt   (%eax)

	return 0;
}

int cymk_set(struct conf_var *var, const char *s)
{
  34:	31 0f                	xor    %ecx,(%edi)
  36:	00 00                	add    %al,(%eax)
  38:	6b 0f 00             	imul   $0x0,(%edi),%ecx
	if (var->p == NULL) {
  3b:	00 80 0f 00 00 00    	add    %al,0xf(%eax)
		var->p = malloc(sizeof(unsigned int));
  41:	00 00                	add    %al,(%eax)
  43:	00 00                	add    %al,(%eax)
  45:	00 00                	add    %al,(%eax)
  47:	00                   	.byte 0x0

Disassembly of section .debug_line:

00000000 <.debug_line>:
int bin64_get(struct conf_var *var, char *s)
{
	s = "";

	return 0;
}
   0:	ab                   	stos   %eax,%es:(%edi)
   1:	06                   	push   %es
   2:	00 00                	add    %al,(%eax)
   4:	02 00                	add    (%eax),%al
int oct32_get(struct conf_var *var, char *s)
{
	s = "";

	return 0;
}
   6:	d9 00                	flds   (%eax)
   8:	00 00                	add    %al,(%eax)
   a:	01 01                	add    %eax,(%ecx)

	return 0;
}

int ratio_set(struct conf_var *var, const char *s)
{
   c:	fb                   	sti    
   d:	0e                   	push   %cs
   e:	0d 00 01 01 01       	or     $0x1010100,%eax
  13:	01 00                	add    %eax,(%eax)
	if (var->p == NULL) {
  15:	00 00                	add    %al,(%eax)
  17:	01 00                	add    %eax,(%eax)
  19:	00 01                	add    %al,(%ecx)
		var->p = malloc(2 * sizeof(int));
  1b:	2f                   	das    
  1c:	75 73                	jne    91 <.debug_line+0x91>
  1e:	72 2f                	jb     4f <.debug_line+0x4f>
  20:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%esi),%ebp
  27:	2f                   	das    
  28:	69 33 38 36 2d 6c    	imul   $0x6c2d3638,(%ebx),%esi
	}

	return 0;
}
  2e:	69 6e 75 78 2d 67 6e 	imul   $0x6e672d78,0x75(%esi),%ebp

	return 0;
}

int cymk_set(struct conf_var *var, const char *s)
{
  35:	75 2f                	jne    66 <.debug_line+0x66>
  37:	62 69 74             	bound  %ebp,0x74(%ecx)
  3a:	73 00                	jae    3c <.debug_line+0x3c>
	if (var->p == NULL) {
  3c:	2f                   	das    
  3d:	75 73                	jne    b2 <.debug_line+0xb2>
  3f:	72 2f                	jb     70 <.debug_line+0x70>
		var->p = malloc(sizeof(unsigned int));
  41:	6c                   	insb   (%dx),%es:(%edi)
  42:	69 62 2f 67 63 63 2f 	imul   $0x2f636367,0x2f(%edx),%esp
  49:	69 36 38 36 2d 6c    	imul   $0x6c2d3638,(%esi),%esi
  4f:	69 6e 75 78 2d 67 6e 	imul   $0x6e672d78,0x75(%esi),%ebp
	}

	return 0;
}
  56:	75 2f                	jne    87 <.debug_line+0x87>
  58:	34 2e                	xor    $0x2e,%al

	return 0;
}

int rgbi_set(struct conf_var *var, const char *s)
{
  5a:	36                   	ss
  5b:	2f                   	das    
  5c:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%esi),%ebp
	if (var->p == NULL) {
  63:	00 2f                	add    %ch,(%edi)
  65:	75 73                	jne    da <.debug_line+0xda>
  67:	72 2f                	jb     98 <.debug_line+0x98>
		var->p = malloc(sizeof(unsigned int));
  69:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%esi),%ebp
  70:	00 2e                	add    %ch,(%esi)
  72:	2e                   	cs
  73:	2f                   	das    
  74:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%esi),%ebp
	}

	return 0;
}
  7b:	00 00                	add    %al,(%eax)
  7d:	63 6f 6e             	arpl   %bp,0x6e(%edi)
  80:	66                   	data16

	return 0;
}

int rgb_set(struct conf_var *var, const char *s)
{
  81:	2e 63 00             	arpl   %ax,%cs:(%eax)
  84:	00 00                	add    %al,(%eax)
  86:	00 73 74             	add    %dh,0x74(%ebx)
	if (var->p == NULL) {
  89:	64 69 6f 32 2e 68 00 01 	imul   $0x100682e,%fs:0x32(%edi),%ebp
		var->p = malloc(sizeof(unsigned int));
  91:	00 00                	add    %al,(%eax)
  93:	73 74                	jae    109 <.debug_line+0x109>
  95:	72 69                	jb     100 <.debug_line+0x100>
  97:	6e                   	outsb  %ds:(%esi),(%dx)
  98:	67 33 2e 68 00       	xor    0x68,%ebp
  9d:	01 00                	add    %eax,(%eax)
	}

	return 0;
}
  9f:	00 73 74             	add    %dh,0x74(%ebx)
  a2:	64                   	fs
  a3:	64                   	fs
  a4:	65                   	gs
  a5:	66                   	data16
  a6:	2e                   	cs
  a7:	68 00 02 00 00       	push   $0x200

	return 0;
}

int oct64_set(struct conf_var *var, const char *s)
{
  ac:	74 79                	je     127 <.debug_line+0x127>
  ae:	70 65                	jo     115 <.debug_line+0x115>
	if (var->p == NULL) {
  b0:	73 2e                	jae    e0 <.debug_line+0xe0>
  b2:	68 00 01 00 00       	push   $0x100
		var->p = malloc(sizeof(long long int));
  b7:	73 74                	jae    12d <.debug_line+0x12d>
  b9:	64 69 6f 2e 68 00 03 00 	imul   $0x30068,%fs:0x2e(%edi),%ebp
  c1:	00 6c 69 62          	add    %ch,0x62(%ecx,%ebp,2)
	}

	return 0;
}
  c5:	69 6f 2e 68 00 03 00 	imul   $0x30068,0x2e(%edi),%ebp
  cc:	00 63 6f             	add    %ah,0x6f(%ebx)

	return 0;
}

int oct32_set(struct conf_var *var, const char *s)
{
  cf:	6e                   	outsb  %ds:(%esi),(%dx)
  d0:	66                   	data16
  d1:	2e                   	cs
  d2:	68 00 04 00 00       	push   $0x400
	if (var->p == NULL) {
  d7:	63 74 79 70          	arpl   %si,0x70(%ecx,%edi,2)
  db:	65                   	gs
  dc:	2e                   	cs
		var->p = malloc(sizeof(unsigned int));
  dd:	68 00 03 00 00       	push   $0x300
  e2:	00 00                	add    %al,(%eax)
  e4:	05 02 00 00 00       	add    $0x2,%eax	e6: R_386_32	.text
  e9:	00 03                	add    %al,(%ebx)
  eb:	ee                   	out    %al,(%dx)
	}

	return 0;
}
  ec:	05 01 16 03 34       	add    $0x34031601,%eax
  f1:	66 16                	pushw  %ss
  f3:	03 87 01 66 83 67    	add    0x67836601(%edi),%eax

	return 0;
}

int oct16_set(struct conf_var *var, const char *s)
{
  f9:	e8 03 66 9e 83       	call   839e6701 <ipport_set+0x839e543e>
	if (var->p == NULL) {
  fe:	67 e8 03 66 9e 83    	addr16 call 839e6707 <ipport_set+0x839e5444>
		var->p = malloc(sizeof(short int));
 104:	67 e8 03 66 9e 83    	addr16 call 839e670d <ipport_set+0x839e544a>
 10a:	67 e8 03 46 9e 83    	addr16 call 839e4713 <ipport_set+0x839e3450>
 110:	67 e8 03 66 9e 83    	addr16 call 839e6719 <ipport_set+0x839e5456>
	}

	return 0;
}
 116:	67 e8 03 6a 9e 83    	addr16 call 839e6b1f <ipport_set+0x839e585c>
 11c:	67 e8 03 66 9e 83    	addr16 call 839e6725 <ipport_set+0x839e5462>

	return 0;
}

int oct8_set(struct conf_var *var, const char *s)
{
 122:	67 e8 03 66 9e 83    	addr16 call 839e672b <ipport_set+0x839e5468>
	if (var->p == NULL) {
 128:	67 e8 03 6b 9e 83    	addr16 call 839e6c31 <ipport_set+0x839e596e>
		var->p = malloc(sizeof(unsigned char));
 12e:	67 e7 03             	addr16 out %eax,$0x3
 131:	67 9e                	addr16 sahf 
 133:	83 67 e8 03          	andl   $0x3,-0x18(%edi)
 137:	66                   	data16
 138:	9e                   	sahf   
 139:	83 67 e8 03          	andl   $0x3,-0x18(%edi)
	}

	return 0;
}
 13d:	c4 7d 9e             	les    -0x62(%ebp),%edi
 140:	75 04                	jne    146 <.debug_line+0x146>
 142:	02 03                	add    (%ebx),%al

	return 0;
}

int bin64_set(struct conf_var *var, const char *s)
{
 144:	98                   	cwtl   
 145:	7d ac                	jge    f3 <.debug_line+0xf3>
 147:	04 01                	add    $0x1,%al
 149:	03 ea                	add    %edx,%ebp
 14b:	02 9e 04 02 03 96    	add    -0x69fcfdfc(%esi),%bl
	if (var->p == NULL) {
 151:	7d 2e                	jge    181 <.debug_line+0x181>
		var->p = malloc(sizeof(long long int));
 153:	04 01                	add    $0x1,%al
 155:	03 ee                	add    %esi,%ebp
 157:	02 02                	add    (%edx),%al
 159:	24 01                	and    $0x1,%al
 15b:	59                   	pop    %ecx
 15c:	03 09                	add    (%ecx),%ecx
 15e:	4a                   	dec    %edx
 15f:	75 04                	jne    165 <.debug_line+0x165>
	}

	return 0;
}
 161:	02 03                	add    (%ebx),%al
 163:	87 7d ac             	xchg   %edi,-0x54(%ebp)
 166:	04 01                	add    $0x1,%al
 168:	03 fb                	add    %ebx,%edi
 16a:	02 9e 04 02 03 85    	add    -0x7afcfdfc(%esi),%bl

	return 0;
}

int bin32_set(struct conf_var *var, const char *s)
{
 170:	7d 2e                	jge    1a0 <.debug_line+0x1a0>
 172:	04 01                	add    $0x1,%al
	if (var->p == NULL) {
 174:	03 ff                	add    %edi,%edi
 176:	02 02                	add    (%edx),%al
 178:	26 01 59 03          	add    %ebx,%es:0x3(%ecx)
		var->p = malloc(sizeof(unsigned long));
 17c:	12 4a 75             	adc    0x75(%edx),%cl
 17f:	04 02                	add    $0x2,%al
 181:	03 ed                	add    %ebp,%ebp
 183:	7c ac                	jl     131 <.debug_line+0x131>
 185:	04 01                	add    $0x1,%al
 187:	03 95 03 9e 04 02    	add    0x2049e03(%ebp),%edx
	}
	return 0;
}
 18d:	03 eb                	add    %ebx,%ebp
 18f:	7c 2e                	jl     1bf <.debug_line+0x1bf>
 191:	04 01                	add    $0x1,%al

	return 0;
}

int bin16_set(struct conf_var *var, const char *s)
{
 193:	03 99 03 02 26 01    	add    0x1260203(%ecx),%ebx
 199:	59                   	pop    %ecx
	if (var->p == NULL) {
 19a:	03 12                	add    (%edx),%edx
 19c:	4a                   	dec    %edx
 19d:	75 04                	jne    1a3 <.debug_line+0x1a3>
 19f:	02 03                	add    (%ebx),%al
		var->p = malloc(sizeof(short int));
 1a1:	d3 7c ac 04          	sarl   %cl,0x4(%esp,%ebp,4)
 1a5:	01 03                	add    %eax,(%ebx)
 1a7:	af                   	scas   %es:(%edi),%eax
 1a8:	03 9e 04 02 03 d1    	add    -0x2efcfdfc(%esi),%ebx
 1ae:	7c 2e                	jl     1de <.debug_line+0x1de>
	}

	return 0;
}
 1b0:	04 01                	add    $0x1,%al
 1b2:	03 b3 03 02 26 01    	add    0x1260203(%ebx),%esi
 1b8:	59                   	pop    %ecx

	return 0;
}

int bin8_set(struct conf_var *var, const char *s)
{
 1b9:	03 0c 4a             	add    (%edx,%ecx,2),%ecx
 1bc:	77 04                	ja     1c2 <.debug_line+0x1c2>
 1be:	02 03                	add    (%ebx),%al
 1c0:	bd 7c ac 04 01       	mov    $0x104ac7c,%ebp
	if (var->p == NULL) {
 1c5:	03 c5                	add    %ebp,%eax
		var->p = malloc(sizeof(unsigned char));
 1c7:	03 9e 04 02 03 bb    	add    -0x44fcfdfc(%esi),%ebx
 1cd:	7c 2e                	jl     1fd <.debug_line+0x1fd>
 1cf:	04 01                	add    $0x1,%al
 1d1:	03 cb                	add    %ebx,%ecx
 1d3:	03 02                	add    (%edx),%eax
 1d5:	24 01                	and    $0x1,%al
	}

	return 0;
}
 1d7:	59                   	pop    %ecx
 1d8:	03 2d 4a 4b 04 02    	add    0x2044b4a,%ebp
 1de:	03 86 7c ba 04 01    	add    0x104ba7c(%esi),%eax
{
	return write_section(stdout, root, NULL);
}

int void_get(struct conf_var *var, char *s)
{
 1e4:	03 ff                	add    %edi,%edi
 1e6:	03 08                	add    (%eax),%ecx
	if (var->p == NULL) {
 1e8:	74 03                	je     1ed <.debug_line+0x1ed>
 1ea:	21 66 75             	and    %esp,0x75(%esi)
 1ed:	04 02                	add    $0x2,%al
 1ef:	03 df                	add    %edi,%ebx
 1f1:	7b ac                	jnp    19f <.debug_line+0x19f>

#ifdef __va_arg_pack
__extern_always_inline int
__NTH (sprintf (char *__restrict __s, __const char *__restrict __fmt, ...))
{
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
 1f3:	04 01                	add    $0x1,%al
 1f5:	03 a3 04 9e 33 04    	add    0x4339e04(%ebx),%esp
 1fb:	02 03                	add    (%ebx),%al
		sprintf(s, "NULL");
		return 0;
 1fd:	d8 7b 74             	fdivrs 0x74(%ebx)
 200:	04 01                	add    $0x1,%al
 202:	03 a9 04 08 e4 59    	add    0x59e40804(%ecx),%ebp
 208:	03 14 4a             	add    (%edx,%ecx,2),%edx
 20b:	75 04                	jne    211 <.debug_line+0x211>
 20d:	02 03                	add    (%ebx),%al
 20f:	c1 7b ac 04          	sarl   $0x4,-0x54(%ebx)
 213:	01 03                	add    %eax,(%ebx)
 215:	c1 04 9e 31          	roll   $0x31,(%esi,%ebx,4)
 219:	04 02                	add    $0x2,%al
 21b:	03 bc 7b 74 04 01 03 	add    0x3010474(%ebx,%edi,2),%edi
	}

	sprintf(s, "%p", var->p);
	return 1;
 222:	c5 04 08             	lds    (%eax,%ecx,1),%eax
 225:	e4 59                	in     $0x59,%al
}
 227:	03 0c 4a             	add    (%edx,%ecx,2),%ecx
 22a:	75 04                	jne    230 <.debug_line+0x230>
	sscanf(s, "%p", &(var->p));
	return 1;
}

int int_get(struct conf_var *var, char *s)
{
 22c:	02 03                	add    (%ebx),%al
 22e:	ad                   	lods   %ds:(%esi),%eax
 22f:	7b ac                	jnp    1dd <.debug_line+0x1dd>
 231:	04 01                	add    $0x1,%al
	if (var->p == NULL) {
 233:	03 d5                	add    %ebp,%edx
 235:	04 9e                	add    $0x9e,%al
 237:	04 02                	add    $0x2,%al
 239:	03 ab 7b 2e 04 01    	add    0x1042e7b(%ebx),%ebp
 23f:	03 d9                	add    %ecx,%ebx
 241:	04 02                	add    $0x2,%al
 243:	26 01 59 03          	add    %ebx,%es:0x3(%ecx)
		sprintf(s, "NULL");
		return 0;
 247:	0c 4a                	or     $0x4a,%al
 249:	75 04                	jne    24f <.debug_line+0x24f>
 24b:	02 03                	add    (%ebx),%al
 24d:	99                   	cltd   
 24e:	7b ac                	jnp    1fc <.debug_line+0x1fc>
 250:	04 01                	add    $0x1,%al
 252:	03 e9                	add    %ecx,%ebp
 254:	04 9e                	add    $0x9e,%al
 256:	04 02                	add    $0x2,%al
 258:	03 97 7b 2e 04 01    	add    0x1042e7b(%edi),%edx
 25e:	03 ed                	add    %ebp,%ebp
 260:	04 02                	add    $0x2,%al
 262:	26 01 59 03          	add    %ebx,%es:0x3(%ecx)
 266:	0d 4a 83 04 02       	or     $0x204834a,%eax
 26b:	03 84 7b ac 04 01 03 	add    0x30104ac(%ebx,%edi,2),%eax
	}

	sprintf(s, "%i", *(int *) (var->p));
	return 1;
 272:	fe 04 9e             	incb   (%esi,%ebx,4)
}
 275:	04 02                	add    $0x2,%al
 277:	03 82 7b 2e 04 01    	add    0x1042e7b(%edx),%eax

	return 1;
}

int uint_get(struct conf_var *var, char *s)
{
 27d:	03 83 05 02 2d 01    	add    0x12d0205(%ebx),%eax
	if (var->p == NULL) {
 283:	59                   	pop    %ecx
 284:	03 0e                	add    (%esi),%ecx
 286:	58                   	pop    %eax
 287:	4b                   	dec    %ebx
 288:	04 02                	add    $0x2,%al
 28a:	03 ed                	add    %ebp,%ebp
 28c:	7a 9e                	jp     22c <.debug_line+0x22c>
 28e:	04 01                	add    $0x1,%al
 290:	03 9a 05 9e 03 0c    	add    0xc039e05(%edx),%ebx
 296:	66 4b                	dec    %bx
 298:	04 02                	add    $0x2,%al
 29a:	03 d9                	add    %ecx,%ebx
 29c:	7a 9e                	jp     23c <.debug_line+0x23c>
 29e:	04 01                	add    $0x1,%al
 2a0:	03 ae 05 9e 03 0c    	add    0xc039e05(%esi),%ebp
 2a6:	66 4b                	dec    %bx
 2a8:	04 02                	add    $0x2,%al
 2aa:	03 c5                	add    %ebp,%eax
 2ac:	7a 9e                	jp     24c <.debug_line+0x24c>
 2ae:	04 01                	add    $0x1,%al
 2b0:	03 c2                	add    %edx,%eax
 2b2:	05 9e 03 1b 66       	add    $0x661b039e,%eax
 2b7:	4b                   	dec    %ebx
 2b8:	04 02                	add    $0x2,%al
 2ba:	03 a2 7a 9e 04 01    	add    0x1049e7a(%edx),%esp
		sprintf(s, "NULL");
		return 0;
	}

	sprintf(s, "%u", *(unsigned int *) (var->p));
	return 1;
 2c0:	03 e5                	add    %ebp,%esp
}
 2c2:	05 9e 03 0c 66       	add    $0x660c039e,%eax

	return 1;
}

int float_get(struct conf_var *var, char *s)
{
 2c7:	4b                   	dec    %ebx
 2c8:	04 02                	add    $0x2,%al
 2ca:	03 8e 7a 9e 04 01    	add    0x1049e7a(%esi),%ecx
	if (var->p == NULL) {
 2d0:	03 f9                	add    %ecx,%edi
 2d2:	05 9e 03 1c 66       	add    $0x661c039e,%eax
 2d7:	4b                   	dec    %ebx
 2d8:	04 02                	add    $0x2,%al
 2da:	03 ea                	add    %edx,%ebp
 2dc:	79 9e                	jns    27c <.debug_line+0x27c>
 2de:	04 01                	add    $0x1,%al
 2e0:	03 9d 06 9e 03 2c    	add    0x2c039e06(%ebp),%ebx
 2e6:	66 4b                	dec    %bx
 2e8:	04 02                	add    $0x2,%al
 2ea:	03 b6 79 9e 04 01    	add    0x1049e79(%esi),%esi
 2f0:	03 d1                	add    %ecx,%edx
 2f2:	06                   	push   %es
 2f3:	9e                   	sahf   
 2f4:	03 0c 66             	add    (%esi,%eiz,2),%ecx
 2f7:	4b                   	dec    %ebx
 2f8:	04 02                	add    $0x2,%al
 2fa:	03 a2 79 9e 04 01    	add    0x1049e79(%edx),%esp
 300:	03 e5                	add    %ebp,%esp
 302:	06                   	push   %es
 303:	9e                   	sahf   
 304:	03 0c 66             	add    (%esi,%eiz,2),%ecx
 307:	4b                   	dec    %ebx
 308:	04 02                	add    $0x2,%al
		sprintf(s, "NULL");
		return 0;
	}

	sprintf(s, "%f", *(double *) (var->p));
	return 1;
 30a:	03 8e 79 9e 04 01    	add    0x1049e79(%esi),%ecx
}
 310:	03 f9                	add    %ecx,%edi
	sscanf(s, "%lf", (double *) (var->p));
	return 1;
}

int string_get(struct conf_var *var, char *s)
{
 312:	06                   	push   %es
 313:	9e                   	sahf   
 314:	03 0c 66             	add    (%esi,%eiz,2),%ecx
 317:	4b                   	dec    %ebx
 318:	04 02                	add    $0x2,%al
	char * cp;			/* source */

	if (var->p == NULL) {
 31a:	03 fa                	add    %edx,%edi
 31c:	78 9e                	js     2bc <.debug_line+0x2bc>
 31e:	04 01                	add    $0x1,%al
 320:	03 8d 07 9e 03 fa    	add    -0x5fc61f9(%ebp),%ecx
 326:	7d 66                	jge    38e <.debug_line+0x38e>
 328:	83 67 e7 08          	andl   $0x8,-0x19(%edi)
 32c:	a1 03 62 9e 83       	mov    0x839e6203,%eax
 331:	67 e7 08             	addr16 out %eax,$0x8
 334:	a0 03 65 9e 83       	mov    0x839e6503,%al
 339:	67 e6 08             	addr16 out %al,$0x8
 33c:	a0 03 66 9e 83       	mov    0x839e6603,%al
 341:	67 e6 08             	addr16 out %al,$0x8
 344:	a0 03 e8 7e 9e       	mov    0x9e7ee803,%al
 349:	83 67 e6 08          	andl   $0x8,-0x1a(%edi)
 34d:	a0 03 b5 7f 9e       	mov    0x9e7fb503,%al
 352:	3d 08 d8 03 b8       	cmp    $0xb803d808,%eax
	}

	cp = (char *)(var->p);
	sprintf(s, "\"%s\"", cp);

	return 1;
 357:	01 90 93 67 e8 00    	add    %edx,0xe86793(%eax)

	return 1;
}

int bool_get(struct conf_var *var, char *s)
{
 35d:	02 04 04             	add    (%esp,%eax,1),%al
 360:	06                   	push   %es
	if ((*(int *) (var->p)) == 0)
 361:	c8 00 02 04          	enter  $0x200,$0x4
 365:	01 3c 00             	add    %edi,(%eax,%eax,1)
 368:	02 04 02             	add    (%edx,%eax,1),%al
 36b:	c8 00 02 04          	enter  $0x200,$0x4
 36f:	03 06                	add    (%esi),%eax
 371:	4e                   	dec    %esi
 372:	00 02                	add    %al,(%edx)
 374:	04 03                	add    $0x3,%al
 376:	08 68 03             	or     %ch,0x3(%eax)
 379:	47                   	inc    %edi
 37a:	ac                   	lods   %ds:(%esi),%al
 37b:	93                   	xchg   %eax,%ebx
 37c:	67 e8 00 02 04 04    	addr16 call 4040582 <ipport_set+0x403f2bf>
 382:	06                   	push   %es
 383:	c8 00 02 04          	enter  $0x200,$0x4
		sprintf(s, "False");
	else
		sprintf(s, "True");
	return 1;
}
 387:	01 3c 00             	add    %edi,(%eax,%eax,1)
 38a:	02 04 02             	add    (%edx,%eax,1),%al

	return 0;
}

int char_get(struct conf_var *var, char *s)
{
 38d:	c8 00 02 04          	enter  $0x200,$0x4
 391:	03 06                	add    (%esi),%eax
	if (var->p == NULL) {
 393:	4c                   	dec    %esp
 394:	00 02                	add    %al,(%edx)
 396:	04 01                	add    $0x1,%al
 398:	08 ad 00 02 04 01    	or     %ch,0x1040200(%ebp)
 39e:	08 73 4c             	or     %dh,0x4c(%ebx)
 3a1:	08 73 4b             	or     %dh,0x4b(%ebx)
 3a4:	08 ae 91 a1 00 02    	or     %ch,0x200a191(%esi)
		return 0;
	}

	//printf("*** %s: var '%s' = '%c'\n", __FUNCTION__, var->name, *(char *)(var->p));

	sprintf(s, "%c", *(char *) (var->p));
 3aa:	04 01                	add    $0x1,%al
 3ac:	08 ad 00 02 04 01    	or     %ch,0x1040200(%ebp)
 3b2:	08 73 4c             	or     %dh,0x4c(%ebx)
 3b5:	08 73 4b             	or     %dh,0x4b(%ebx)
 3b8:	08 96 03 7a 58 4c    	or     %dl,0x4c587a03(%esi)
 3be:	91                   	xchg   %eax,%ecx
 3bf:	5c                   	pop    %esp
 3c0:	03 b2 7f 66 dc f6    	add    -0x9239981(%edx),%esi
 3c6:	00 02                	add    %al,(%edx)
 3c8:	04 04                	add    $0x4,%al
 3ca:	06                   	push   %es
 3cb:	ac                   	lods   %ds:(%esi),%al
 3cc:	00 02                	add    %al,(%edx)
 3ce:	04 01                	add    $0x1,%al
	return 1;
 3d0:	3c 00                	cmp    $0x0,%al
 3d2:	02 04 02             	add    (%edx,%eax,1),%al
}
 3d5:	c8 4a 00 02          	enter  $0x4a,$0x2
	sscanf(cp, "%c", (char *) (var->p));
	return 1;
}

int hex8_get(struct conf_var *var, char *s)
{
 3d9:	04 03                	add    $0x3,%al
 3db:	4a                   	dec    %edx
 3dc:	00 02                	add    %al,(%edx)
 3de:	04 03                	add    $0x3,%al
	if (var->p == NULL) {
 3e0:	06                   	push   %es
 3e1:	2f                   	das    
 3e2:	92                   	xchg   %eax,%edx
 3e3:	3d e5 49 04 02       	cmp    $0x20449e5,%eax
 3e8:	03 e3                	add    %ebx,%esp
 3ea:	7c 4a                	jl     436 <.debug_line+0x436>
 3ec:	04 01                	add    $0x1,%al
 3ee:	03 a3 03 02 25 01    	add    0x1250203(%ebx),%esp
 3f4:	03 77 74             	add    0x74(%edi),%esi
		sprintf(s, "NULL");
		return 0;
	}

	sprintf(s, "0x%02X", *(unsigned char *) (var->p));
 3f7:	03 0d 2e 08 31 67    	add    0x6731082e,%ecx
 3fd:	d9 75 04             	fnstenv 0x4(%ebp)
 400:	03 03                	add    (%ebx),%eax
 402:	e8 7c 58 04 01       	call   1045c83 <ipport_set+0x10449c0>
 407:	03 9c 03 08 2e 76 03 	add    0x3762e08(%ebx,%eax,1),%ebx
 40e:	61                   	popa   
 40f:	74 03                	je     414 <.debug_line+0x414>
 411:	20 58 03             	and    %bl,0x3(%eax)
 414:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
 415:	7f 74                	jg     48b <.debug_line+0x48b>
 417:	85 67 e7             	test   %esp,-0x19(%edi)
 41a:	3e                   	ds
 41b:	08 cb                	or     %cl,%bl
 41d:	03 5a 9e             	add    -0x62(%edx),%ebx
	return 1;
 420:	85 67 e7             	test   %esp,-0x19(%edi)
}
 423:	3e                   	ds
 424:	08 cb                	or     %cl,%bl
 426:	03 95 7f 9e d6 03    	add    0x3d69e7f(%ebp),%edx
	sscanf(s, "%X", (unsigned int *) (var->p));
	return 1;
}

int hex16_get(struct conf_var *var, char *s)
{
 42c:	0b e4                	or     %esp,%esp
	if (var->p == NULL) {
 42e:	81 00 02 04 01 86    	addl   $0x86010402,(%eax)
 434:	06                   	push   %es
 435:	90                   	nop
 436:	06                   	push   %es
 437:	a3 08 47 9f 92       	mov    %eax,0x929f4708
 43c:	d7                   	xlat   %ds:(%ebx)
 43d:	04 02                	add    $0x2,%al
 43f:	03 88 7e 4a 04 01    	add    0x1044a7e(%eax),%ecx
 445:	03 fd                	add    %ebp,%edi
 447:	01 02                	add    %eax,(%edx)
 449:	4e                   	dec    %esi
 44a:	01 3e                	add    %edi,(%esi)
 44c:	03 73 3c             	add    0x3c(%ebx),%esi
 44f:	03 10                	add    (%eax),%edx
 451:	08 12                	or     %dl,(%edx)
 453:	f3 4b                	repz dec %ebx
 455:	04 02                	add    $0x2,%al
 457:	03 fc                	add    %esp,%edi
 459:	7d 4a                	jge    4a5 <.debug_line+0x4a5>
 45b:	04 01                	add    $0x1,%al
 45d:	03 86 02 08 3c 00    	add    0x3c0802(%esi),%eax
 463:	02 04 01             	add    (%ecx,%eax,1),%al
 466:	06                   	push   %es
 467:	4a                   	dec    %edx
 468:	04 02                	add    $0x2,%al
 46a:	06                   	push   %es
		sprintf(s, "NULL");
		return 0;
	}

	sprintf(s, "0x%04X", *(unsigned int *) (var->p));
	return 1;
 46b:	03 ba 7d 66 04 01    	add    0x104667d(%edx),%edi
}
 471:	03 c7                	add    %edi,%eax
 473:	02 02                	add    (%edx),%al
	sscanf(s, "%X", (unsigned int *) (var->p));
	return 1;
}

int hex32_get(struct conf_var *var, char *s)
{
 475:	22 01                	and    (%ecx),%al
 477:	04 02                	add    $0x2,%al
 479:	03 b9 7d 3c 04 03    	add    0x3043c7d(%ecx),%edi
	if (var->p == NULL) {
 47f:	03 c7                	add    %edi,%eax
 481:	00 74 04 01          	add    %dh,0x1(%esp,%eax,1)
 485:	03 82 02 d6 04 03    	add    0x304d602(%edx),%eax
 48b:	03 fe                	add    %esi,%edi
 48d:	7d 3c                	jge    4cb <.debug_line+0x4cb>
 48f:	04 01                	add    $0x1,%al
		sprintf(s, "NULL");
		return 0;
 491:	03 83 02 58 04 02    	add    0x2045802(%ebx),%eax
 497:	03 f6                	add    %esi,%esi
 499:	7d 4a                	jge    4e5 <.debug_line+0x4e5>
 49b:	04 01                	add    $0x1,%al
 49d:	03 8b 02 08 ac 03    	add    0x3ac0802(%ebx),%ecx
 4a3:	77 08                	ja     4ad <.debug_line+0x4ad>
 4a5:	20 03                	and    %al,(%ebx)
 4a7:	0d c8 03 74 08       	or     $0x87403c8,%eax
 4ac:	58                   	pop    %eax
 4ad:	94                   	xchg   %eax,%esp
 4ae:	c2 03 ed             	ret    $0xed03
 4b1:	7d f2                	jge    4a5 <.debug_line+0x4a5>
 4b3:	cb                   	lret   
 4b4:	00 02                	add    %al,(%edx)
 4b6:	04 01                	add    $0x1,%al
	}

	sprintf(s, "0x%08X", *(unsigned int *) (var->p));
	return 1;
 4b8:	4c                   	dec    %esp
 4b9:	00 02                	add    %al,(%edx)
 4bb:	04 01                	add    $0x1,%al
}
 4bd:	56                   	push   %esi
 4be:	5d                   	pop    %ebp
 4bf:	00 02                	add    %al,(%edx)
	sscanf(s, "%X", (unsigned int *) (var->p));
	return 1;
}

int hex64_get(struct conf_var *var, char *s)
{
 4c1:	04 01                	add    $0x1,%al
 4c3:	4f                   	dec    %edi
 4c4:	06                   	push   %es
 4c5:	66 06                	pushw  %es
 4c7:	2f                   	das    
 4c8:	f4                   	hlt    
	if (var->p == NULL) {
 4c9:	39 6d 03             	cmp    %ebp,0x3(%ebp)
 4cc:	71 74                	jno    542 <.debug_line+0x542>
 4ce:	79 03                	jns    4d3 <.debug_line+0x4d3>
 4d0:	0b 58 85             	or     -0x7b(%eax),%ebx
 4d3:	85 08                	test   %ecx,(%eax)
 4d5:	3d 4f a0 c9 03       	cmp    $0x3c9a04f,%eax
 4da:	79 74                	jns    550 <.debug_line+0x550>
 4dc:	03 0a                	add    (%edx),%ecx
		sprintf(s, "NULL");
		return 0;
 4de:	58                   	pop    %eax
 4df:	5b                   	pop    %ebx
 4e0:	85 4d 08             	test   %ecx,0x8(%ebp)
 4e3:	3d 4d c9 57 04       	cmp    $0x457c94d,%eax
 4e8:	03 03                	add    (%ebx),%eax
 4ea:	57                   	push   %edi
 4eb:	4a                   	dec    %edx
 4ec:	04 01                	add    $0x1,%al
 4ee:	03 2d 08 12 03 76    	add    0x76031208,%ebp
 4f4:	2e 78 03             	js,pn  4fa <.debug_line+0x4fa>
 4f7:	0a 58 77             	or     0x77(%eax),%bl
 4fa:	08 e4                	or     %ah,%ah
 4fc:	03 15 e4 03 10 02    	add    0x21003e4,%edx
 502:	45                   	inc    %ebp
 503:	01 03                	add    %eax,(%ebx)
 505:	0b 58 03             	or     0x3(%eax),%ebx
 508:	7a ac                	jp     4b6 <.debug_line+0x4b6>
 50a:	50                   	push   %eax
 50b:	00 02                	add    %al,(%edx)
	}

	sprintf(s, "0x%016llX", *(unsigned long long int *) (var->p));

	return 1;
 50d:	04 04                	add    $0x4,%al
 50f:	06                   	push   %es
 510:	2e 00 02             	add    %al,%cs:(%edx)
}
 513:	04 01                	add    $0x1,%al
 515:	3c 00                	cmp    $0x0,%al

	return 1;
}

int bin8_get(struct conf_var *var, char *s)
{
 517:	02 04 02             	add    (%edx,%eax,1),%al
 51a:	c8 4a 00 02          	enter  $0x4a,$0x2
	if (var->p == NULL) {
 51e:	04 03                	add    $0x3,%al
 520:	06                   	push   %es
 521:	67 06                	addr16 push %es
 523:	08 74 00 02          	or     %dh,0x2(%eax,%eax,1)
 527:	04 04                	add    $0x4,%al
 529:	9e                   	sahf   
 52a:	00 02                	add    %al,(%edx)
 52c:	04 02                	add    $0x2,%al
 52e:	74 00                	je     530 <.debug_line+0x530>
		return 0;
	}
	s = "";

	return 0;
}
 530:	02 04 03             	add    (%ebx,%eax,1),%al
 533:	9e                   	sahf   
 534:	00 02                	add    %al,(%edx)

	return 0;
}

int bin16_get(struct conf_var *var, char *s)
{
 536:	04 03                	add    $0x3,%al
 538:	06                   	push   %es
	if (var->p == NULL) {
 539:	50                   	push   %eax
 53a:	00 02                	add    %al,(%edx)
 53c:	04 01                	add    $0x1,%al
 53e:	06                   	push   %es
 53f:	08 2e                	or     %ch,(%esi)
 541:	06                   	push   %es
 542:	f5                   	cmc    
 543:	a1 00 02 04 04       	mov    0x4040200,%eax
 548:	06                   	push   %es
 549:	08 4a 00             	or     %cl,0x0(%edx)
 54c:	02 04 02             	add    (%edx,%eax,1),%al
		return 0;
	}
	s = "";

	return 0;
}
 54f:	08 12                	or     %dl,(%edx)
 551:	00 02                	add    %al,(%edx)

	return 0;
}

int bin32_get(struct conf_var *var, char *s)
{
 553:	04 03                	add    $0x3,%al
 555:	06                   	push   %es
 556:	4c                   	dec    %esp
	if (var->p == NULL) {
 557:	08 3d 42 04 02 03    	or     %bh,0x3020442
 55d:	ff                   	(bad)  
 55e:	7e 02                	jle    562 <.debug_line+0x562>
 560:	2a 01                	sub    (%ecx),%al
 562:	04 01                	add    $0x1,%al
 564:	03 fe                	add    %esi,%edi
 566:	00 02                	add    %al,(%edx)
 568:	2d 01 83 00 02       	sub    $0x2008301,%eax
		return 0;
	}
	s = "";

	return 0;
}
 56d:	04 04                	add    $0x4,%al
 56f:	5a                   	pop    %edx
 570:	00 02                	add    %al,(%edx)

	return 0;
}

int oct8_get(struct conf_var *var, char *s)
{
 572:	04 02                	add    $0x2,%al
 574:	06                   	push   %es
	if (var->p == NULL) {
 575:	74 00                	je     577 <.debug_line+0x577>
 577:	02 04 03             	add    (%ebx,%eax,1),%al
 57a:	9e                   	sahf   
 57b:	00 02                	add    %al,(%edx)
 57d:	04 03                	add    $0x3,%al
 57f:	06                   	push   %es
 580:	4d                   	dec    %ebp
 581:	00 02                	add    %al,(%edx)
 583:	04 03                	add    $0x3,%al
 585:	08 21                	or     %ah,(%ecx)
 587:	04 02                	add    $0x2,%al
		return 0;
	}
	s = "";

	return 0;
}
 589:	03 fb                	add    %ebx,%edi
 58b:	7e 4a                	jle    5d7 <.debug_line+0x5d7>
 58d:	04 01                	add    $0x1,%al

	return 0;
}

int oct16_get(struct conf_var *var, char *s)
{
 58f:	03 89 01 02 31 01    	add    0x1310201(%ecx),%ecx
	if (var->p == NULL) {
 595:	83 5a 04 02          	sbbl   $0x2,0x4(%edx)
 599:	03 f4                	add    %esp,%esi
 59b:	7e 90                	jle    52d <.debug_line+0x52d>
 59d:	04 01                	add    $0x1,%al
 59f:	03 92 01 02 31 01    	add    0x1310201(%edx),%edx
 5a5:	75 83                	jne    52a <.debug_line+0x52a>
		return 0;
	}
	s = "";

	return 0;
}
 5a7:	5b                   	pop    %ebx
 5a8:	00 02                	add    %al,(%edx)
 5aa:	04 01                	add    $0x1,%al
 5ac:	b3 06                	mov    $0x6,%bl

	return 0;
}

int oct64_get(struct conf_var *var, char *s)
{
 5ae:	82                   	(bad)  
 5af:	00 02                	add    %al,(%edx)
	if (var->p == NULL) {
 5b1:	04 02                	add    $0x2,%al
 5b3:	2e 08 12             	or     %dl,%cs:(%edx)
 5b6:	06                   	push   %es
 5b7:	33 04 02             	xor    (%edx,%eax,1),%eax
 5ba:	03 dd                	add    %ebp,%ebx
 5bc:	7e 82                	jle    540 <.debug_line+0x540>
 5be:	04 01                	add    $0x1,%al
 5c0:	03 a5 01 02 2d 01    	add    0x12d0201(%ebp),%esp
		return 0;
	}
	s = "";

	return 0;
}
 5c6:	5f                   	pop    %edi
 5c7:	4c                   	dec    %esp
 5c8:	42                   	inc    %edx
 5c9:	00 02                	add    %al,(%edx)

	return 0;
}

int rgb_get(struct conf_var *var, char *s)
{
 5cb:	04 04                	add    $0x4,%al
 5cd:	06                   	push   %es
 5ce:	08 2e                	or     %ch,(%esi)
	if (var->p == NULL) {
 5d0:	00 02                	add    %al,(%edx)
 5d2:	04 02                	add    $0x2,%al
 5d4:	f2 04 03             	repnz add $0x3,%al
 5d7:	00 02                	add    %al,(%edx)
 5d9:	04 03                	add    $0x3,%al
 5db:	06                   	push   %es
 5dc:	03 d3                	add    %ebx,%edx
 5de:	7e 4a                	jle    62a <.debug_line+0x62a>
 5e0:	04 01                	add    $0x1,%al
 5e2:	00 02                	add    %al,(%edx)
		return 0;
	}
	s = "";

	return 0;
}
 5e4:	04 03                	add    $0x3,%al
 5e6:	03 b1 01 ba 04 03    	add    0x304ba01(%ecx),%esi

	return 0;
}

int rgbi_get(struct conf_var *var, char *s)
{
 5ec:	00 02                	add    %al,(%edx)
	if (var->p == NULL) {
 5ee:	04 03                	add    $0x3,%al
 5f0:	03 cf                	add    %edi,%ecx
 5f2:	7e 9e                	jle    592 <.debug_line+0x592>
 5f4:	04 01                	add    $0x1,%al
 5f6:	00 02                	add    %al,(%edx)
 5f8:	04 03                	add    $0x3,%al
 5fa:	03 b6 01 58 06 08    	add    0x8065801(%esi),%esi
 600:	74 00                	je     602 <.debug_line+0x602>
		return 0;
	}
	s = "";

	return 0;
}
 602:	02 04 04             	add    (%esp,%eax,1),%al
 605:	f2 00 02             	repnz add %al,(%edx)

	return 0;
}

int cymk_get(struct conf_var *var, char *s)
{
 608:	04 02                	add    $0x2,%al
 60a:	74 00                	je     60c <.debug_line+0x60c>
	if (var->p == NULL) {
 60c:	02 04 03             	add    (%ebx,%eax,1),%al
 60f:	9e                   	sahf   
 610:	04 03                	add    $0x3,%al
 612:	00 02                	add    %al,(%edx)
 614:	04 03                	add    $0x3,%al
 616:	06                   	push   %es
 617:	03 ca                	add    %edx,%ecx
 619:	7e 4a                	jle    665 <.debug_line+0x665>
 61b:	04 01                	add    $0x1,%al
 61d:	00 02                	add    %al,(%edx)
		return 0;
	}
	s = "";

	return 0;
}
 61f:	04 03                	add    $0x3,%al
 621:	03 b7 01 ba 04 03    	add    0x304ba01(%edi),%esi

	return 0;
}

int ratio_get(struct conf_var *var, char *s)
{
 627:	00 02                	add    %al,(%edx)
	if (var->p == NULL) {
 629:	04 03                	add    $0x3,%al
 62b:	03 c9                	add    %ecx,%ecx
 62d:	7e 9e                	jle    5cd <.debug_line+0x5cd>
 62f:	04 01                	add    $0x1,%al
 631:	00 02                	add    %al,(%edx)
 633:	04 03                	add    $0x3,%al
 635:	03 bc 01 58 00 02 04 	add    0x4020058(%ecx,%eax,1),%edi
 63c:	03 08                	add    (%eax),%ecx
		return 0;
	}
	s = "";

	return 0;
}
 63e:	6b 4b 04 02          	imul   $0x2,0x4(%ebx),%ecx
 642:	03 b7 7e ac 04 01    	add    0x104ac7e(%edi),%esi

	return 1;
}

int hex64_set(struct conf_var *var, const char *s)
{
 648:	03 ca                	add    %edx,%ecx
 64a:	01 02                	add    %eax,(%edx)
	if (var->p == NULL) {
 64c:	2d 01 36 08 75       	sub    $0x75083601,%eax
		var->p = malloc(sizeof(unsigned long long int));
 651:	04 02                	add    $0x2,%al
 653:	03 ad 7e 74 00 02    	add    0x200747e(%ebp),%ebp
 659:	04 01                	add    $0x1,%al
 65b:	03 9d 01 02 2d 01    	add    0x12d0201(%ebp),%ebx
	}

	sscanf(s, "%llX", (unsigned long long int *) (var->p));
 661:	04 01                	add    $0x1,%al
 663:	00 02                	add    %al,(%edx)
 665:	04 01                	add    $0x1,%al
 667:	03 42 f2             	add    -0xe(%edx),%eax
 66a:	04 02                	add    $0x2,%al
 66c:	00 02                	add    %al,(%edx)
 66e:	04 01                	add    $0x1,%al
 670:	03 3e                	add    (%esi),%edi
 672:	74 04                	je     678 <.debug_line+0x678>
 674:	01 00                	add    %eax,(%eax)
 676:	02 04 01             	add    (%ecx,%eax,1),%al
 679:	03 42 58             	add    0x58(%edx),%eax

	return 1;
}
 67c:	03 fb                	add    %ebx,%edi
 67e:	00 82 bc 03 f5 7e    	add    %al,0x7ef503bc(%edx)
 684:	2e 03 8c 01 82 03 35 02 	add    %cs:0x2350382(%ecx,%eax,1),%ecx
	sprintf(s, "0x%08X", *(unsigned int *) (var->p));
	return 1;
}

int hex32_set(struct conf_var *var, const char *s)
{
 68c:	24 01                	and    $0x1,%al
	if (var->p == NULL) {
 68e:	b0 08                	mov    $0x8,%al
 690:	94                   	xchg   %eax,%esp
 691:	f4                   	hlt    
 692:	84 03                	test   %al,(%ebx)
		var->p = malloc(sizeof(unsigned int));
 694:	79 2e                	jns    6c4 <hex32_set+0x3f>
 696:	60                   	pusha  
 697:	d9 3d 08 2f 03 c5    	fnstcw 0xc5032f08
 69d:	03 4a 16             	add    0x16(%edx),%ecx
 6a0:	69 83 67 e8 a1 16 69 83 67 e8 	imul   $0xe8678369,0x16a1e867(%ebx),%eax
	}

	sscanf(s, "%X", (unsigned int *) (var->p));
 6aa:	02 0a                	add    (%edx),%cl
 6ac:	00 01                	add    %al,(%ecx)
 6ae:	01                   	.byte 0x1

Disassembly of section .debug_str:

00000000 <.debug_str>:
int bin64_get(struct conf_var *var, char *s)
{
	s = "";

	return 0;
}
   0:	5f                   	pop    %edi
   1:	73 68                	jae    6b <.debug_str+0x6b>
   3:	6f                   	outsl  %ds:(%esi),(%dx)
   4:	72 74                	jb     7a <.debug_str+0x7a>
int oct32_get(struct conf_var *var, char *s)
{
	s = "";

	return 0;
}
   6:	62 75 66             	bound  %esi,0x66(%ebp)
   9:	00 5f 49             	add    %bl,0x49(%edi)

	return 0;
}

int ratio_set(struct conf_var *var, const char *s)
{
   c:	4f                   	dec    %edi
   d:	5f                   	pop    %edi
   e:	6c                   	insb   (%dx),%es:(%edi)
   f:	6f                   	outsl  %ds:(%esi),(%dx)
  10:	63 6b 5f             	arpl   %bp,0x5f(%ebx)
  13:	74 00                	je     15 <.debug_str+0x15>
	if (var->p == NULL) {
  15:	63 6f 6e             	arpl   %bp,0x6e(%edi)
  18:	66 5f                	pop    %di
		var->p = malloc(2 * sizeof(int));
  1a:	64                   	fs
  1b:	75 6d                	jne    8a <.debug_str+0x8a>
  1d:	70 00                	jo     1f <.debug_str+0x1f>
  1f:	63 6f 6e             	arpl   %bp,0x6e(%edi)
  22:	66 5f                	pop    %di
  24:	74 79                	je     9f <.debug_str+0x9f>
  26:	70 65                	jo     8d <.debug_str+0x8d>
  28:	00 5f 49             	add    %bl,0x49(%edi)
	}

	return 0;
}
  2b:	4f                   	dec    %edi
  2c:	5f                   	pop    %edi
  2d:	62 75 66             	bound  %esi,0x66(%ebp)
  30:	5f                   	pop    %edi
  31:	65 6e                	outsb  %gs:(%esi),(%dx)

	return 0;
}

int cymk_set(struct conf_var *var, const char *s)
{
  33:	64 00 68 65          	add    %ch,%fs:0x65(%eax)
  37:	78 38                	js     71 <.debug_str+0x71>
  39:	5f                   	pop    %edi
  3a:	67                   	addr16
	if (var->p == NULL) {
  3b:	65                   	gs
  3c:	74 00                	je     3e <.debug_str+0x3e>
  3e:	5f                   	pop    %edi
  3f:	49                   	dec    %ecx
  40:	4f                   	dec    %edi
		var->p = malloc(sizeof(unsigned int));
  41:	5f                   	pop    %edi
  42:	77 72                	ja     b6 <.debug_str+0xb6>
  44:	69 74 65 5f 65 6e 64 00 	imul   $0x646e65,0x5f(%ebp,%eiz,2),%esi
  4c:	75 6e                	jne    bc <.debug_str+0xbc>
  4e:	73 69                	jae    b9 <.debug_str+0xb9>
	}

	return 0;
}
  50:	67 6e                	outsb  %ds:(%si),(%dx)
  52:	65 64 20 69 6e       	gs and %ch,%fs:%gs:0x6e(%ecx)
  57:	74 00                	je     59 <.debug_str+0x59>
  59:	68 65 78 33 32       	push   $0x32337865

	return 0;
}

int rgbi_set(struct conf_var *var, const char *s)
{
  5e:	5f                   	pop    %edi
  5f:	73 65                	jae    c6 <.debug_str+0xc6>
  61:	74 00                	je     63 <.debug_str+0x63>
	if (var->p == NULL) {
  63:	5f                   	pop    %edi
  64:	66                   	data16
  65:	6c                   	insb   (%dx),%es:(%edi)
  66:	61                   	popa   
  67:	67 73 00             	addr16 jae 6a <.debug_str+0x6a>
		var->p = malloc(sizeof(unsigned int));
  6a:	68 65 61 64 00       	push   $0x646165
  6f:	62 69 6e             	bound  %ebp,0x6e(%ecx)
  72:	38 5f 67             	cmp    %bl,0x67(%edi)
  75:	65                   	gs
  76:	74 00                	je     78 <.debug_str+0x78>
	}

	return 0;
}
  78:	6f                   	outsl  %ds:(%esi),(%dx)
  79:	63 74 38 5f          	arpl   %si,0x5f(%eax,%edi,1)
  7d:	67                   	addr16
  7e:	65                   	gs
  7f:	74 00                	je     81 <.debug_str+0x81>

	return 0;
}

int rgb_set(struct conf_var *var, const char *s)
{
  81:	76 6f                	jbe    f2 <.debug_str+0xf2>
  83:	69 64 5f 73 65 74 00 5f 	imul   $0x5f007465,0x73(%edi,%ebx,2),%esp
	if (var->p == NULL) {
  8b:	6d                   	insl   (%dx),%es:(%edi)
  8c:	61                   	popa   
  8d:	72 6b                	jb     fa <.debug_str+0xfa>
		var->p = malloc(sizeof(unsigned int));
  8f:	65                   	gs
  90:	72 73                	jb     105 <.debug_str+0x105>
  92:	00 63 6f             	add    %ah,0x6f(%ebx)
  95:	6e                   	outsb  %ds:(%esi),(%dx)
  96:	66 5f                	pop    %di
  98:	74 79                	je     113 <.debug_str+0x113>
  9a:	70 65                	jo     101 <.debug_str+0x101>
  9c:	5f                   	pop    %edi
  9d:	74 61                	je     100 <.debug_str+0x100>
	}

	return 0;
}
  9f:	62 00                	bound  %eax,(%eax)
  a1:	6f                   	outsl  %ds:(%esi),(%dx)
  a2:	63 74 33 32          	arpl   %si,0x32(%ebx,%esi,1)
  a6:	5f                   	pop    %edi
  a7:	73 65                	jae    10e <.debug_str+0x10e>

	return 0;
}

int oct64_set(struct conf_var *var, const char *s)
{
  a9:	74 00                	je     ab <.debug_str+0xab>
  ab:	5f                   	pop    %edi
  ac:	70 6f                	jo     11d <.debug_str+0x11d>
  ae:	73 00                	jae    b0 <.debug_str+0xb0>
	if (var->p == NULL) {
  b0:	73 74                	jae    126 <.debug_str+0x126>
  b2:	72 63                	jb     117 <.debug_str+0x117>
  b4:	70 79                	jo     12f <.debug_str+0x12f>
		var->p = malloc(sizeof(long long int));
  b6:	00 68 65             	add    %ch,0x65(%eax)
  b9:	78 36                	js     f1 <.debug_str+0xf1>
  bb:	34 5f                	xor    $0x5f,%al
  bd:	73 65                	jae    124 <.debug_str+0x124>
  bf:	74 00                	je     c1 <.debug_str+0xc1>
  c1:	72 67                	jb     12a <.debug_str+0x12a>
  c3:	62 69 5f             	bound  %ebp,0x5f(%ecx)
	}

	return 0;
}
  c6:	73 65                	jae    12d <.debug_str+0x12d>
  c8:	74 00                	je     ca <.debug_str+0xca>
  ca:	5f                   	pop    %edi
  cb:	49                   	dec    %ecx
  cc:	4f                   	dec    %edi
  cd:	5f                   	pop    %edi
  ce:	73 61                	jae    131 <.debug_str+0x131>

	return 0;
}

int oct32_set(struct conf_var *var, const char *s)
{
  d0:	76 65                	jbe    137 <.debug_str+0x137>
  d2:	5f                   	pop    %edi
  d3:	65 6e                	outsb  %gs:(%esi),(%dx)
  d5:	64 00 62 69          	add    %ah,%fs:0x69(%edx)
	if (var->p == NULL) {
  d9:	6e                   	outsb  %ds:(%esi),(%dx)
  da:	33 32                	xor    (%edx),%esi
  dc:	5f                   	pop    %edi
		var->p = malloc(sizeof(unsigned int));
  dd:	73 65                	jae    144 <.debug_str+0x144>
  df:	74 00                	je     e1 <.debug_str+0xe1>
  e1:	5f                   	pop    %edi
  e2:	5f                   	pop    %edi
  e3:	6c                   	insb   (%dx),%es:(%edi)
  e4:	65 6e                	outsb  %gs:(%esi),(%dx)
  e6:	00 69 67             	add    %ch,0x67(%ecx)
  e9:	6e                   	outsb  %ds:(%esi),(%dx)
  ea:	6f                   	outsl  %ds:(%esi),(%dx)
  eb:	72 65                	jb     152 <.debug_str+0x152>
	}

	return 0;
}
  ed:	00 63 6f             	add    %ah,0x6f(%ebx)
  f0:	75 6e                	jne    160 <.debug_str+0x160>
  f2:	74 00                	je     f4 <.debug_str+0xf4>
  f4:	6c                   	insb   (%dx),%es:(%edi)
  f5:	6f                   	outsl  %ds:(%esi),(%dx)

	return 0;
}

int oct16_set(struct conf_var *var, const char *s)
{
  f6:	6e                   	outsb  %ds:(%esi),(%dx)
  f7:	67 20 6c 6f          	and    %ch,0x6f(%si)
  fb:	6e                   	outsb  %ds:(%esi),(%dx)
  fc:	67 20 75 6e          	and    %dh,0x6e(%di)
	if (var->p == NULL) {
 100:	73 69                	jae    16b <.debug_str+0x16b>
 102:	67 6e                	outsb  %ds:(%si),(%dx)
		var->p = malloc(sizeof(short int));
 104:	65 64 20 69 6e       	gs and %ch,%fs:%gs:0x6e(%ecx)
 109:	74 00                	je     10b <.debug_str+0x10b>
 10b:	66                   	data16
 10c:	6c                   	insb   (%dx),%es:(%edi)
 10d:	6f                   	outsl  %ds:(%esi),(%dx)
 10e:	61                   	popa   
 10f:	74 5f                	je     170 <.debug_str+0x170>
 111:	67                   	addr16
 112:	65                   	gs
	}

	return 0;
}
 113:	74 00                	je     115 <.debug_str+0x115>
 115:	73 74                	jae    18b <.debug_str+0x18b>
 117:	72 6e                	jb     187 <.debug_str+0x187>
 119:	63 70 79             	arpl   %si,0x79(%eax)
 11c:	00 62 72             	add    %ah,0x72(%edx)

	return 0;
}

int oct8_set(struct conf_var *var, const char *s)
{
 11f:	61                   	popa   
 120:	6e                   	outsb  %ds:(%esi),(%dx)
 121:	63 68 00             	arpl   %bp,0x0(%eax)
 124:	5f                   	pop    %edi
	if (var->p == NULL) {
 125:	49                   	dec    %ecx
 126:	4f                   	dec    %edi
 127:	5f                   	pop    %edi
 128:	62 61 63             	bound  %esp,0x63(%ecx)
		var->p = malloc(sizeof(unsigned char));
 12b:	6b 75 70 5f          	imul   $0x5f,0x70(%ebp),%esi
 12f:	62 61 73             	bound  %esp,0x73(%ecx)
 132:	65 00 69 70          	add    %ch,%gs:0x70(%ecx)
 136:	61                   	popa   
 137:	64                   	fs
 138:	64                   	fs
 139:	72 5f                	jb     19a <.debug_str+0x19a>
	}

	return 0;
}
 13b:	73 65                	jae    1a2 <.debug_str+0x1a2>
 13d:	74 00                	je     13f <.debug_str+0x13f>
 13f:	5f                   	pop    %edi
 140:	6f                   	outsl  %ds:(%esi),(%dx)
 141:	66                   	data16
 142:	66                   	data16
 143:	73 65                	jae    1aa <.debug_str+0x1aa>

	return 0;
}

int bin64_set(struct conf_var *var, const char *s)
{
 145:	74 00                	je     147 <.debug_str+0x147>
 147:	5f                   	pop    %edi
 148:	5f                   	pop    %edi
 149:	64                   	fs
 14a:	65                   	gs
 14b:	73 74                	jae    1c1 <.debug_str+0x1c1>
	if (var->p == NULL) {
 14d:	00 5f 49             	add    %bl,0x49(%edi)
 150:	53                   	push   %ebx
 151:	6c                   	insb   (%dx),%es:(%edi)
		var->p = malloc(sizeof(long long int));
 152:	6f                   	outsl  %ds:(%esi),(%dx)
 153:	77 65                	ja     1ba <.debug_str+0x1ba>
 155:	72 00                	jb     157 <.debug_str+0x157>
 157:	5f                   	pop    %edi
 158:	66 69 6c 65 6e 6f 00 	imul   $0x6f,0x6e(%ebp,%eiz,2),%bp
 15f:	6f                   	outsl  %ds:(%esi),(%dx)
 160:	63 74 36 34          	arpl   %si,0x34(%esi,%esi,1)
	}

	return 0;
}
 164:	5f                   	pop    %edi
 165:	73 65                	jae    1cc <.debug_str+0x1cc>
 167:	74 00                	je     169 <.debug_str+0x169>
 169:	76 61                	jbe    1cc <.debug_str+0x1cc>

	return 0;
}

int bin32_set(struct conf_var *var, const char *s)
{
 16b:	72 5f                	jb     1cc <.debug_str+0x1cc>
 16d:	6c                   	insb   (%dx),%es:(%edi)
 16e:	6f                   	outsl  %ds:(%esi),(%dx)
 16f:	6f                   	outsl  %ds:(%esi),(%dx)
 170:	6b 75 70 00          	imul   $0x0,0x70(%ebp),%esi
	if (var->p == NULL) {
 174:	73 69                	jae    1df <.debug_str+0x1df>
 176:	7a 65                	jp     1dd <.debug_str+0x1dd>
 178:	5f                   	pop    %edi
		var->p = malloc(sizeof(unsigned long));
 179:	74 00                	je     17b <.debug_str+0x17b>
 17b:	68 65 78 33 32       	push   $0x32337865
 180:	5f                   	pop    %edi
 181:	67                   	addr16
 182:	65                   	gs
 183:	74 00                	je     185 <.debug_str+0x185>
 185:	5f                   	pop    %edi
 186:	49                   	dec    %ecx
 187:	53                   	push   %ebx
	}
	return 0;
}
 188:	78 64                	js     1ee <.debug_str+0x1ee>
 18a:	69 67 69 74 00 62 69 	imul   $0x69620074,0x69(%edi),%esp
 191:	6e                   	outsb  %ds:(%esi),(%dx)

	return 0;
}

int bin16_set(struct conf_var *var, const char *s)
{
 192:	36                   	ss
 193:	34 5f                	xor    $0x5f,%al
 195:	73 65                	jae    1fc <.debug_str+0x1fc>
 197:	74 00                	je     199 <.debug_str+0x199>
 199:	5f                   	pop    %edi
	if (var->p == NULL) {
 19a:	49                   	dec    %ecx
 19b:	4f                   	dec    %edi
 19c:	5f                   	pop    %edi
 19d:	72 65                	jb     204 <.debug_str+0x204>
 19f:	61                   	popa   
		var->p = malloc(sizeof(short int));
 1a0:	64                   	fs
 1a1:	5f                   	pop    %edi
 1a2:	62 61 73             	bound  %esp,0x73(%ecx)
 1a5:	65 00 73 74          	add    %dh,%gs:0x74(%ebx)
 1a9:	64 69 6e 00 5f 6e 65 78 	imul   $0x78656e5f,%fs:0x0(%esi),%ebp
	}

	return 0;
}
 1b1:	74 00                	je     1b3 <.debug_str+0x1b3>
 1b3:	69 6e 74 5f 73 65 74 	imul   $0x7465735f,0x74(%esi),%ebp

	return 0;
}

int bin8_set(struct conf_var *var, const char *s)
{
 1ba:	00 70 61             	add    %dh,0x61(%eax)
 1bd:	74 68                	je     227 <.debug_str+0x227>
 1bf:	00 5f 5f             	add    %bl,0x5f(%edi)
	if (var->p == NULL) {
 1c2:	66 6d                	insw   (%dx),%es:(%edi)
 1c4:	74 00                	je     1c6 <.debug_str+0x1c6>
 1c6:	5f                   	pop    %edi
		var->p = malloc(sizeof(unsigned char));
 1c7:	5f                   	pop    %edi
 1c8:	73 74                	jae    23e <.debug_str+0x23e>
 1ca:	72 65                	jb     231 <.debug_str+0x231>
 1cc:	61                   	popa   
 1cd:	6d                   	insl   (%dx),%es:(%edi)
 1ce:	00 5f 5f             	add    %bl,0x5f(%edi)
 1d1:	73 31                	jae    204 <.debug_str+0x204>
 1d3:	5f                   	pop    %edi
 1d4:	6c                   	insb   (%dx),%es:(%edi)
 1d5:	65 6e                	outsb  %gs:(%esi),(%dx)
	}

	return 0;
}
 1d7:	00 63 6f             	add    %ah,0x6f(%ebx)
 1da:	6e                   	outsb  %ds:(%esi),(%dx)
 1db:	66 5f                	pop    %di
 1dd:	76 61                	jbe    240 <.debug_str+0x240>
 1df:	72 00                	jb     1e1 <.debug_str+0x1e1>
{
	return write_section(stdout, root, NULL);
}

int void_get(struct conf_var *var, char *s)
{
 1e1:	76 61                	jbe    244 <.debug_str+0x244>
 1e3:	72 5f                	jb     244 <.debug_str+0x244>
 1e5:	73 65                	jae    24c <.debug_str+0x24c>
	if (var->p == NULL) {
 1e7:	74 00                	je     1e9 <.debug_str+0x1e9>
 1e9:	63 68 61             	arpl   %bp,0x61(%eax)
 1ec:	72 00                	jb     1ee <.debug_str+0x1ee>
 1ee:	5f                   	pop    %edi
 1ef:	6d                   	insl   (%dx),%es:(%edi)
 1f0:	6f                   	outsl  %ds:(%esi),(%dx)
 1f1:	64 65 00 5f 49       	fs add %bl,%fs:%gs:0x49(%edi)
 1f6:	4f                   	dec    %edi
 1f7:	5f                   	pop    %edi
 1f8:	6d                   	insl   (%dx),%es:(%edi)
 1f9:	61                   	popa   
 1fa:	72 6b                	jb     267 <.debug_str+0x267>
		sprintf(s, "NULL");
		return 0;
 1fc:	65                   	gs
 1fd:	72 00                	jb     1ff <.debug_str+0x1ff>
 1ff:	6f                   	outsl  %ds:(%esi),(%dx)
 200:	63 74 33 32          	arpl   %si,0x32(%ebx,%esi,1)
 204:	5f                   	pop    %edi
 205:	67                   	addr16
 206:	65                   	gs
 207:	74 00                	je     209 <.debug_str+0x209>
 209:	5f                   	pop    %edi
 20a:	49                   	dec    %ecx
 20b:	4f                   	dec    %edi
 20c:	5f                   	pop    %edi
 20d:	72 65                	jb     274 <.debug_str+0x274>
 20f:	61                   	popa   
 210:	64                   	fs
 211:	5f                   	pop    %edi
 212:	70 74                	jo     288 <.debug_str+0x288>
 214:	72 00                	jb     216 <.debug_str+0x216>
 216:	68 65 78 36 34       	push   $0x34367865
 21b:	5f                   	pop    %edi
 21c:	67                   	addr16
 21d:	65                   	gs
 21e:	74 00                	je     220 <.debug_str+0x220>
 220:	72 67                	jb     289 <.debug_str+0x289>
	}

	sprintf(s, "%p", var->p);
	return 1;
 222:	62 69 5f             	bound  %ebp,0x5f(%ecx)
 225:	67                   	addr16
 226:	65                   	gs
}
 227:	74 00                	je     229 <.debug_str+0x229>
 229:	72 67                	jb     292 <.debug_str+0x292>
	sscanf(s, "%p", &(var->p));
	return 1;
}

int int_get(struct conf_var *var, char *s)
{
 22b:	62 5f 73             	bound  %ebx,0x73(%edi)
 22e:	65                   	gs
 22f:	74 00                	je     231 <.debug_str+0x231>
 231:	74 5f                	je     292 <.debug_str+0x292>
	if (var->p == NULL) {
 233:	63 6f 64             	arpl   %bp,0x64(%edi)
 236:	65 00 62 69          	add    %ah,%gs:0x69(%edx)
 23a:	6e                   	outsb  %ds:(%esi),(%dx)
 23b:	33 32                	xor    (%edx),%esi
 23d:	5f                   	pop    %edi
 23e:	67                   	addr16
 23f:	65                   	gs
 240:	74 00                	je     242 <.debug_str+0x242>
 242:	73 74                	jae    2b8 <.debug_str+0x2b8>
 244:	64                   	fs
 245:	65                   	gs
 246:	72 72                	jb     2ba <.debug_str+0x2ba>
		sprintf(s, "NULL");
		return 0;
 248:	00 63 6f             	add    %ah,0x6f(%ebx)
 24b:	6e                   	outsb  %ds:(%esi),(%dx)
 24c:	66 5f                	pop    %di
 24e:	6c                   	insb   (%dx),%es:(%edi)
 24f:	6f                   	outsl  %ds:(%esi),(%dx)
 250:	61                   	popa   
 251:	64 00 5f 49          	add    %bl,%fs:0x49(%edi)
 255:	4f                   	dec    %edi
 256:	5f                   	pop    %edi
 257:	77 72                	ja     2cb <.debug_str+0x2cb>
 259:	69 74 65 5f 62 61 73 65 	imul   $0x65736162,0x5f(%ebp,%eiz,2),%esi
 261:	00 2f                	add    %ch,(%edi)
 263:	68 6f 6d 65 2f       	push   $0x2f656d6f
 268:	6a 6f                	push   $0x6f
 26a:	6e                   	outsb  %ds:(%esi),(%dx)
 26b:	61                   	popa   
 26c:	73 2f                	jae    29d <.debug_str+0x29d>
 26e:	44                   	inc    %esp
	}

	sprintf(s, "%i", *(int *) (var->p));
	return 1;
 26f:	6f                   	outsl  %ds:(%esi),(%dx)
 270:	63 75 6d             	arpl   %si,0x6d(%ebp)
 273:	65 6e                	outsb  %gs:(%esi),(%dx)
}
 275:	74 6f                	je     2e6 <.debug_str+0x2e6>
 277:	73 2f                	jae    2a8 <.debug_str+0x2a8>

	return 1;
}

int uint_get(struct conf_var *var, char *s)
{
 279:	72 65                	jb     2e0 <.debug_str+0x2e0>
 27b:	66                   	data16
 27c:	65                   	gs
 27d:	72 65                	jb     2e4 <.debug_str+0x2e4>
	if (var->p == NULL) {
 27f:	6e                   	outsb  %ds:(%esi),(%dx)
 280:	63 69 61             	arpl   %bp,0x61(%ecx)
 283:	73 2f                	jae    2b4 <.debug_str+0x2b4>
 285:	70 72                	jo     2f9 <.debug_str+0x2f9>
 287:	6f                   	outsl  %ds:(%esi),(%dx)
 288:	6a 65                	push   $0x65
 28a:	74 6f                	je     2fb <.debug_str+0x2fb>
 28c:	73 2d                	jae    2bb <.debug_str+0x2bb>
 28e:	64                   	fs
 28f:	65                   	gs
 290:	6d                   	insl   (%dx),%es:(%edi)
 291:	6f                   	outsl  %ds:(%esi),(%dx)
 292:	2f                   	das    
 293:	61                   	popa   
		sprintf(s, "NULL");
		return 0;
 294:	70 70                	jo     306 <.debug_str+0x306>
 296:	2d 74 65 6d 70       	sub    $0x706d6574,%eax
 29b:	6c                   	insb   (%dx),%es:(%edi)
 29c:	61                   	popa   
 29d:	74 65                	je     304 <.debug_str+0x304>
 29f:	2f                   	das    
 2a0:	63 6f 6e             	arpl   %bp,0x6e(%edi)
 2a3:	66                   	data16
 2a4:	00 6c 6f 6e          	add    %ch,0x6e(%edi,%ebp,2)
 2a8:	67 20 6c 6f          	and    %ch,0x6f(%si)
 2ac:	6e                   	outsb  %ds:(%esi),(%dx)
 2ad:	67 20 69 6e          	and    %ch,0x6e(%bx,%di)
 2b1:	74 00                	je     2b3 <.debug_str+0x2b3>
 2b3:	5f                   	pop    %edi
 2b4:	5f                   	pop    %edi
 2b5:	73 32                	jae    2e9 <.debug_str+0x2e9>
 2b7:	5f                   	pop    %edi
 2b8:	6c                   	insb   (%dx),%es:(%edi)
 2b9:	65 6e                	outsb  %gs:(%esi),(%dx)
 2bb:	00 5f 49             	add    %bl,0x49(%edi)
	}

	sprintf(s, "%u", *(unsigned int *) (var->p));
	return 1;
 2be:	4f                   	dec    %edi
 2bf:	5f                   	pop    %edi
 2c0:	73 61                	jae    323 <.debug_str+0x323>
}
 2c2:	76 65                	jbe    329 <.debug_str+0x329>
 2c4:	5f                   	pop    %edi

	return 1;
}

int float_get(struct conf_var *var, char *s)
{
 2c5:	62 61 73             	bound  %esp,0x73(%ecx)
 2c8:	65 00 5f 49          	add    %bl,%gs:0x49(%edi)
	if (var->p == NULL) {
 2cc:	53                   	push   %ebx
 2cd:	63 6e 74             	arpl   %bp,0x74(%esi)
 2d0:	72 6c                	jb     33e <.debug_str+0x33e>
 2d2:	00 69 70             	add    %ch,0x70(%ecx)
 2d5:	61                   	popa   
 2d6:	64                   	fs
 2d7:	64                   	fs
 2d8:	72 5f                	jb     339 <.debug_str+0x339>
 2da:	67                   	addr16
 2db:	65                   	gs
 2dc:	74 00                	je     2de <.debug_str+0x2de>
 2de:	68 65 78 31 36       	push   $0x36317865
 2e3:	5f                   	pop    %edi
 2e4:	73 65                	jae    34b <.debug_str+0x34b>
 2e6:	74 00                	je     2e8 <.debug_str+0x2e8>
 2e8:	6f                   	outsl  %ds:(%esi),(%dx)
 2e9:	63 74 31 36          	arpl   %si,0x36(%ecx,%esi,1)
 2ed:	5f                   	pop    %edi
 2ee:	73 65                	jae    355 <.debug_str+0x355>
 2f0:	74 00                	je     2f2 <.debug_str+0x2f2>
 2f2:	5f                   	pop    %edi
 2f3:	49                   	dec    %ecx
 2f4:	53                   	push   %ebx
 2f5:	64 69 67 69 74 00 6f 63 	imul   $0x636f0074,%fs:0x69(%edi),%esp
 2fd:	74 36                	je     335 <.debug_str+0x335>
 2ff:	34 5f                	xor    $0x5f,%al
 301:	67                   	addr16
 302:	65                   	gs
 303:	74 00                	je     305 <.debug_str+0x305>
 305:	5f                   	pop    %edi
 306:	5f                   	pop    %edi
 307:	71 75                	jno    37e <.debug_str+0x37e>
		sprintf(s, "NULL");
		return 0;
	}

	sprintf(s, "%f", *(double *) (var->p));
	return 1;
 309:	61                   	popa   
 30a:	64                   	fs
 30b:	5f                   	pop    %edi
 30c:	74 00                	je     30e <.debug_str+0x30e>
}
 30e:	5f                   	pop    %edi
 30f:	49                   	dec    %ecx
 310:	53                   	push   %ebx
 311:	73 70                	jae    383 <.debug_str+0x383>
	sscanf(s, "%lf", (double *) (var->p));
	return 1;
}

int string_get(struct conf_var *var, char *s)
{
 313:	61                   	popa   
 314:	63 65 00             	arpl   %sp,0x0(%ebp)
 317:	62 69 6e             	bound  %ebp,0x6e(%ecx)
	char * cp;			/* source */

	if (var->p == NULL) {
 31a:	36                   	ss
 31b:	34 5f                	xor    $0x5f,%al
 31d:	67                   	addr16
 31e:	65                   	gs
 31f:	74 00                	je     321 <.debug_str+0x321>
 321:	63 68 61             	arpl   %bp,0x61(%eax)
 324:	72 5f                	jb     385 <.debug_str+0x385>
 326:	73 65                	jae    38d <.debug_str+0x38d>
 328:	74 00                	je     32a <.debug_str+0x32a>
 32a:	5f                   	pop    %edi
 32b:	5f                   	pop    %edi
 32c:	70 61                	jo     38f <.debug_str+0x38f>
		sprintf(s, "NULL");
		return 0;
 32e:	64 31 00             	xor    %eax,%fs:(%eax)
 331:	5f                   	pop    %edi
 332:	5f                   	pop    %edi
 333:	70 61                	jo     396 <.debug_str+0x396>
 335:	64 32 00             	xor    %fs:(%eax),%al
 338:	5f                   	pop    %edi
 339:	5f                   	pop    %edi
 33a:	70 61                	jo     39d <.debug_str+0x39d>
 33c:	64 33 00             	xor    %fs:(%eax),%eax
 33f:	5f                   	pop    %edi
 340:	5f                   	pop    %edi
 341:	70 61                	jo     3a4 <.debug_str+0x3a4>
 343:	64                   	fs
 344:	34 00                	xor    $0x0,%al
 346:	5f                   	pop    %edi
 347:	5f                   	pop    %edi
 348:	70 61                	jo     3ab <.debug_str+0x3ab>
 34a:	64                   	fs
 34b:	35 00 73 74 72       	xor    $0x72747300,%eax
 350:	69 6e 67 5f 73 65 74 	imul   $0x7465735f,0x67(%esi),%ebp
	}

	cp = (char *)(var->p);
	sprintf(s, "\"%s\"", cp);

	return 1;
 357:	00 69 6e             	add    %ch,0x6e(%ecx)
}
 35a:	74 5f                	je     3bb <.debug_str+0x3bb>
 35c:	67                   	addr16

	return 1;
}

int bool_get(struct conf_var *var, char *s)
{
 35d:	65                   	gs
 35e:	74 00                	je     360 <.debug_str+0x360>
 360:	5f                   	pop    %edi
	if ((*(int *) (var->p)) == 0)
 361:	76 74                	jbe    3d7 <.debug_str+0x3d7>
 363:	61                   	popa   
 364:	62 6c 65 5f          	bound  %ebp,0x5f(%ebp,%eiz,2)
 368:	6f                   	outsl  %ds:(%esi),(%dx)
 369:	66                   	data16
 36a:	66                   	data16
 36b:	73 65                	jae    3d2 <.debug_str+0x3d2>
 36d:	74 00                	je     36f <.debug_str+0x36f>
 36f:	69 70 70 6f 72 74 5f 	imul   $0x5f74726f,0x70(%eax),%esi
 376:	73 65                	jae    3dd <.debug_str+0x3dd>
 378:	74 00                	je     37a <.debug_str+0x37a>
 37a:	66                   	data16
 37b:	67                   	addr16
 37c:	65                   	gs
 37d:	74 73                	je     3f2 <.debug_str+0x3f2>
 37f:	00 6c 6f 6e          	add    %ch,0x6e(%edi,%ebp,2)
 383:	67 20 64 6f          	and    %ah,0x6f(%si)
		sprintf(s, "False");
	else
		sprintf(s, "True");
	return 1;
}
 387:	75 62                	jne    3eb <.debug_str+0x3eb>
 389:	6c                   	insb   (%dx),%es:(%edi)
 38a:	65 00 73 70          	add    %dh,%gs:0x70(%ebx)

	return 0;
}

int char_get(struct conf_var *var, char *s)
{
 38e:	72 69                	jb     3f9 <.debug_str+0x3f9>
 390:	6e                   	outsb  %ds:(%esi),(%dx)
 391:	74 66                	je     3f9 <.debug_str+0x3f9>
	if (var->p == NULL) {
 393:	00 77 72             	add    %dh,0x72(%edi)
 396:	69 74 65 5f 73 65 63 74 	imul   $0x74636573,0x5f(%ebp,%eiz,2),%esi
 39e:	69 6f 6e 00 76 61 72 	imul   $0x72617600,0x6e(%edi),%ebp
 3a5:	5f                   	pop    %edi
 3a6:	67                   	addr16
		sprintf(s, "NULL");
		return 0;
 3a7:	65                   	gs
 3a8:	74 00                	je     3aa <.debug_str+0x3aa>
	}

	//printf("*** %s: var '%s' = '%c'\n", __FUNCTION__, var->name, *(char *)(var->p));

	sprintf(s, "%c", *(char *) (var->p));
 3aa:	62 6f 6f             	bound  %ebp,0x6f(%edi)
 3ad:	6c                   	insb   (%dx),%es:(%edi)
 3ae:	5f                   	pop    %edi
 3af:	73 65                	jae    416 <.debug_str+0x416>
 3b1:	74 00                	je     3b3 <.debug_str+0x3b3>
 3b3:	72 6f                	jb     424 <.debug_str+0x424>
 3b5:	6f                   	outsl  %ds:(%esi),(%dx)
 3b6:	74 00                	je     3b8 <.debug_str+0x3b8>
 3b8:	62 69 6e             	bound  %ebp,0x6e(%ecx)
 3bb:	31 36                	xor    %esi,(%esi)
 3bd:	5f                   	pop    %edi
 3be:	73 65                	jae    425 <.debug_str+0x425>
 3c0:	74 00                	je     3c2 <.debug_str+0x3c2>
 3c2:	5f                   	pop    %edi
 3c3:	49                   	dec    %ecx
 3c4:	53                   	push   %ebx
 3c5:	70 75                	jo     43c <.debug_str+0x43c>
 3c7:	6e                   	outsb  %ds:(%esi),(%dx)
 3c8:	63 74 00 5f          	arpl   %si,0x5f(%eax,%eax,1)
 3cc:	49                   	dec    %ecx
 3cd:	4f                   	dec    %edi
 3ce:	5f                   	pop    %edi
 3cf:	72 65                	jb     436 <.debug_str+0x436>
	return 1;
 3d1:	61                   	popa   
 3d2:	64                   	fs
 3d3:	5f                   	pop    %edi
 3d4:	65 6e                	outsb  %gs:(%esi),(%dx)
}
 3d6:	64 00 5f 49          	add    %bl,%fs:0x49(%edi)
	sscanf(cp, "%c", (char *) (var->p));
	return 1;
}

int hex8_get(struct conf_var *var, char *s)
{
 3da:	53                   	push   %ebx
 3db:	70 72                	jo     44f <.debug_str+0x44f>
 3dd:	69 6e 74 00 73 68 6f 	imul   $0x6f687300,0x74(%esi),%ebp
	if (var->p == NULL) {
 3e4:	72 74                	jb     45a <.debug_str+0x45a>
 3e6:	20 69 6e             	and    %ch,0x6e(%ecx)
 3e9:	74 00                	je     3eb <.debug_str+0x3eb>
 3eb:	53                   	push   %ebx
 3ec:	54                   	push   %esp
 3ed:	55                   	push   %ebp
 3ee:	42                   	inc    %edx
 3ef:	5f                   	pop    %edi
 3f0:	53                   	push   %ebx
 3f1:	54                   	push   %esp
 3f2:	52                   	push   %edx
 3f3:	49                   	dec    %ecx
 3f4:	4e                   	dec    %esi
		sprintf(s, "NULL");
		return 0;
 3f5:	47                   	inc    %edi
 3f6:	00 6c 6f 6e          	add    %ch,0x6e(%edi,%ebp,2)
	}

	sprintf(s, "0x%02X", *(unsigned char *) (var->p));
 3fa:	67 20 69 6e          	and    %ch,0x6e(%bx,%di)
 3fe:	74 00                	je     400 <.debug_str+0x400>
 400:	72 67                	jb     469 <.debug_str+0x469>
 402:	62 5f 67             	bound  %ebx,0x67(%edi)
 405:	65                   	gs
 406:	74 00                	je     408 <.debug_str+0x408>
 408:	71 75                	jno    47f <.debug_str+0x47f>
 40a:	6f                   	outsl  %ds:(%esi),(%dx)
 40b:	74 65                	je     472 <.debug_str+0x472>
 40d:	00 72 61             	add    %dh,0x61(%edx)
 410:	74 69                	je     47b <.debug_str+0x47b>
 412:	6f                   	outsl  %ds:(%esi),(%dx)
 413:	5f                   	pop    %edi
 414:	73 65                	jae    47b <.debug_str+0x47b>
 416:	74 00                	je     418 <.debug_str+0x418>
 418:	66                   	data16
 419:	70 72                	jo     48d <.debug_str+0x48d>
 41b:	69 6e 74 66 00 76 6f 	imul   $0x6f760066,0x74(%esi),%ebp
	return 1;
 422:	69 64 5f 67 65 74 00 63 	imul   $0x63007465,0x67(%edi,%ebx,2),%esp
	sscanf(s, "%X", (unsigned int *) (var->p));
	return 1;
}

int hex16_get(struct conf_var *var, char *s)
{
 42a:	79 6d                	jns    499 <.debug_str+0x499>
 42c:	6b 5f 73 65          	imul   $0x65,0x73(%edi),%ebx
	if (var->p == NULL) {
 430:	74 00                	je     432 <.debug_str+0x432>
 432:	73 65                	jae    499 <.debug_str+0x499>
 434:	63 74 69 6f          	arpl   %si,0x6f(%ecx,%ebp,2)
 438:	6e                   	outsb  %ds:(%esi),(%dx)
 439:	00 5f 49             	add    %bl,0x49(%edi)
 43c:	53                   	push   %ebx
 43d:	67 72 61             	addr16 jb 4a1 <.debug_str+0x4a1>
 440:	70 68                	jo     4aa <.debug_str+0x4aa>
 442:	00 6e 61             	add    %ch,0x61(%esi)
 445:	6d                   	insl   (%dx),%es:(%edi)
 446:	65 00 75 69          	add    %dh,%gs:0x69(%ebp)
 44a:	6e                   	outsb  %ds:(%esi),(%dx)
 44b:	74 5f                	je     4ac <.debug_str+0x4ac>
 44d:	73 65                	jae    4b4 <.debug_str+0x4b4>
 44f:	74 00                	je     451 <.debug_str+0x451>
 451:	68 65 78 31 36       	push   $0x36317865
 456:	5f                   	pop    %edi
 457:	67                   	addr16
 458:	65                   	gs
 459:	74 00                	je     45b <.debug_str+0x45b>
 45b:	6f                   	outsl  %ds:(%esi),(%dx)
 45c:	63 74 31 36          	arpl   %si,0x36(%ecx,%esi,1)
 460:	5f                   	pop    %edi
 461:	67                   	addr16
 462:	65                   	gs
 463:	74 00                	je     465 <.debug_str+0x465>
 465:	5f                   	pop    %edi
 466:	6c                   	insb   (%dx),%es:(%edi)
 467:	6f                   	outsl  %ds:(%esi),(%dx)
 468:	63 6b 00             	arpl   %bp,0x0(%ebx)
		sprintf(s, "NULL");
		return 0;
	}

	sprintf(s, "0x%04X", *(unsigned int *) (var->p));
	return 1;
 46b:	63 6f 6e             	arpl   %bp,0x6e(%edi)
 46e:	66                   	data16
 46f:	2e 63 00             	arpl   %ax,%cs:(%eax)
}
 472:	6c                   	insb   (%dx),%es:(%edi)
 473:	6f                   	outsl  %ds:(%esi),(%dx)
	sscanf(s, "%X", (unsigned int *) (var->p));
	return 1;
}

int hex32_get(struct conf_var *var, char *s)
{
 474:	6e                   	outsb  %ds:(%esi),(%dx)
 475:	67 20 75 6e          	and    %dh,0x6e(%di)
 479:	73 69                	jae    4e4 <.debug_str+0x4e4>
	if (var->p == NULL) {
 47b:	67 6e                	outsb  %ds:(%si),(%dx)
 47d:	65 64 20 69 6e       	gs and %ch,%fs:%gs:0x6e(%ecx)
 482:	74 00                	je     484 <.debug_str+0x484>
 484:	5f                   	pop    %edi
 485:	6f                   	outsl  %ds:(%esi),(%dx)
 486:	6c                   	insb   (%dx),%es:(%edi)
 487:	64                   	fs
 488:	5f                   	pop    %edi
 489:	6f                   	outsl  %ds:(%esi),(%dx)
 48a:	66                   	data16
 48b:	66                   	data16
 48c:	73 65                	jae    4f3 <.debug_str+0x4f3>
 48e:	74 00                	je     490 <.debug_str+0x490>
		sprintf(s, "NULL");
		return 0;
 490:	5f                   	pop    %edi
 491:	49                   	dec    %ecx
 492:	4f                   	dec    %edi
 493:	5f                   	pop    %edi
 494:	46                   	inc    %esi
 495:	49                   	dec    %ecx
 496:	4c                   	dec    %esp
 497:	45                   	inc    %ebp
 498:	00 71 75             	add    %dh,0x75(%ecx)
 49b:	65                   	gs
 49c:	75 65                	jne    503 <.debug_str+0x503>
 49e:	00 5f 49             	add    %bl,0x49(%edi)
 4a1:	53                   	push   %ebx
 4a2:	61                   	popa   
 4a3:	6c                   	insb   (%dx),%es:(%edi)
 4a4:	70 68                	jo     50e <.debug_str+0x50e>
 4a6:	61                   	popa   
 4a7:	00 47 4e             	add    %al,0x4e(%edi)
 4aa:	55                   	push   %ebp
 4ab:	20 43 20             	and    %al,0x20(%ebx)
 4ae:	34 2e                	xor    $0x2e,%al
 4b0:	36 2e 33 00          	ss xor %cs:%ss:(%eax),%eax
 4b4:	63 68 61             	arpl   %bp,0x61(%eax)
 4b7:	72 5f                	jb     518 <.debug_str+0x518>
	}

	sprintf(s, "0x%08X", *(unsigned int *) (var->p));
	return 1;
 4b9:	67                   	addr16
 4ba:	65                   	gs
 4bb:	74 00                	je     4bd <.debug_str+0x4bd>
}
 4bd:	74 5f                	je     51e <.debug_str+0x51e>
 4bf:	67                   	addr16
 4c0:	65                   	gs
	sscanf(s, "%X", (unsigned int *) (var->p));
	return 1;
}

int hex64_get(struct conf_var *var, char *s)
{
 4c1:	74 00                	je     4c3 <.debug_str+0x4c3>
 4c3:	65 6e                	outsb  %gs:(%esi),(%dx)
 4c5:	74 72                	je     539 <.debug_str+0x539>
 4c7:	79 00                	jns    4c9 <.debug_str+0x4c9>
	if (var->p == NULL) {
 4c9:	68 65 78 38 5f       	push   $0x5f387865
 4ce:	73 65                	jae    535 <.debug_str+0x535>
 4d0:	74 00                	je     4d2 <.debug_str+0x4d2>
 4d2:	73 74                	jae    548 <.debug_str+0x548>
 4d4:	72 69                	jb     53f <.debug_str+0x53f>
 4d6:	6e                   	outsb  %ds:(%esi),(%dx)
 4d7:	67 5f                	addr16 pop %edi
 4d9:	67                   	addr16
 4da:	65                   	gs
 4db:	74 00                	je     4dd <.debug_str+0x4dd>
 4dd:	74 79                	je     558 <.debug_str+0x558>
		sprintf(s, "NULL");
		return 0;
 4df:	70 65                	jo     546 <.debug_str+0x546>
 4e1:	00 63 6f             	add    %ah,0x6f(%ebx)
 4e4:	6e                   	outsb  %ds:(%esi),(%dx)
 4e5:	66 5f                	pop    %di
 4e7:	73 61                	jae    54a <.debug_str+0x54a>
 4e9:	76 65                	jbe    550 <.debug_str+0x550>
 4eb:	00 75 6e             	add    %dh,0x6e(%ebp)
 4ee:	73 69                	jae    559 <.debug_str+0x559>
 4f0:	67 6e                	outsb  %ds:(%si),(%dx)
 4f2:	65 64 20 63 68       	gs and %ah,%fs:%gs:0x68(%ebx)
 4f7:	61                   	popa   
 4f8:	72 00                	jb     4fa <.debug_str+0x4fa>
 4fa:	66                   	data16
 4fb:	6c                   	insb   (%dx),%es:(%edi)
 4fc:	6f                   	outsl  %ds:(%esi),(%dx)
 4fd:	61                   	popa   
 4fe:	74 5f                	je     55f <.debug_str+0x55f>
 500:	73 65                	jae    567 <.debug_str+0x567>
 502:	74 00                	je     504 <.debug_str+0x504>
 504:	5f                   	pop    %edi
 505:	73 62                	jae    569 <.debug_str+0x569>
 507:	75 66                	jne    56f <.debug_str+0x56f>
 509:	00 6c 69 6e          	add    %ch,0x6e(%ecx,%ebp,2)
	}

	sprintf(s, "0x%016llX", *(unsigned long long int *) (var->p));

	return 1;
 50d:	65 00 74 5f 6e       	add    %dh,%gs:0x6e(%edi,%ebx,2)
}
 512:	61                   	popa   
 513:	6d                   	insl   (%dx),%es:(%edi)
 514:	65 00 5f 5f          	add    %bl,%gs:0x5f(%edi)

	return 1;
}

int bin8_get(struct conf_var *var, char *s)
{
 518:	73 72                	jae    58c <.debug_str+0x58c>
 51a:	63 00                	arpl   %ax,(%eax)
	if (var->p == NULL) {
 51c:	5f                   	pop    %edi
 51d:	49                   	dec    %ecx
 51e:	4f                   	dec    %edi
 51f:	5f                   	pop    %edi
 520:	77 72                	ja     594 <.debug_str+0x594>
 522:	69 74 65 5f 70 74 72 00 	imul   $0x727470,0x5f(%ebp,%eiz,2),%esi
 52a:	69 70 70 6f 72 74 5f 	imul   $0x5f74726f,0x70(%eax),%esi
		return 0;
	}
	s = "";

	return 0;
}
 531:	67                   	addr16
 532:	65                   	gs
 533:	74 00                	je     535 <.debug_str+0x535>

	return 0;
}

int bin16_get(struct conf_var *var, char *s)
{
 535:	74 61                	je     598 <.debug_str+0x598>
 537:	69 6c 00 62 69 6e 38 5f 	imul   $0x5f386e69,0x62(%eax,%eax,1),%ebp
	if (var->p == NULL) {
 53f:	73 65                	jae    5a6 <.debug_str+0x5a6>
 541:	74 00                	je     543 <.debug_str+0x543>
 543:	6f                   	outsl  %ds:(%esi),(%dx)
 544:	63 74 38 5f          	arpl   %si,0x5f(%eax,%edi,1)
 548:	73 65                	jae    5af <.debug_str+0x5af>
 54a:	74 00                	je     54c <.debug_str+0x54c>
 54c:	5f                   	pop    %edi
		return 0;
	}
	s = "";

	return 0;
}
 54d:	49                   	dec    %ecx
 54e:	53                   	push   %ebx
 54f:	61                   	popa   
 550:	6c                   	insb   (%dx),%es:(%edi)
 551:	6e                   	outsb  %ds:(%esi),(%dx)
 552:	75 6d                	jne    5c1 <.debug_str+0x5c1>

	return 0;
}

int bin32_get(struct conf_var *var, char *s)
{
 554:	00 73 74             	add    %dh,0x74(%ebx)
	if (var->p == NULL) {
 557:	64 6f                	outsl  %fs:(%esi),(%dx)
 559:	75 74                	jne    5cf <.debug_str+0x5cf>
 55b:	00 62 6f             	add    %ah,0x6f(%edx)
 55e:	6f                   	outsl  %ds:(%esi),(%dx)
 55f:	6c                   	insb   (%dx),%es:(%edi)
 560:	5f                   	pop    %edi
 561:	67                   	addr16
 562:	65                   	gs
 563:	74 00                	je     565 <.debug_str+0x565>
 565:	62 69 6e             	bound  %ebp,0x6e(%ecx)
 568:	31 36                	xor    %esi,(%esi)
 56a:	5f                   	pop    %edi
		return 0;
	}
	s = "";

	return 0;
}
 56b:	67                   	addr16
 56c:	65                   	gs
 56d:	74 00                	je     56f <.debug_str+0x56f>
 56f:	5f                   	pop    %edi
 570:	5f                   	pop    %edi

	return 0;
}

int oct8_get(struct conf_var *var, char *s)
{
 571:	6f                   	outsl  %ds:(%esi),(%dx)
 572:	66 66 5f             	data32 pop %di
	if (var->p == NULL) {
 575:	74 00                	je     577 <.debug_str+0x577>
 577:	5f                   	pop    %edi
 578:	49                   	dec    %ecx
 579:	53                   	push   %ebx
 57a:	62 6c 61 6e          	bound  %ebp,0x6e(%ecx,%eiz,2)
 57e:	6b 00 73             	imul   $0x73,(%eax),%eax
 581:	69 67 6e 65 64 20 63 	imul   $0x63206465,0x6e(%edi),%esp
 588:	68 61 72 00 73       	push   $0x73007261
		return 0;
	}
	s = "";

	return 0;
}
 58d:	68 6f 72 74 20       	push   $0x2074726f

	return 0;
}

int oct16_get(struct conf_var *var, char *s)
{
 592:	75 6e                	jne    602 <.debug_str+0x602>
	if (var->p == NULL) {
 594:	73 69                	jae    5ff <.debug_str+0x5ff>
 596:	67 6e                	outsb  %ds:(%si),(%dx)
 598:	65 64 20 69 6e       	gs and %ch,%fs:%gs:0x6e(%ecx)
 59d:	74 00                	je     59f <.debug_str+0x59f>
 59f:	64 6f                	outsl  %fs:(%esi),(%dx)
 5a1:	75 62                	jne    605 <.debug_str+0x605>
 5a3:	6c                   	insb   (%dx),%es:(%edi)
 5a4:	65 00 5f 63          	add    %bl,%gs:0x63(%edi)
		return 0;
	}
	s = "";

	return 0;
}
 5a8:	68 61 69 6e 00       	push   $0x6e6961

	return 0;
}

int oct64_get(struct conf_var *var, char *s)
{
 5ad:	5f                   	pop    %edi
 5ae:	49                   	dec    %ecx
 5af:	53                   	push   %ebx
 5b0:	75 70                	jne    622 <cymk_get+0x1b>
	if (var->p == NULL) {
 5b2:	70 65                	jo     619 <cymk_get+0x12>
 5b4:	72 00                	jb     5b6 <.debug_str+0x5b6>
 5b6:	72 61                	jb     619 <cymk_get+0x12>
 5b8:	74 69                	je     623 <cymk_get+0x1c>
 5ba:	6f                   	outsl  %ds:(%esi),(%dx)
 5bb:	5f                   	pop    %edi
 5bc:	67                   	addr16
 5bd:	65                   	gs
 5be:	74 00                	je     5c0 <.debug_str+0x5c0>
 5c0:	46                   	inc    %esi
 5c1:	49                   	dec    %ecx
 5c2:	4c                   	dec    %esp
 5c3:	45                   	inc    %ebp
 5c4:	00 5f 66             	add    %bl,0x66(%edi)
		return 0;
	}
	s = "";

	return 0;
}
 5c7:	6c                   	insb   (%dx),%es:(%edi)
 5c8:	61                   	popa   
 5c9:	67 73 32             	addr16 jae 5fe <.debug_str+0x5fe>

	return 0;
}

int rgb_get(struct conf_var *var, char *s)
{
 5cc:	00 5f 63             	add    %bl,0x63(%edi)
	if (var->p == NULL) {
 5cf:	75 72                	jne    643 <hex64_set>
 5d1:	5f                   	pop    %edi
 5d2:	63 6f 6c             	arpl   %bp,0x6c(%edi)
 5d5:	75 6d                	jne    644 <hex64_set+0x1>
 5d7:	6e                   	outsb  %ds:(%esi),(%dx)
 5d8:	00 74 5f 73          	add    %dh,0x73(%edi,%ebx,2)
 5dc:	65                   	gs
 5dd:	74 00                	je     5df <.debug_str+0x5df>
 5df:	76 61                	jbe    642 <ratio_get+0x1d>
 5e1:	6c                   	insb   (%dx),%es:(%edi)
 5e2:	75 65                	jne    649 <hex64_set+0x6>
		return 0;
	}
	s = "";

	return 0;
}
 5e4:	00 63 79             	add    %ah,0x79(%ebx)
 5e7:	6d                   	insl   (%dx),%es:(%edi)
 5e8:	6b 5f 67 65          	imul   $0x65,0x67(%edi),%ebx

	return 0;
}

int rgbi_get(struct conf_var *var, char *s)
{
 5ec:	74 00                	je     5ee <.debug_str+0x5ee>
	if (var->p == NULL) {
 5ee:	5f                   	pop    %edi
 5ef:	5f                   	pop    %edi
 5f0:	6f                   	outsl  %ds:(%esi),(%dx)
 5f1:	66                   	data16
 5f2:	66                   	data16
 5f3:	36                   	ss
 5f4:	34 5f                	xor    $0x5f,%al
 5f6:	74 00                	je     5f8 <.debug_str+0x5f8>
 5f8:	5f                   	pop    %edi
 5f9:	75 6e                	jne    669 <hex64_set+0x26>
 5fb:	75 73                	jne    670 <hex64_set+0x2d>
 5fd:	65 64 32 00          	gs xor %fs:%gs:(%eax),%al
		return 0;
	}
	s = "";

	return 0;
}
 601:	5f                   	pop    %edi
 602:	49                   	dec    %ecx
 603:	4f                   	dec    %edi
 604:	5f                   	pop    %edi
 605:	62 75 66             	bound  %esi,0x66(%ebp)

	return 0;
}

int cymk_get(struct conf_var *var, char *s)
{
 608:	5f                   	pop    %edi
 609:	62 61 73             	bound  %esp,0x73(%ecx)
	if (var->p == NULL) {
 60c:	65 00 75 69          	add    %dh,%gs:0x69(%ebp)
 610:	6e                   	outsb  %ds:(%esi),(%dx)
 611:	74 5f                	je     672 <hex64_set+0x2f>
 613:	67                   	addr16
 614:	65                   	gs
 615:	74 00                	je     617 <cymk_get+0x10>

Disassembly of section .comment:

00000000 <.comment>:
int bin64_get(struct conf_var *var, char *s)
{
	s = "";

	return 0;
}
   0:	00 47 43             	add    %al,0x43(%edi)
   3:	43                   	inc    %ebx
   4:	3a 20                	cmp    (%eax),%ah
int oct32_get(struct conf_var *var, char *s)
{
	s = "";

	return 0;
}
   6:	28 55 62             	sub    %dl,0x62(%ebp)
   9:	75 6e                	jne    79 <rgbi_set+0x1f>
   b:	74 75                	je     82 <rgb_set+0x1>

	return 0;
}

int ratio_set(struct conf_var *var, const char *s)
{
   d:	2f                   	das    
   e:	4c                   	dec    %esp
   f:	69 6e 61 72 6f 20 34 	imul   $0x34206f72,0x61(%esi),%ebp
	if (var->p == NULL) {
  16:	2e 36 2e 33 2d 31 75 62 75 	cs ss xor %cs:%ss:0x75627531,%ebp
		var->p = malloc(2 * sizeof(int));
  1f:	6e                   	outsb  %ds:(%esi),(%dx)
  20:	74 75                	je     97 <rgb_set+0x16>
  22:	35 29 20 34 2e       	xor    $0x2e342029,%eax
  27:	36 2e 33 00          	ss xor %cs:%ss:(%eax),%eax

Disassembly of section .eh_frame:

00000000 <.eh_frame>:
   0:	14 00                	adc    $0x0,%al
   2:	00 00                	add    %al,(%eax)
   4:	00 00                	add    %al,(%eax)
   6:	00 00                	add    %al,(%eax)
   8:	01 7a 52             	add    %edi,0x52(%edx)
   b:	00 01                	add    %al,(%ecx)
   d:	7c 08                	jl     17 <.eh_frame+0x17>
   f:	01 1b                	add    %ebx,(%ebx)
  11:	0c 04                	or     $0x4,%al
  13:	04 88                	add    $0x88,%al
  15:	01 00                	add    %eax,(%eax)
  17:	00 10                	add    %dl,(%eax)
  19:	00 00                	add    %al,(%eax)
  1b:	00 1c 00             	add    %bl,(%eax,%eax,1)
  1e:	00 00                	add    %al,(%eax)
  20:	00 00                	add    %al,(%eax)	20: R_386_PC32	.text
  22:	00 00                	add    %al,(%eax)
  24:	06                   	push   %es
  25:	00 00                	add    %al,(%eax)
  27:	00 00                	add    %al,(%eax)
  29:	00 00                	add    %al,(%eax)
  2b:	00 10                	add    %dl,(%eax)
  2d:	00 00                	add    %al,(%eax)
  2f:	00 30                	add    %dh,(%eax)
  31:	00 00                	add    %al,(%eax)
  33:	00 06                	add    %al,(%esi)	34: R_386_PC32	.text
  35:	00 00                	add    %al,(%eax)
  37:	00 06                	add    %al,(%esi)
  39:	00 00                	add    %al,(%eax)
  3b:	00 00                	add    %al,(%eax)
  3d:	00 00                	add    %al,(%eax)
  3f:	00 1c 00             	add    %bl,(%eax,%eax,1)
  42:	00 00                	add    %al,(%eax)
  44:	44                   	inc    %esp
  45:	00 00                	add    %al,(%eax)
  47:	00 0c 00             	add    %cl,(%eax,%eax,1)	48: R_386_PC32	.text
  4a:	00 00                	add    %al,(%eax)
  4c:	27                   	daa    
  4d:	00 00                	add    %al,(%eax)
  4f:	00 00                	add    %al,(%eax)
  51:	41                   	inc    %ecx
  52:	0e                   	push   %cs
  53:	08 83 02 43 0e 20    	or     %al,0x200e4302(%ebx)
  59:	61                   	popa   
  5a:	0e                   	push   %cs
  5b:	08 41 0e             	or     %al,0xe(%ecx)
  5e:	04 c3                	add    $0xc3,%al
  60:	1c 00                	sbb    $0x0,%al
  62:	00 00                	add    %al,(%eax)
  64:	64 00 00             	add    %al,%fs:(%eax)
  67:	00 33                	add    %dh,(%ebx)	68: R_386_PC32	.text
  69:	00 00                	add    %al,(%eax)
  6b:	00 27                	add    %ah,(%edi)
  6d:	00 00                	add    %al,(%eax)
  6f:	00 00                	add    %al,(%eax)
  71:	41                   	inc    %ecx
  72:	0e                   	push   %cs
  73:	08 83 02 43 0e 20    	or     %al,0x200e4302(%ebx)
  79:	61                   	popa   
  7a:	0e                   	push   %cs
  7b:	08 41 0e             	or     %al,0xe(%ecx)
  7e:	04 c3                	add    $0xc3,%al
  80:	1c 00                	sbb    $0x0,%al
  82:	00 00                	add    %al,(%eax)
  84:	84 00                	test   %al,(%eax)
  86:	00 00                	add    %al,(%eax)
  88:	5a                   	pop    %edx	88: R_386_PC32	.text
  89:	00 00                	add    %al,(%eax)
  8b:	00 27                	add    %ah,(%edi)
  8d:	00 00                	add    %al,(%eax)
  8f:	00 00                	add    %al,(%eax)
  91:	41                   	inc    %ecx
  92:	0e                   	push   %cs
  93:	08 83 02 43 0e 20    	or     %al,0x200e4302(%ebx)
  99:	61                   	popa   
  9a:	0e                   	push   %cs
  9b:	08 41 0e             	or     %al,0xe(%ecx)
  9e:	04 c3                	add    $0xc3,%al
  a0:	1c 00                	sbb    $0x0,%al
  a2:	00 00                	add    %al,(%eax)
  a4:	a4                   	movsb  %ds:(%esi),%es:(%edi)
  a5:	00 00                	add    %al,(%eax)
  a7:	00 81 00 00 00 27    	add    %al,0x27000000(%ecx)	a8: R_386_PC32	.text
  ad:	00 00                	add    %al,(%eax)
  af:	00 00                	add    %al,(%eax)
  b1:	41                   	inc    %ecx
  b2:	0e                   	push   %cs
  b3:	08 83 02 43 0e 20    	or     %al,0x200e4302(%ebx)
  b9:	61                   	popa   
  ba:	0e                   	push   %cs
  bb:	08 41 0e             	or     %al,0xe(%ecx)
  be:	04 c3                	add    $0xc3,%al
  c0:	1c 00                	sbb    $0x0,%al
  c2:	00 00                	add    %al,(%eax)
  c4:	c4 00                	les    (%eax),%eax
  c6:	00 00                	add    %al,(%eax)
  c8:	a8 00                	test   $0x0,%al	c8: R_386_PC32	.text
  ca:	00 00                	add    %al,(%eax)
  cc:	27                   	daa    
  cd:	00 00                	add    %al,(%eax)
  cf:	00 00                	add    %al,(%eax)
  d1:	41                   	inc    %ecx
  d2:	0e                   	push   %cs
  d3:	08 83 02 43 0e 20    	or     %al,0x200e4302(%ebx)
  d9:	61                   	popa   
  da:	0e                   	push   %cs
  db:	08 41 0e             	or     %al,0xe(%ecx)
  de:	04 c3                	add    $0xc3,%al
  e0:	1c 00                	sbb    $0x0,%al
  e2:	00 00                	add    %al,(%eax)
  e4:	e4 00                	in     $0x0,%al
  e6:	00 00                	add    %al,(%eax)
  e8:	cf                   	iret   	e8: R_386_PC32	.text
  e9:	00 00                	add    %al,(%eax)
  eb:	00 27                	add    %ah,(%edi)
  ed:	00 00                	add    %al,(%eax)
  ef:	00 00                	add    %al,(%eax)
  f1:	41                   	inc    %ecx
  f2:	0e                   	push   %cs
  f3:	08 83 02 43 0e 20    	or     %al,0x200e4302(%ebx)
  f9:	61                   	popa   
  fa:	0e                   	push   %cs
  fb:	08 41 0e             	or     %al,0xe(%ecx)
  fe:	04 c3                	add    $0xc3,%al
 100:	1c 00                	sbb    $0x0,%al
 102:	00 00                	add    %al,(%eax)
 104:	04 01                	add    $0x1,%al
 106:	00 00                	add    %al,(%eax)
 108:	f6 00 00             	testb  $0x0,(%eax)	108: R_386_PC32	.text
 10b:	00 27                	add    %ah,(%edi)
 10d:	00 00                	add    %al,(%eax)
 10f:	00 00                	add    %al,(%eax)
 111:	41                   	inc    %ecx
 112:	0e                   	push   %cs
 113:	08 83 02 43 0e 20    	or     %al,0x200e4302(%ebx)
 119:	61                   	popa   
 11a:	0e                   	push   %cs
 11b:	08 41 0e             	or     %al,0xe(%ecx)
 11e:	04 c3                	add    $0xc3,%al
 120:	1c 00                	sbb    $0x0,%al
 122:	00 00                	add    %al,(%eax)
 124:	24 01                	and    $0x1,%al
 126:	00 00                	add    %al,(%eax)
 128:	1d 01 00 00 27       	sbb    $0x27000001,%eax	128: R_386_PC32	.text
 12d:	00 00                	add    %al,(%eax)
 12f:	00 00                	add    %al,(%eax)
 131:	41                   	inc    %ecx
 132:	0e                   	push   %cs
 133:	08 83 02 43 0e 20    	or     %al,0x200e4302(%ebx)
 139:	61                   	popa   
 13a:	0e                   	push   %cs
 13b:	08 41 0e             	or     %al,0xe(%ecx)
 13e:	04 c3                	add    $0xc3,%al
 140:	1c 00                	sbb    $0x0,%al
 142:	00 00                	add    %al,(%eax)
 144:	44                   	inc    %esp
 145:	01 00                	add    %eax,(%eax)
 147:	00 44 01 00          	add    %al,0x0(%ecx,%eax,1)	148: R_386_PC32	.text
 14b:	00 27                	add    %ah,(%edi)
 14d:	00 00                	add    %al,(%eax)
 14f:	00 00                	add    %al,(%eax)
 151:	41                   	inc    %ecx
 152:	0e                   	push   %cs
 153:	08 83 02 43 0e 20    	or     %al,0x200e4302(%ebx)
 159:	61                   	popa   
 15a:	0e                   	push   %cs
 15b:	08 41 0e             	or     %al,0xe(%ecx)
 15e:	04 c3                	add    $0xc3,%al
 160:	1c 00                	sbb    $0x0,%al
 162:	00 00                	add    %al,(%eax)
 164:	64 01 00             	add    %eax,%fs:(%eax)
 167:	00 6b 01             	add    %ch,0x1(%ebx)	168: R_386_PC32	.text
 16a:	00 00                	add    %al,(%eax)
 16c:	27                   	daa    
 16d:	00 00                	add    %al,(%eax)
 16f:	00 00                	add    %al,(%eax)
 171:	41                   	inc    %ecx
 172:	0e                   	push   %cs
 173:	08 83 02 43 0e 20    	or     %al,0x200e4302(%ebx)
 179:	61                   	popa   
 17a:	0e                   	push   %cs
 17b:	08 41 0e             	or     %al,0xe(%ecx)
 17e:	04 c3                	add    $0xc3,%al
 180:	1c 00                	sbb    $0x0,%al
 182:	00 00                	add    %al,(%eax)
 184:	84 01                	test   %al,(%ecx)
 186:	00 00                	add    %al,(%eax)
 188:	92                   	xchg   %eax,%edx	188: R_386_PC32	.text
 189:	01 00                	add    %eax,(%eax)
 18b:	00 27                	add    %ah,(%edi)
 18d:	00 00                	add    %al,(%eax)
 18f:	00 00                	add    %al,(%eax)
 191:	41                   	inc    %ecx
 192:	0e                   	push   %cs
 193:	08 83 02 43 0e 20    	or     %al,0x200e4302(%ebx)
 199:	61                   	popa   
 19a:	0e                   	push   %cs
 19b:	08 41 0e             	or     %al,0xe(%ecx)
 19e:	04 c3                	add    $0xc3,%al
 1a0:	1c 00                	sbb    $0x0,%al
 1a2:	00 00                	add    %al,(%eax)
 1a4:	a4                   	movsb  %ds:(%esi),%es:(%edi)
 1a5:	01 00                	add    %eax,(%eax)
 1a7:	00 b9 01 00 00 27    	add    %bh,0x27000001(%ecx)	1a8: R_386_PC32	.text
 1ad:	00 00                	add    %al,(%eax)
 1af:	00 00                	add    %al,(%eax)
 1b1:	41                   	inc    %ecx
 1b2:	0e                   	push   %cs
 1b3:	08 83 02 43 0e 20    	or     %al,0x200e4302(%ebx)
 1b9:	61                   	popa   
 1ba:	0e                   	push   %cs
 1bb:	08 41 0e             	or     %al,0xe(%ecx)
 1be:	04 c3                	add    $0xc3,%al
 1c0:	14 00                	adc    $0x0,%al
 1c2:	00 00                	add    %al,(%eax)
 1c4:	c4 01                	les    (%ecx),%eax
 1c6:	00 00                	add    %al,(%eax)
 1c8:	e0 01                	loopne 1cb <.eh_frame+0x1cb>	1c8: R_386_PC32	.text
 1ca:	00 00                	add    %al,(%eax)
 1cc:	4b                   	dec    %ebx
 1cd:	00 00                	add    %al,(%eax)
 1cf:	00 00                	add    %al,(%eax)
 1d1:	43                   	inc    %ebx
 1d2:	0e                   	push   %cs
 1d3:	30 02                	xor    %al,(%edx)
 1d5:	47                   	inc    %edi
 1d6:	0e                   	push   %cs
 1d7:	04 14                	add    $0x14,%al
 1d9:	00 00                	add    %al,(%eax)
 1db:	00 dc                	add    %bl,%ah
 1dd:	01 00                	add    %eax,(%eax)
 1df:	00 2b                	add    %ch,(%ebx)	1e0: R_386_PC32	.text
 1e1:	02 00                	add    (%eax),%al
 1e3:	00 4d 00             	add    %cl,0x0(%ebp)
 1e6:	00 00                	add    %al,(%eax)
 1e8:	00 43 0e             	add    %al,0xe(%ebx)
 1eb:	30 02                	xor    %al,(%edx)
 1ed:	49                   	dec    %ecx
 1ee:	0e                   	push   %cs
 1ef:	04 14                	add    $0x14,%al
 1f1:	00 00                	add    %al,(%eax)
 1f3:	00 f4                	add    %dh,%ah
 1f5:	01 00                	add    %eax,(%eax)
 1f7:	00 78 02             	add    %bh,0x2(%eax)	1f8: R_386_PC32	.text
 1fa:	00 00                	add    %al,(%eax)
 1fc:	4d                   	dec    %ebp
 1fd:	00 00                	add    %al,(%eax)
 1ff:	00 00                	add    %al,(%eax)
 201:	43                   	inc    %ebx
 202:	0e                   	push   %cs
 203:	30 02                	xor    %al,(%edx)
 205:	49                   	dec    %ecx
 206:	0e                   	push   %cs
 207:	04 14                	add    $0x14,%al
 209:	00 00                	add    %al,(%eax)
 20b:	00 0c 02             	add    %cl,(%edx,%eax,1)
 20e:	00 00                	add    %al,(%eax)
 210:	c5 02                	lds    (%edx),%eax	210: R_386_PC32	.text
 212:	00 00                	add    %al,(%eax)
 214:	4d                   	dec    %ebp
 215:	00 00                	add    %al,(%eax)
 217:	00 00                	add    %al,(%eax)
 219:	43                   	inc    %ebx
 21a:	0e                   	push   %cs
 21b:	30 02                	xor    %al,(%edx)
 21d:	49                   	dec    %ecx
 21e:	0e                   	push   %cs
 21f:	04 14                	add    $0x14,%al
 221:	00 00                	add    %al,(%eax)
 223:	00 24 02             	add    %ah,(%edx,%eax,1)
 226:	00 00                	add    %al,(%eax)
 228:	12 03                	adc    (%ebx),%al	228: R_386_PC32	.text
 22a:	00 00                	add    %al,(%eax)
 22c:	4b                   	dec    %ebx
 22d:	00 00                	add    %al,(%eax)
 22f:	00 00                	add    %al,(%eax)
 231:	43                   	inc    %ebx
 232:	0e                   	push   %cs
 233:	30 02                	xor    %al,(%edx)
 235:	47                   	inc    %edi
 236:	0e                   	push   %cs
 237:	04 10                	add    $0x10,%al
 239:	00 00                	add    %al,(%eax)
 23b:	00 3c 02             	add    %bh,(%edx,%eax,1)
 23e:	00 00                	add    %al,(%eax)
 240:	5d                   	pop    %ebp	240: R_386_PC32	.text
 241:	03 00                	add    (%eax),%eax
 243:	00 2e                	add    %ch,(%esi)
 245:	00 00                	add    %al,(%eax)
 247:	00 00                	add    %al,(%eax)
 249:	00 00                	add    %al,(%eax)
 24b:	00 14 00             	add    %dl,(%eax,%eax,1)
 24e:	00 00                	add    %al,(%eax)
 250:	50                   	push   %eax
 251:	02 00                	add    (%eax),%al
 253:	00 8b 03 00 00 4e    	add    %cl,0x4e000003(%ebx)	254: R_386_PC32	.text
 259:	00 00                	add    %al,(%eax)
 25b:	00 00                	add    %al,(%eax)
 25d:	43                   	inc    %ebx
 25e:	0e                   	push   %cs
 25f:	30 02                	xor    %al,(%edx)
 261:	4a                   	dec    %edx
 262:	0e                   	push   %cs
 263:	04 14                	add    $0x14,%al
 265:	00 00                	add    %al,(%eax)
 267:	00 68 02             	add    %ch,0x2(%eax)
 26a:	00 00                	add    %al,(%eax)
 26c:	d9 03                	flds   (%ebx)	26c: R_386_PC32	.text
 26e:	00 00                	add    %al,(%eax)
 270:	4e                   	dec    %esi
 271:	00 00                	add    %al,(%eax)
 273:	00 00                	add    %al,(%eax)
 275:	43                   	inc    %ebx
 276:	0e                   	push   %cs
 277:	30 02                	xor    %al,(%edx)
 279:	4a                   	dec    %edx
 27a:	0e                   	push   %cs
 27b:	04 14                	add    $0x14,%al
 27d:	00 00                	add    %al,(%eax)
 27f:	00 80 02 00 00 27    	add    %al,0x27000002(%eax)	284: R_386_PC32	.text
 285:	04 00                	add    $0x0,%al
 287:	00 4d 00             	add    %cl,0x0(%ebp)
 28a:	00 00                	add    %al,(%eax)
 28c:	00 43 0e             	add    %al,0xe(%ebx)
 28f:	30 02                	xor    %al,(%edx)
 291:	49                   	dec    %ecx
 292:	0e                   	push   %cs
 293:	04 14                	add    $0x14,%al
 295:	00 00                	add    %al,(%eax)
 297:	00 98 02 00 00 74    	add    %bl,0x74000002(%eax)	29c: R_386_PC32	.text
 29d:	04 00                	add    $0x0,%al
 29f:	00 4d 00             	add    %cl,0x0(%ebp)
 2a2:	00 00                	add    %al,(%eax)
 2a4:	00 43 0e             	add    %al,0xe(%ebx)
 2a7:	30 02                	xor    %al,(%edx)
 2a9:	49                   	dec    %ecx
 2aa:	0e                   	push   %cs
 2ab:	04 20                	add    $0x20,%al
 2ad:	00 00                	add    %al,(%eax)
 2af:	00 b0 02 00 00 c1    	add    %dh,-0x3efffffe(%eax)	2b4: R_386_PC32	.text
 2b5:	04 00                	add    $0x0,%al
 2b7:	00 56 00             	add    %dl,0x0(%esi)
 2ba:	00 00                	add    %al,(%eax)
 2bc:	00 41 0e             	add    %al,0xe(%ecx)
 2bf:	08 83 02 43 0e 30    	or     %al,0x300e4302(%ebx)
 2c5:	02 50 0e             	add    0xe(%eax),%dl
 2c8:	08 41 0e             	or     %al,0xe(%ecx)
 2cb:	04 c3                	add    $0xc3,%al
 2cd:	00 00                	add    %al,(%eax)
 2cf:	00 10                	add    %dl,(%eax)
 2d1:	00 00                	add    %al,(%eax)
 2d3:	00 d4                	add    %dl,%ah
 2d5:	02 00                	add    (%eax),%al
 2d7:	00 17                	add    %dl,(%edi)	2d8: R_386_PC32	.text
 2d9:	05 00 00 1e 00       	add    $0x1e0000,%eax
 2de:	00 00                	add    %al,(%eax)
 2e0:	00 00                	add    %al,(%eax)
 2e2:	00 00                	add    %al,(%eax)
 2e4:	10 00                	adc    %al,(%eax)
 2e6:	00 00                	add    %al,(%eax)
 2e8:	e8 02 00 00 35       	call   350002ef <ipport_set+0x34fff02c>	2ec: R_386_PC32	.text
 2ed:	05 00 00 1e 00       	add    $0x1e0000,%eax
 2f2:	00 00                	add    %al,(%eax)
 2f4:	00 00                	add    %al,(%eax)
 2f6:	00 00                	add    %al,(%eax)
 2f8:	10 00                	adc    %al,(%eax)
 2fa:	00 00                	add    %al,(%eax)
 2fc:	fc                   	cld    
 2fd:	02 00                	add    (%eax),%al
 2ff:	00 53 05             	add    %dl,0x5(%ebx)	300: R_386_PC32	.text
 302:	00 00                	add    %al,(%eax)
 304:	1e                   	push   %ds
 305:	00 00                	add    %al,(%eax)
 307:	00 00                	add    %al,(%eax)
 309:	00 00                	add    %al,(%eax)
 30b:	00 10                	add    %dl,(%eax)
 30d:	00 00                	add    %al,(%eax)
 30f:	00 10                	add    %dl,(%eax)
 311:	03 00                	add    (%eax),%eax
 313:	00 71 05             	add    %dh,0x5(%ecx)	314: R_386_PC32	.text
 316:	00 00                	add    %al,(%eax)
 318:	1e                   	push   %ds
 319:	00 00                	add    %al,(%eax)
 31b:	00 00                	add    %al,(%eax)
 31d:	00 00                	add    %al,(%eax)
 31f:	00 10                	add    %dl,(%eax)
 321:	00 00                	add    %al,(%eax)
 323:	00 24 03             	add    %ah,(%ebx,%eax,1)
 326:	00 00                	add    %al,(%eax)
 328:	8f 05 00 00 1e 00    	popl   0x1e0000	328: R_386_PC32	.text
 32e:	00 00                	add    %al,(%eax)
 330:	00 00                	add    %al,(%eax)
 332:	00 00                	add    %al,(%eax)
 334:	10 00                	adc    %al,(%eax)
 336:	00 00                	add    %al,(%eax)
 338:	38 03                	cmp    %al,(%ebx)
 33a:	00 00                	add    %al,(%eax)
 33c:	ad                   	lods   %ds:(%esi),%eax	33c: R_386_PC32	.text
 33d:	05 00 00 1e 00       	add    $0x1e0000,%eax
 342:	00 00                	add    %al,(%eax)
 344:	00 00                	add    %al,(%eax)
 346:	00 00                	add    %al,(%eax)
 348:	10 00                	adc    %al,(%eax)
 34a:	00 00                	add    %al,(%eax)
 34c:	4c                   	dec    %esp
 34d:	03 00                	add    (%eax),%eax
 34f:	00 cb                	add    %cl,%bl	350: R_386_PC32	.text
 351:	05 00 00 1e 00       	add    $0x1e0000,%eax
 356:	00 00                	add    %al,(%eax)
 358:	00 00                	add    %al,(%eax)
 35a:	00 00                	add    %al,(%eax)
 35c:	10 00                	adc    %al,(%eax)
 35e:	00 00                	add    %al,(%eax)
 360:	60                   	pusha  
 361:	03 00                	add    (%eax),%eax
 363:	00 e9                	add    %ch,%cl	364: R_386_PC32	.text
 365:	05 00 00 1e 00       	add    $0x1e0000,%eax
 36a:	00 00                	add    %al,(%eax)
 36c:	00 00                	add    %al,(%eax)
 36e:	00 00                	add    %al,(%eax)
 370:	10 00                	adc    %al,(%eax)
 372:	00 00                	add    %al,(%eax)
 374:	74 03                	je     379 <.eh_frame+0x379>
 376:	00 00                	add    %al,(%eax)
 378:	07                   	pop    %es	378: R_386_PC32	.text
 379:	06                   	push   %es
 37a:	00 00                	add    %al,(%eax)
 37c:	1e                   	push   %ds
 37d:	00 00                	add    %al,(%eax)
 37f:	00 00                	add    %al,(%eax)
 381:	00 00                	add    %al,(%eax)
 383:	00 10                	add    %dl,(%eax)
 385:	00 00                	add    %al,(%eax)
 387:	00 88 03 00 00 25    	add    %cl,0x25000003(%eax)	38c: R_386_PC32	.text
 38d:	06                   	push   %es
 38e:	00 00                	add    %al,(%eax)
 390:	1e                   	push   %ds
 391:	00 00                	add    %al,(%eax)
 393:	00 00                	add    %al,(%eax)
 395:	00 00                	add    %al,(%eax)
 397:	00 1c 00             	add    %bl,(%eax,%eax,1)
 39a:	00 00                	add    %al,(%eax)
 39c:	9c                   	pushf  
 39d:	03 00                	add    (%eax),%eax
 39f:	00 43 06             	add    %al,0x6(%ebx)	3a0: R_386_PC32	.text
 3a2:	00 00                	add    %al,(%eax)
 3a4:	42                   	inc    %edx
 3a5:	00 00                	add    %al,(%eax)
 3a7:	00 00                	add    %al,(%eax)
 3a9:	41                   	inc    %ecx
 3aa:	0e                   	push   %cs
 3ab:	08 83 02 43 0e 20    	or     %al,0x200e4302(%ebx)
 3b1:	7c 0e                	jl     3c1 <.eh_frame+0x3c1>
 3b3:	08 41 0e             	or     %al,0xe(%ecx)
 3b6:	04 c3                	add    $0xc3,%al
 3b8:	1c 00                	sbb    $0x0,%al
 3ba:	00 00                	add    %al,(%eax)
 3bc:	bc 03 00 00 85       	mov    $0x85000003,%esp	3c0: R_386_PC32	.text
 3c1:	06                   	push   %es
 3c2:	00 00                	add    %al,(%eax)
 3c4:	42                   	inc    %edx
 3c5:	00 00                	add    %al,(%eax)
 3c7:	00 00                	add    %al,(%eax)
 3c9:	41                   	inc    %ecx
 3ca:	0e                   	push   %cs
 3cb:	08 83 02 43 0e 20    	or     %al,0x200e4302(%ebx)
 3d1:	7c 0e                	jl     3e1 <.eh_frame+0x3e1>
 3d3:	08 41 0e             	or     %al,0xe(%ecx)
 3d6:	04 c3                	add    $0xc3,%al
 3d8:	1c 00                	sbb    $0x0,%al
 3da:	00 00                	add    %al,(%eax)
 3dc:	dc 03                	faddl  (%ebx)
 3de:	00 00                	add    %al,(%eax)
 3e0:	c7 06 00 00 42 00    	movl   $0x420000,(%esi)	3e0: R_386_PC32	.text
 3e6:	00 00                	add    %al,(%eax)
 3e8:	00 41 0e             	add    %al,0xe(%ecx)
 3eb:	08 83 02 43 0e 20    	or     %al,0x200e4302(%ebx)
 3f1:	7c 0e                	jl     401 <.eh_frame+0x401>
 3f3:	08 41 0e             	or     %al,0xe(%ecx)
 3f6:	04 c3                	add    $0xc3,%al
 3f8:	1c 00                	sbb    $0x0,%al
 3fa:	00 00                	add    %al,(%eax)
 3fc:	fc                   	cld    
 3fd:	03 00                	add    (%eax),%eax
 3ff:	00 09                	add    %cl,(%ecx)	400: R_386_PC32	.text
 401:	07                   	pop    %es
 402:	00 00                	add    %al,(%eax)
 404:	42                   	inc    %edx
 405:	00 00                	add    %al,(%eax)
 407:	00 00                	add    %al,(%eax)
 409:	41                   	inc    %ecx
 40a:	0e                   	push   %cs
 40b:	08 83 02 43 0e 20    	or     %al,0x200e4302(%ebx)
 411:	7c 0e                	jl     421 <.eh_frame+0x421>
 413:	08 41 0e             	or     %al,0xe(%ecx)
 416:	04 c3                	add    $0xc3,%al
 418:	1c 00                	sbb    $0x0,%al
 41a:	00 00                	add    %al,(%eax)
 41c:	1c 04                	sbb    $0x4,%al
 41e:	00 00                	add    %al,(%eax)
 420:	4b                   	dec    %ebx	420: R_386_PC32	.text
 421:	07                   	pop    %es
 422:	00 00                	add    %al,(%eax)
 424:	42                   	inc    %edx
 425:	00 00                	add    %al,(%eax)
 427:	00 00                	add    %al,(%eax)
 429:	41                   	inc    %ecx
 42a:	0e                   	push   %cs
 42b:	08 83 02 43 0e 20    	or     %al,0x200e4302(%ebx)
 431:	7c 0e                	jl     441 <.eh_frame+0x441>
 433:	08 41 0e             	or     %al,0xe(%ecx)
 436:	04 c3                	add    $0xc3,%al
 438:	14 00                	adc    $0x0,%al
 43a:	00 00                	add    %al,(%eax)
 43c:	3c 04                	cmp    $0x4,%al
 43e:	00 00                	add    %al,(%eax)
 440:	8d 07                	lea    (%edi),%eax	440: R_386_PC32	.text
 442:	00 00                	add    %al,(%eax)
 444:	2b 00                	sub    (%eax),%eax
 446:	00 00                	add    %al,(%eax)
 448:	00 43 0e             	add    %al,0xe(%ebx)
 44b:	20 67 0e             	and    %ah,0xe(%edi)
 44e:	04 00                	add    $0x0,%al
 450:	28 00                	sub    %al,(%eax)
 452:	00 00                	add    %al,(%eax)
 454:	54                   	push   %esp
 455:	04 00                	add    $0x0,%al
 457:	00 b8 07 00 00 61    	add    %bh,0x61000007(%eax)	458: R_386_PC32	.text
 45d:	00 00                	add    %al,(%eax)
 45f:	00 00                	add    %al,(%eax)
 461:	41                   	inc    %ecx
 462:	0e                   	push   %cs
 463:	08 86 02 41 0e 0c    	or     %al,0xc0e4102(%esi)
 469:	83 03 43             	addl   $0x43,(%ebx)
 46c:	0e                   	push   %cs
 46d:	20 02                	and    %al,(%edx)
 46f:	59                   	pop    %ecx
 470:	0e                   	push   %cs
 471:	0c 41                	or     $0x41,%al
 473:	0e                   	push   %cs
 474:	08 c3                	or     %al,%bl
 476:	41                   	inc    %ecx
 477:	0e                   	push   %cs
 478:	04 c6                	add    $0xc6,%al
 47a:	00 00                	add    %al,(%eax)
 47c:	28 00                	sub    %al,(%eax)
 47e:	00 00                	add    %al,(%eax)
 480:	80 04 00 00          	addb   $0x0,(%eax,%eax,1)
 484:	19 08                	sbb    %ecx,(%eax)	484: R_386_PC32	.text
 486:	00 00                	add    %al,(%eax)
 488:	4d                   	dec    %ebp
 489:	01 00                	add    %eax,(%eax)
 48b:	00 00                	add    %al,(%eax)
 48d:	41                   	inc    %ecx
 48e:	0e                   	push   %cs
 48f:	08 86 02 41 0e 0c    	or     %al,0xc0e4102(%esi)
 495:	83 03 43             	addl   $0x43,(%ebx)
 498:	0e                   	push   %cs
 499:	20 03                	and    %al,(%ebx)
 49b:	45                   	inc    %ebp
 49c:	01 0e                	add    %ecx,(%esi)
 49e:	0c 41                	or     $0x41,%al
 4a0:	0e                   	push   %cs
 4a1:	08 c3                	or     %al,%bl
 4a3:	41                   	inc    %ecx
 4a4:	0e                   	push   %cs
 4a5:	04 c6                	add    $0xc6,%al
 4a7:	00 30                	add    %dh,(%eax)
 4a9:	00 00                	add    %al,(%eax)
 4ab:	00 ac 04 00 00 66 09 	add    %ch,0x9660000(%esp,%eax,1)	4b0: R_386_PC32	.text
 4b2:	00 00                	add    %al,(%eax)
 4b4:	f4                   	hlt    
 4b5:	00 00                	add    %al,(%eax)
 4b7:	00 00                	add    %al,(%eax)
 4b9:	41                   	inc    %ecx
 4ba:	0e                   	push   %cs
 4bb:	08 87 02 41 0e 0c    	or     %al,0xc0e4102(%edi)
 4c1:	86 03                	xchg   %al,(%ebx)
 4c3:	41                   	inc    %ecx
 4c4:	0e                   	push   %cs
 4c5:	10 83 04 43 0e 20    	adc    %al,0x200e4304(%ebx)
 4cb:	02 ea                	add    %dl,%ch
 4cd:	0e                   	push   %cs
 4ce:	10 41 0e             	adc    %al,0xe(%ecx)
 4d1:	0c c3                	or     $0xc3,%al
 4d3:	41                   	inc    %ecx
 4d4:	0e                   	push   %cs
 4d5:	08 c6                	or     %al,%dh
 4d7:	41                   	inc    %ecx
 4d8:	0e                   	push   %cs
 4d9:	04 c7                	add    $0xc7,%al
 4db:	00 20                	add    %ah,(%eax)
 4dd:	00 00                	add    %al,(%eax)
 4df:	00 e0                	add    %ah,%al
 4e1:	04 00                	add    $0x0,%al
 4e3:	00 5a 0a             	add    %bl,0xa(%edx)	4e4: R_386_PC32	.text
 4e6:	00 00                	add    %al,(%eax)
 4e8:	48                   	dec    %eax
 4e9:	00 00                	add    %al,(%eax)
 4eb:	00 00                	add    %al,(%eax)
 4ed:	41                   	inc    %ecx
 4ee:	0e                   	push   %cs
 4ef:	08 83 02 43 0e 20    	or     %al,0x200e4302(%ebx)
 4f5:	02 42 0e             	add    0xe(%edx),%al
 4f8:	08 41 0e             	or     %al,0xe(%ecx)
 4fb:	04 c3                	add    $0xc3,%al
 4fd:	00 00                	add    %al,(%eax)
 4ff:	00 20                	add    %ah,(%eax)
 501:	00 00                	add    %al,(%eax)
 503:	00 04 05 00 00 a2 0a 	add    %al,0xaa20000(,%eax,1)	508: R_386_PC32	.text
 50a:	00 00                	add    %al,(%eax)
 50c:	48                   	dec    %eax
 50d:	00 00                	add    %al,(%eax)
 50f:	00 00                	add    %al,(%eax)
 511:	41                   	inc    %ecx
 512:	0e                   	push   %cs
 513:	08 83 02 43 0e 20    	or     %al,0x200e4302(%ebx)
 519:	02 42 0e             	add    0xe(%edx),%al
 51c:	08 41 0e             	or     %al,0xe(%ecx)
 51f:	04 c3                	add    $0xc3,%al
 521:	00 00                	add    %al,(%eax)
 523:	00 3c 00             	add    %bh,(%eax,%eax,1)
 526:	00 00                	add    %al,(%eax)
 528:	28 05 00 00 ea 0a    	sub    %al,0xaea0000	52c: R_386_PC32	.text
 52e:	00 00                	add    %al,(%eax)
 530:	d1 01                	roll   (%ecx)
 532:	00 00                	add    %al,(%eax)
 534:	00 41 0e             	add    %al,0xe(%ecx)
 537:	08 85 02 41 0e 0c    	or     %al,0xc0e4102(%ebp)
 53d:	87 03                	xchg   %eax,(%ebx)
 53f:	41                   	inc    %ecx
 540:	0e                   	push   %cs
 541:	10 86 04 41 0e 14    	adc    %al,0x140e4104(%esi)
 547:	83 05 46 0e e0 30 03 	addl   $0x3,0x30e00e46
 54e:	c2 01 0e             	ret    $0xe01
 551:	14 41                	adc    $0x41,%al
 553:	0e                   	push   %cs
 554:	10 c3                	adc    %al,%bl
 556:	41                   	inc    %ecx
 557:	0e                   	push   %cs
 558:	0c c6                	or     $0xc6,%al
 55a:	41                   	inc    %ecx
 55b:	0e                   	push   %cs
 55c:	08 c7                	or     %al,%bh
 55e:	41                   	inc    %ecx
 55f:	0e                   	push   %cs
 560:	04 c5                	add    $0xc5,%al
 562:	00 00                	add    %al,(%eax)
 564:	28 00                	sub    %al,(%eax)
 566:	00 00                	add    %al,(%eax)
 568:	68 05 00 00 bb       	push   $0xbb000005	56c: R_386_PC32	.text
 56d:	0c 00                	or     $0x0,%al
 56f:	00 5b 00             	add    %bl,0x0(%ebx)
 572:	00 00                	add    %al,(%eax)
 574:	00 41 0e             	add    %al,0xe(%ecx)
 577:	08 86 02 41 0e 0c    	or     %al,0xc0e4102(%esi)
 57d:	83 03 43             	addl   $0x43,(%ebx)
 580:	0e                   	push   %cs
 581:	20 02                	and    %al,(%edx)
 583:	53                   	push   %ebx
 584:	0e                   	push   %cs
 585:	0c 41                	or     $0x41,%al
 587:	0e                   	push   %cs
 588:	08 c3                	or     %al,%bl
 58a:	41                   	inc    %ecx
 58b:	0e                   	push   %cs
 58c:	04 c6                	add    $0xc6,%al
 58e:	00 00                	add    %al,(%eax)
 590:	20 00                	and    %al,(%eax)
 592:	00 00                	add    %al,(%eax)
 594:	94                   	xchg   %eax,%esp
 595:	05 00 00 16 0d       	add    $0xd160000,%eax	598: R_386_PC32	.text
 59a:	00 00                	add    %al,(%eax)
 59c:	48                   	dec    %eax
 59d:	00 00                	add    %al,(%eax)
 59f:	00 00                	add    %al,(%eax)
 5a1:	41                   	inc    %ecx
 5a2:	0e                   	push   %cs
 5a3:	08 83 02 43 0e 20    	or     %al,0x200e4302(%ebx)
 5a9:	02 42 0e             	add    0xe(%edx),%al
 5ac:	08 41 0e             	or     %al,0xe(%ecx)
 5af:	04 c3                	add    $0xc3,%al
 5b1:	00 00                	add    %al,(%eax)
 5b3:	00 20                	add    %ah,(%eax)
 5b5:	00 00                	add    %al,(%eax)
 5b7:	00 b8 05 00 00 5e    	add    %bh,0x5e000005(%eax)	5bc: R_386_PC32	.text
 5bd:	0d 00 00 60 00       	or     $0x600000,%eax
 5c2:	00 00                	add    %al,(%eax)
 5c4:	00 41 0e             	add    %al,0xe(%ecx)
 5c7:	08 83 02 43 0e 20    	or     %al,0x200e4302(%ebx)
 5cd:	02 5a 0e             	add    0xe(%edx),%bl
 5d0:	08 41 0e             	or     %al,0xe(%ecx)
 5d3:	04 c3                	add    $0xc3,%al
 5d5:	00 00                	add    %al,(%eax)
 5d7:	00 3c 00             	add    %bh,(%eax,%eax,1)
 5da:	00 00                	add    %al,(%eax)
 5dc:	dc 05 00 00 be 0d    	faddl  0xdbe0000	5e0: R_386_PC32	.text
 5e2:	00 00                	add    %al,(%eax)
 5e4:	66                   	data16
 5e5:	04 00                	add    $0x0,%al
 5e7:	00 00                	add    %al,(%eax)
 5e9:	41                   	inc    %ecx
 5ea:	0e                   	push   %cs
 5eb:	08 85 02 41 0e 0c    	or     %al,0xc0e4102(%ebp)
 5f1:	87 03                	xchg   %eax,(%ebx)
 5f3:	41                   	inc    %ecx
 5f4:	0e                   	push   %cs
 5f5:	10 86 04 41 0e 14    	adc    %al,0x140e4104(%esi)
 5fb:	83 05 46 0e f0 10 03 	addl   $0x3,0x10f00e46
 602:	57                   	push   %edi
 603:	04 0e                	add    $0xe,%al
 605:	14 41                	adc    $0x41,%al
 607:	0e                   	push   %cs
 608:	10 c3                	adc    %al,%bl
 60a:	41                   	inc    %ecx
 60b:	0e                   	push   %cs
 60c:	0c c6                	or     $0xc6,%al
 60e:	41                   	inc    %ecx
 60f:	0e                   	push   %cs
 610:	08 c7                	or     %al,%bh
 612:	41                   	inc    %ecx
 613:	0e                   	push   %cs
 614:	04 c5                	add    $0xc5,%al
 616:	00 00                	add    %al,(%eax)
 618:	1c 00                	sbb    $0x0,%al
 61a:	00 00                	add    %al,(%eax)
 61c:	1c 06                	sbb    $0x6,%al
 61e:	00 00                	add    %al,(%eax)
 620:	24 12                	and    $0x12,%al	620: R_386_PC32	.text
 622:	00 00                	add    %al,(%eax)
 624:	52                   	push   %edx
 625:	00 00                	add    %al,(%eax)
 627:	00 00                	add    %al,(%eax)
 629:	43                   	inc    %ebx
 62a:	0e                   	push   %cs
 62b:	20 57 86             	and    %dl,-0x7a(%edi)
 62e:	02 83 03 77 0e 04    	add    0x40e7703(%ebx),%al
 634:	c6 c3 00             	mov    $0x0,%bl
 637:	00 14 00             	add    %dl,(%eax,%eax,1)
 63a:	00 00                	add    %al,(%eax)
 63c:	3c 06                	cmp    $0x6,%al
 63e:	00 00                	add    %al,(%eax)
 640:	76 12                	jbe    654 <.eh_frame+0x654>	640: R_386_PC32	.text
 642:	00 00                	add    %al,(%eax)
 644:	1a 00                	sbb    (%eax),%al
 646:	00 00                	add    %al,(%eax)
 648:	00 43 0e             	add    %al,0xe(%ebx)
 64b:	10 56 0e             	adc    %dl,0xe(%esi)
 64e:	04 00                	add    $0x0,%al
 650:	10 00                	adc    %al,(%eax)
 652:	00 00                	add    %al,(%eax)
 654:	54                   	push   %esp
 655:	06                   	push   %es
 656:	00 00                	add    %al,(%eax)
 658:	90                   	nop	658: R_386_PC32	.text
 659:	12 00                	adc    (%eax),%al
 65b:	00 06                	add    %al,(%esi)
 65d:	00 00                	add    %al,(%eax)
 65f:	00 00                	add    %al,(%eax)
 661:	00 00                	add    %al,(%eax)
 663:	00 1c 00             	add    %bl,(%eax,%eax,1)
 666:	00 00                	add    %al,(%eax)
 668:	68 06 00 00 96       	push   $0x96000006	66c: R_386_PC32	.text
 66d:	12 00                	adc    (%eax),%al
 66f:	00 27                	add    %ah,(%edi)
 671:	00 00                	add    %al,(%eax)
 673:	00 00                	add    %al,(%eax)
 675:	41                   	inc    %ecx
 676:	0e                   	push   %cs
 677:	08 83 02 43 0e 20    	or     %al,0x200e4302(%ebx)
 67d:	61                   	popa   
 67e:	0e                   	push   %cs
 67f:	08 41 0e             	or     %al,0xe(%ecx)
 682:	04 c3                	add    $0xc3,%al
 684:	10 00                	adc    %al,(%eax)
 686:	00 00                	add    %al,(%eax)
 688:	88 06                	mov    %al,(%esi)
 68a:	00 00                	add    %al,(%eax)
 68c:	bd 12 00 00 06       	mov    $0x6000012,%ebp	68c: R_386_PC32	.text
 691:	00 00                	add    %al,(%eax)
 693:	00 00                	add    %al,(%eax)
 695:	00 00                	add    %al,(%eax)
 697:	00 1c 00             	add    %bl,(%eax,%eax,1)
 69a:	00 00                	add    %al,(%eax)
 69c:	9c                   	pushf  
 69d:	06                   	push   %es
 69e:	00 00                	add    %al,(%eax)
 6a0:	c3                   	ret    	6a0: R_386_PC32	.text
 6a1:	12 00                	adc    (%eax),%al
 6a3:	00 27                	add    %ah,(%edi)
 6a5:	00 00                	add    %al,(%eax)
 6a7:	00 00                	add    %al,(%eax)
 6a9:	41                   	inc    %ecx
 6aa:	0e                   	push   %cs
 6ab:	08 83 02 43 0e 20    	or     %al,0x200e4302(%ebx)
 6b1:	61                   	popa   
 6b2:	0e                   	push   %cs
 6b3:	08 41 0e             	or     %al,0xe(%ecx)
 6b6:	04 c3                	add    $0xc3,%al

lookup.o:     file format elf32-i386

SYMBOL TABLE:
00000000 g     F .text	0000019d conf_lookup
00000000         *UND*	00000000 getenv
00000000         *UND*	00000000 strcpy
00000000         *UND*	00000000 strcat
00000000         *UND*	00000000 __xstat
00000000         *UND*	00000000 __ctype_b_loc



Disassembly of section .text:

00000000 <conf_lookup>:

#include "conf.h"

int conf_lookup(char * pathname, const char ** searchpath, 
				const char ** filename)
{
   0:	55                   	push   %ebp
   1:	57                   	push   %edi
   2:	56                   	push   %esi
   3:	53                   	push   %ebx
   4:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
   a:	8b 94 24 a8 00 00 00 	mov    0xa8(%esp),%edx
	char * sp;
	struct stat buf;
	int i;
	int j;

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
  11:	83 bc 24 a0 00 00 00 00 	cmpl   $0x0,0xa0(%esp)
  19:	0f 84 59 01 00 00    	je     178 <conf_lookup+0x178>
  1f:	83 bc 24 a4 00 00 00 00 	cmpl   $0x0,0xa4(%esp)
  27:	0f 84 4b 01 00 00    	je     178 <conf_lookup+0x178>
  2d:	85 d2                	test   %edx,%edx
  2f:	0f 84 4a 01 00 00    	je     17f <conf_lookup+0x17f>
		return -1;

	for (i = 0; filename[i] != NULL; i++) {
  35:	8b 2a                	mov    (%edx),%ebp

			}
		}
	}

	return -1;
  37:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	int j;

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
		return -1;

	for (i = 0; filename[i] != NULL; i++) {
  3c:	85 ed                	test   %ebp,%ebp
  3e:	0f 84 4e 01 00 00    	je     192 <conf_lookup+0x192>
  44:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  48:	e9 0a 01 00 00       	jmp    157 <conf_lookup+0x157>
		for(fn = (char *)filename[i]; (*fn != '\0') && (*fn != '/') 
				&& (isspace(*fn)); fn++);
  4d:	83 c5 01             	add    $0x1,%ebp

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
		return -1;

	for (i = 0; filename[i] != NULL; i++) {
		for(fn = (char *)filename[i]; (*fn != '\0') && (*fn != '/') 
  50:	0f b6 5d 00          	movzbl 0x0(%ebp),%ebx
  54:	84 db                	test   %bl,%bl
  56:	74 0f                	je     67 <conf_lookup+0x67>
  58:	80 fb 2f             	cmp    $0x2f,%bl
  5b:	74 0a                	je     67 <conf_lookup+0x67>
				&& (isspace(*fn)); fn++);
  5d:	0f be c3             	movsbl %bl,%eax
  60:	f6 44 42 01 20       	testb  $0x20,0x1(%edx,%eax,2)
  65:	75 e6                	jne    4d <conf_lookup+0x4d>
		if (*fn == '\0')
  67:	84 db                	test   %bl,%bl
  69:	0f 84 d9 00 00 00    	je     148 <conf_lookup+0x148>
			continue;

		for (j = 0; searchpath[j] != NULL; j++) {
  6f:	8b 84 24 a4 00 00 00 	mov    0xa4(%esp),%eax
  76:	8b 30                	mov    (%eax),%esi
  78:	85 f6                	test   %esi,%esi
  7a:	0f 84 c8 00 00 00    	je     148 <conf_lookup+0x148>
  80:	89 44 24 14          	mov    %eax,0x14(%esp)
  84:	89 6c 24 18          	mov    %ebp,0x18(%esp)
  88:	8b ac 24 a0 00 00 00 	mov    0xa0(%esp),%ebp
  8f:	e9 a1 00 00 00       	jmp    135 <conf_lookup+0x135>

			for(sp = (char *)searchpath[j]; (*sp != '\0') && 
				(isspace(*sp)); sp++);
  94:	83 c6 01             	add    $0x1,%esi
		if (*fn == '\0')
			continue;

		for (j = 0; searchpath[j] != NULL; j++) {

			for(sp = (char *)searchpath[j]; (*sp != '\0') && 
  97:	0f b6 1e             	movzbl (%esi),%ebx
  9a:	84 db                	test   %bl,%bl
  9c:	74 29                	je     c7 <conf_lookup+0xc7>
				(isspace(*sp)); sp++);
  9e:	0f be c3             	movsbl %bl,%eax
		if (*fn == '\0')
			continue;

		for (j = 0; searchpath[j] != NULL; j++) {

			for(sp = (char *)searchpath[j]; (*sp != '\0') && 
  a1:	f6 44 42 01 20       	testb  $0x20,0x1(%edx,%eax,2)
  a6:	75 ec                	jne    94 <conf_lookup+0x94>
				(isspace(*sp)); sp++);

			/* very basic shell expansion */
			if (*sp == '~') {
  a8:	80 fb 7e             	cmp    $0x7e,%bl
  ab:	75 1a                	jne    c7 <conf_lookup+0xc7>
				strcpy(pathname, getenv("HOME"));
  ad:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)	b0: R_386_32	.rodata.str1.1
  b4:	e8 fc ff ff ff       	call   b5 <conf_lookup+0xb5>	b5: R_386_PC32	getenv
#endif

__extern_always_inline char *
__NTH (strcpy (char *__restrict __dest, __const char *__restrict __src))
{
  return __builtin___strcpy_chk (__dest, __src, __bos (__dest));
  b9:	89 44 24 04          	mov    %eax,0x4(%esp)
  bd:	89 2c 24             	mov    %ebp,(%esp)
  c0:	e8 fc ff ff ff       	call   c1 <conf_lookup+0xc1>	c1: R_386_PC32	strcpy
  c5:	eb 0c                	jmp    d3 <conf_lookup+0xd3>
  c7:	89 74 24 04          	mov    %esi,0x4(%esp)
  cb:	89 2c 24             	mov    %ebp,(%esp)
  ce:	e8 fc ff ff ff       	call   cf <conf_lookup+0xcf>	cf: R_386_PC32	strcpy


__extern_always_inline char *
__NTH (strcat (char *__restrict __dest, __const char *__restrict __src))
{
  return __builtin___strcat_chk (__dest, __src, __bos (__dest));
  d3:	89 ef                	mov    %ebp,%edi
  d5:	b8 00 00 00 00       	mov    $0x0,%eax
  da:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  df:	f2 ae                	repnz scas %es:(%edi),%al
  e1:	f7 d1                	not    %ecx
  e3:	66 c7 44 0d ff 2f 00 	movw   $0x2f,-0x1(%ebp,%ecx,1)
  ea:	8b 44 24 18          	mov    0x18(%esp),%eax
  ee:	89 44 24 04          	mov    %eax,0x4(%esp)
  f2:	89 2c 24             	mov    %ebp,(%esp)
  f5:	e8 fc ff ff ff       	call   f6 <conf_lookup+0xf6>	f6: R_386_PC32	strcat
			} else 
				strcpy(pathname, sp);
			strcat(pathname, "/");
			strcat(pathname, fn);

			if (stat(pathname, &buf) == 0) {
  fa:	8d 44 24 28          	lea    0x28(%esp),%eax
  fe:	89 44 24 08          	mov    %eax,0x8(%esp)
/* Inlined versions of the real stat and mknod functions.  */

__extern_inline int
__NTH (stat (__const char *__path, struct stat *__statbuf))
{
  return __xstat (_STAT_VER, __path, __statbuf);
 102:	89 6c 24 04          	mov    %ebp,0x4(%esp)
 106:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
 10d:	e8 fc ff ff ff       	call   10e <conf_lookup+0x10e>	10e: R_386_PC32	__xstat
 112:	85 c0                	test   %eax,%eax
 114:	75 10                	jne    126 <conf_lookup+0x126>

				if (S_ISREG(buf.st_mode))
 116:	8b 44 24 38          	mov    0x38(%esp),%eax
 11a:	25 00 f0 00 00       	and    $0xf000,%eax
 11f:	3d 00 80 00 00       	cmp    $0x8000,%eax
 124:	74 60                	je     186 <conf_lookup+0x186>
 126:	83 44 24 14 04       	addl   $0x4,0x14(%esp)
		for(fn = (char *)filename[i]; (*fn != '\0') && (*fn != '/') 
				&& (isspace(*fn)); fn++);
		if (*fn == '\0')
			continue;

		for (j = 0; searchpath[j] != NULL; j++) {
 12b:	8b 44 24 14          	mov    0x14(%esp),%eax
 12f:	8b 30                	mov    (%eax),%esi
 131:	85 f6                	test   %esi,%esi
 133:	74 13                	je     148 <conf_lookup+0x148>

			for(sp = (char *)searchpath[j]; (*sp != '\0') && 
 135:	0f b6 1e             	movzbl (%esi),%ebx
 138:	84 db                	test   %bl,%bl
 13a:	74 8b                	je     c7 <conf_lookup+0xc7>
				(isspace(*sp)); sp++);
 13c:	e8 fc ff ff ff       	call   13d <conf_lookup+0x13d>	13d: R_386_PC32	__ctype_b_loc
 141:	8b 10                	mov    (%eax),%edx
 143:	e9 56 ff ff ff       	jmp    9e <conf_lookup+0x9e>
 148:	83 44 24 1c 04       	addl   $0x4,0x1c(%esp)
	int j;

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
		return -1;

	for (i = 0; filename[i] != NULL; i++) {
 14d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 151:	8b 28                	mov    (%eax),%ebp
 153:	85 ed                	test   %ebp,%ebp
 155:	74 36                	je     18d <conf_lookup+0x18d>
		for(fn = (char *)filename[i]; (*fn != '\0') && (*fn != '/') 
 157:	0f b6 5d 00          	movzbl 0x0(%ebp),%ebx
 15b:	84 db                	test   %bl,%bl
 15d:	0f 84 04 ff ff ff    	je     67 <conf_lookup+0x67>
 163:	80 fb 2f             	cmp    $0x2f,%bl
 166:	0f 84 fb fe ff ff    	je     67 <conf_lookup+0x67>
				&& (isspace(*fn)); fn++);
 16c:	e8 fc ff ff ff       	call   16d <conf_lookup+0x16d>	16d: R_386_PC32	__ctype_b_loc
 171:	8b 10                	mov    (%eax),%edx
 173:	e9 e5 fe ff ff       	jmp    5d <conf_lookup+0x5d>
	struct stat buf;
	int i;
	int j;

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
		return -1;
 178:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 17d:	eb 13                	jmp    192 <conf_lookup+0x192>
 17f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 184:	eb 0c                	jmp    192 <conf_lookup+0x192>
			strcat(pathname, fn);

			if (stat(pathname, &buf) == 0) {

				if (S_ISREG(buf.st_mode))
					return 0;
 186:	b8 00 00 00 00       	mov    $0x0,%eax
 18b:	eb 05                	jmp    192 <conf_lookup+0x192>

			}
		}
	}

	return -1;
 18d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
 192:	81 c4 8c 00 00 00    	add    $0x8c,%esp
 198:	5b                   	pop    %ebx
 199:	5e                   	pop    %esi
 19a:	5f                   	pop    %edi
 19b:	5d                   	pop    %ebp
 19c:	c3                   	ret    

Disassembly of section .rodata.str1.1:

00000000 <.rodata.str1.1>:
   0:	48                   	dec    %eax
   1:	4f                   	dec    %edi
   2:	4d                   	dec    %ebp
   3:	45                   	inc    %ebp
   4:	00                   	.byte 0x0

Disassembly of section .debug_info:

00000000 <.debug_info>:

#include "conf.h"

int conf_lookup(char * pathname, const char ** searchpath, 
				const char ** filename)
{
   0:	22 06                	and    (%esi),%al
   2:	00 00                	add    %al,(%eax)
   4:	02 00                	add    (%eax),%al
   6:	00 00                	add    %al,(%eax)	6: R_386_32	.debug_abbrev
   8:	00 00                	add    %al,(%eax)
   a:	04 01                	add    $0x1,%al
   c:	c5 03                	lds    (%ebx),%eax	c: R_386_32	.debug_str
   e:	00 00                	add    %al,(%eax)
  10:	01 3d 02 00 00 f0    	add    %edi,0xf0000002	11: R_386_32	.debug_str
	15: R_386_32	.debug_str
	char * sp;
	struct stat buf;
	int i;
	int j;

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
  16:	00 00                	add    %al,(%eax)
  18:	00 00                	add    %al,(%eax)	19: R_386_32	.text
  1a:	00 00                	add    %al,(%eax)
  1c:	00 9d 01 00 00 00    	add    %bl,0x1(%ebp)	1d: R_386_32	.text
	21: R_386_32	.debug_line
  22:	00 00                	add    %al,(%eax)
  24:	00 02                	add    %al,(%edx)
  26:	01 08                	add    %ecx,(%eax)
  28:	bb 01 00 00 02       	mov    $0x2000001,%ebx	28: R_386_32	.debug_str
  2d:	02 07                	add    (%edi),%al
  2f:	01 03                	add    %eax,(%ebx)	2f: R_386_32	.debug_str
  31:	00 00                	add    %al,(%eax)
  33:	02 04 07             	add    (%edi,%eax,1),%al
		return -1;

	for (i = 0; filename[i] != NULL; i++) {
  36:	1b 02                	sbb    (%edx),%eax	36: R_386_32	.debug_str

			}
		}
	}

	return -1;
  38:	00 00                	add    %al,(%eax)
  3a:	02 04 07             	add    (%edi,%eax,1),%al
	int j;

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
		return -1;

	for (i = 0; filename[i] != NULL; i++) {
  3d:	1d 03 00 00 02       	sbb    $0x2000003,%eax	3d: R_386_32	.debug_str
  42:	01 06                	add    %eax,(%esi)
  44:	f8                   	clc    	44: R_386_32	.debug_str
  45:	01 00                	add    %eax,(%eax)
  47:	00 02                	add    %al,(%edx)
  49:	02 05 c7 00 00 00    	add    0xc7,%al	4b: R_386_32	.debug_str
		for(fn = (char *)filename[i]; (*fn != '\0') && (*fn != '/') 
				&& (isspace(*fn)); fn++);
  4f:	03 04 05 69 6e 74 00 	add    0x746e69(,%eax,1),%eax

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
		return -1;

	for (i = 0; filename[i] != NULL; i++) {
		for(fn = (char *)filename[i]; (*fn != '\0') && (*fn != '/') 
  56:	02 08                	add    (%eax),%cl
  58:	05 6d 01 00 00       	add    $0x16d,%eax	59: R_386_32	.debug_str
				&& (isspace(*fn)); fn++);
  5d:	02 08                	add    (%eax),%cl
  5f:	07                   	pop    %es
  60:	04 02                	add    $0x2,%al	60: R_386_32	.debug_str
  62:	00 00                	add    %al,(%eax)
  64:	04 7b                	add    $0x7b,%al	65: R_386_32	.debug_str
  66:	03 00                	add    (%eax),%eax
		if (*fn == '\0')
  68:	00 04 38             	add    %al,(%eax,%edi,1)
  6b:	56                   	push   %esi
  6c:	00 00                	add    %al,(%eax)
  6e:	00 04 df             	add    %al,(%edi,%ebx,8)	70: R_386_32	.debug_str
			continue;

		for (j = 0; searchpath[j] != NULL; j++) {
  71:	02 00                	add    (%eax),%al
  73:	00 04 39             	add    %al,(%ecx,%edi,1)
  76:	5d                   	pop    %ebp
  77:	00 00                	add    %al,(%eax)
  79:	00 04 5d 03 00 00 04 	add    %al,0x4000003(,%ebx,2)	7b: R_386_32	.debug_str
  80:	86 6f 00             	xchg   %ch,0x0(%edi)
  83:	00 00                	add    %al,(%eax)
  85:	04 bd                	add    $0xbd,%al	86: R_386_32	.debug_str
  87:	03 00                	add    (%eax),%eax
  89:	00 04 87             	add    %al,(%edi,%eax,4)
  8c:	33 00                	xor    (%eax),%eax
  8e:	00 00                	add    %al,(%eax)
  90:	04 22                	add    $0x22,%al	91: R_386_32	.debug_str
  92:	04 00                	add    $0x0,%al

			for(sp = (char *)searchpath[j]; (*sp != '\0') && 
				(isspace(*sp)); sp++);
  94:	00 04 88             	add    %al,(%eax,%ecx,4)
		if (*fn == '\0')
			continue;

		for (j = 0; searchpath[j] != NULL; j++) {

			for(sp = (char *)searchpath[j]; (*sp != '\0') && 
  97:	33 00                	xor    (%eax),%eax
  99:	00 00                	add    %al,(%eax)
  9b:	04 f2                	add    $0xf2,%al	9c: R_386_32	.debug_str
  9d:	02 00                	add    (%eax),%al
				(isspace(*sp)); sp++);
  9f:	00 04 89             	add    %al,(%ecx,%ecx,4)
		if (*fn == '\0')
			continue;

		for (j = 0; searchpath[j] != NULL; j++) {

			for(sp = (char *)searchpath[j]; (*sp != '\0') && 
  a2:	3a 00                	cmp    (%eax),%al
  a4:	00 00                	add    %al,(%eax)
  a6:	04 5c                	add    $0x5c,%al	a7: R_386_32	.debug_str
				(isspace(*sp)); sp++);

			/* very basic shell expansion */
			if (*sp == '~') {
  a8:	00 00                	add    %al,(%eax)
  aa:	00 04 8b             	add    %al,(%ebx,%ecx,4)
				strcpy(pathname, getenv("HOME"));
  ad:	33 00                	xor    (%eax),%eax
  af:	00 00                	add    %al,(%eax)
  b1:	04 98                	add    $0x98,%al	b2: R_386_32	.debug_str
  b3:	01 00                	add    %eax,(%eax)
  b5:	00 04 8c             	add    %al,(%esp,%ecx,4)
  b8:	33 00                	xor    (%eax),%eax
#endif

__extern_always_inline char *
__NTH (strcpy (char *__restrict __dest, __const char *__restrict __src))
{
  return __builtin___strcpy_chk (__dest, __src, __bos (__dest));
  ba:	00 00                	add    %al,(%eax)
  bc:	04 55                	add    $0x55,%al	bd: R_386_32	.debug_str
  be:	03 00                	add    (%eax),%eax
  c0:	00 04 8d c7 00 00 00 	add    %al,0xc7(,%ecx,4)
  c7:	02 04 05 88 01 00 00 	add    0x188(,%eax,1),%al	ca: R_386_32	.debug_str
  ce:	04 46                	add    $0x46,%al	cf: R_386_32	.debug_str
  d0:	02 00                	add    (%eax),%al
  d2:	00 04 8e             	add    %al,(%esi,%ecx,4)


__extern_always_inline char *
__NTH (strcat (char *__restrict __dest, __const char *__restrict __src))
{
  return __builtin___strcat_chk (__dest, __src, __bos (__dest));
  d5:	64 00 00             	add    %al,%fs:(%eax)
  d8:	00 04 3d 03 00 00 04 	add    %al,0x4000003(,%edi,1)	da: R_386_32	.debug_str
  df:	95                   	xchg   %eax,%ebp
  e0:	c7 00 00 00 05 04    	movl   $0x4050000,(%eax)
  e6:	04 7c                	add    $0x7c,%al	e7: R_386_32	.debug_str
  e8:	02 00                	add    (%eax),%al
  ea:	00 04 a4             	add    %al,(%esp,%eiz,4)
  ed:	c7 00 00 00 04 05    	movl   $0x5040000,(%eax)	f2: R_386_32	.debug_str
  f3:	04 00                	add    $0x0,%al
  f5:	00 04 a9             	add    %al,(%ecx,%ebp,4)
  f8:	c7 00 00 00 06 04    	movl   $0x4060000,(%eax)
			} else 
				strcpy(pathname, sp);
			strcat(pathname, "/");
			strcat(pathname, fn);

			if (stat(pathname, &buf) == 0) {
  fe:	02 01                	add    (%ecx),%al
 100:	00 00                	add    %al,(%eax)
 102:	02 01                	add    (%ecx),%al
 104:	06                   	push   %es
 105:	9b                   	fwait	105: R_386_32	.debug_str
 106:	02 00                	add    (%eax),%al
 108:	00 04 65 00 00 00 05 	add    %al,0x5000000(,%eiz,2)	10a: R_386_32	.debug_str
 10f:	d4 33                	aam    $0x33
 111:	00 00                	add    %al,(%eax)
 113:	00 07                	add    %al,(%edi)
 115:	b4 03                	mov    $0x3,%ah	115: R_386_32	.debug_str

				if (S_ISREG(buf.st_mode))
 117:	00 00                	add    %al,(%eax)
 119:	08 06                	or     %al,(%esi)
 11b:	78 3d                	js     15a <.debug_info+0x15a>
 11d:	01 00                	add    %eax,(%eax)
 11f:	00 08                	add    %cl,(%eax)
 121:	48                   	dec    %eax	121: R_386_32	.debug_str
 122:	00 00                	add    %al,(%eax)
 124:	00 06                	add    %al,(%esi)
 126:	7a d9                	jp     101 <.debug_info+0x101>
 128:	00 00                	add    %al,(%eax)
 12a:	00 02                	add    %al,(%edx)
		for(fn = (char *)filename[i]; (*fn != '\0') && (*fn != '/') 
				&& (isspace(*fn)); fn++);
		if (*fn == '\0')
			continue;

		for (j = 0; searchpath[j] != NULL; j++) {
 12c:	23 00                	and    (%eax),%eax
 12e:	08 08                	or     %cl,(%eax)	12f: R_386_32	.debug_str
 130:	00 00                	add    %al,(%eax)
 132:	00 06                	add    %al,(%esi)
 134:	7b c7                	jnp    fd <.debug_info+0xfd>

			for(sp = (char *)searchpath[j]; (*sp != '\0') && 
 136:	00 00                	add    %al,(%eax)
 138:	00 02                	add    %al,(%edx)
 13a:	23 04 00             	and    (%eax,%eax,1),%eax
				(isspace(*sp)); sp++);
 13d:	07                   	pop    %es
 13e:	df 03                	fild   (%ebx)	13e: R_386_32	.debug_str
 140:	00 00                	add    %al,(%eax)
 142:	58                   	pop    %eax
 143:	07                   	pop    %es
 144:	27                   	daa    
 145:	38 02                	cmp    %al,(%edx)
 147:	00 00                	add    %al,(%eax)
 149:	08 aa 00 00 00 07    	or     %ch,0x7000000(%edx)	14a: R_386_32	.debug_str
	int j;

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
		return -1;

	for (i = 0; filename[i] != NULL; i++) {
 14f:	29 7a 00             	sub    %edi,0x0(%edx)
 152:	00 00                	add    %al,(%eax)
 154:	02 23                	add    (%ebx),%ah
 156:	00 08                	add    %cl,(%eax)
		for(fn = (char *)filename[i]; (*fn != '\0') && (*fn != '/') 
 158:	d8 01                	fadds  (%ecx)	158: R_386_32	.debug_str
 15a:	00 00                	add    %al,(%eax)
 15c:	07                   	pop    %es
 15d:	2a 2c 00             	sub    (%eax,%eax,1),%ch
 160:	00 00                	add    %al,(%eax)
 162:	02 23                	add    (%ebx),%ah
 164:	08 08                	or     %cl,(%eax)
 166:	df 01                	fild   (%ecx)	166: R_386_32	.debug_str
 168:	00 00                	add    %al,(%eax)
 16a:	07                   	pop    %es
 16b:	2c 9b                	sub    $0x9b,%al
				&& (isspace(*fn)); fn++);
 16d:	00 00                	add    %al,(%eax)
 16f:	00 02                	add    %al,(%edx)
 171:	23 0c 08             	and    (%eax,%ecx,1),%ecx
 174:	e4 03                	in     $0x3,%al	174: R_386_32	.debug_str
 176:	00 00                	add    %al,(%eax)
	struct stat buf;
	int i;
	int j;

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
		return -1;
 178:	07                   	pop    %es
 179:	30 a6 00 00 00 02    	xor    %ah,0x2000000(%esi)
 17f:	23 10                	and    (%eax),%edx
 181:	08 be 00 00 00 07    	or     %bh,0x7000000(%esi)	182: R_386_32	.debug_str
			strcat(pathname, fn);

			if (stat(pathname, &buf) == 0) {

				if (S_ISREG(buf.st_mode))
					return 0;
 187:	31 b1 00 00 00 02    	xor    %esi,0x2000000(%ecx)

			}
		}
	}

	return -1;
 18d:	23 14 08             	and    (%eax,%ecx,1),%edx
 190:	fa                   	cli    	190: R_386_32	.debug_str
 191:	02 00                	add    (%eax),%al
}
 193:	00 07                	add    %al,(%edi)
 195:	32 85 00 00 00 02    	xor    0x2000000(%ebp),%al
 19b:	23 18                	and    (%eax),%ebx
 19d:	08 7b 01             	or     %bh,0x1(%ebx)	19e: R_386_32	.debug_str
 1a0:	00 00                	add    %al,(%eax)
 1a2:	07                   	pop    %es
 1a3:	33 90 00 00 00 02    	xor    0x2000000(%eax),%edx
 1a9:	23 1c 08             	and    (%eax,%ecx,1),%ebx
 1ac:	00 00                	add    %al,(%eax)	1ac: R_386_32	.debug_str
 1ae:	00 00                	add    %al,(%eax)
 1b0:	07                   	pop    %es
 1b1:	34 7a                	xor    $0x7a,%al
 1b3:	00 00                	add    %al,(%eax)
 1b5:	00 02                	add    %al,(%edx)
 1b7:	23 20                	and    (%eax),%esp
 1b9:	08 50 02             	or     %dl,0x2(%eax)	1ba: R_386_32	.debug_str
 1bc:	00 00                	add    %al,(%eax)
 1be:	07                   	pop    %es
 1bf:	35 2c 00 00 00       	xor    $0x2c,%eax
 1c4:	02 23                	add    (%ebx),%ah
 1c6:	28 08                	sub    %cl,(%eax)
 1c8:	37                   	aaa    	1c8: R_386_32	.debug_str
 1c9:	00 00                	add    %al,(%eax)
 1cb:	00 07                	add    %al,(%edi)
 1cd:	37                   	aaa    
 1ce:	bc 00 00 00 02       	mov    $0x2000000,%esp
 1d3:	23 2c 08             	and    (%eax,%ecx,1),%ebp
 1d6:	59                   	pop    %ecx	1d6: R_386_32	.debug_str
 1d7:	01 00                	add    %eax,(%eax)
 1d9:	00 07                	add    %al,(%edi)
 1db:	3b e6                	cmp    %esi,%esp
 1dd:	00 00                	add    %al,(%eax)
 1df:	00 02                	add    %al,(%edx)
 1e1:	23 30                	and    (%eax),%esi
 1e3:	08 d5                	or     %dl,%ch	1e4: R_386_32	.debug_str
 1e5:	02 00                	add    (%eax),%al
 1e7:	00 07                	add    %al,(%edi)
 1e9:	3e                   	ds
 1ea:	f1                   	icebp  
 1eb:	00 00                	add    %al,(%eax)
 1ed:	00 02                	add    %al,(%edx)
 1ef:	23 34 08             	and    (%eax,%ecx,1),%esi
 1f2:	9b                   	fwait	1f2: R_386_32	.debug_str
 1f3:	00 00                	add    %al,(%eax)
 1f5:	00 07                	add    %al,(%edi)
 1f7:	49                   	dec    %ecx
 1f8:	14 01                	adc    $0x1,%al
 1fa:	00 00                	add    %al,(%eax)
 1fc:	02 23                	add    (%ebx),%ah
 1fe:	38 08                	cmp    %cl,(%eax)
 200:	ea 02 00 00 07 4a 14 	ljmp   $0x144a,$0x7000002	200: R_386_32	.debug_str
 207:	01 00                	add    %eax,(%eax)
 209:	00 02                	add    %al,(%edx)
 20b:	23 40 08             	and    0x8(%eax),%eax
 20e:	b3 01                	mov    $0x1,%bl	20e: R_386_32	.debug_str
 210:	00 00                	add    %al,(%eax)
 212:	07                   	pop    %es
 213:	4b                   	dec    %ebx
 214:	14 01                	adc    $0x1,%al
 216:	00 00                	add    %al,(%eax)
 218:	02 23                	add    (%ebx),%ah
 21a:	48                   	dec    %eax
 21b:	08 f2                	or     %dh,%dl	21c: R_386_32	.debug_str
 21d:	03 00                	add    (%eax),%eax
 21f:	00 07                	add    %al,(%edi)
 221:	58                   	pop    %eax
 222:	3a 00                	cmp    (%eax),%al
 224:	00 00                	add    %al,(%eax)
 226:	02 23                	add    (%ebx),%ah
 228:	50                   	push   %eax
 229:	08 2d 00 00 00 07    	or     %ch,0x7000000	22a: R_386_32	.debug_str
 22f:	59                   	pop    %ecx
 230:	3a 00                	cmp    (%eax),%al
 232:	00 00                	add    %al,(%eax)
 234:	02 23                	add    (%ebx),%ah
 236:	54                   	push   %esp
 237:	00 09                	add    %cl,(%ecx)
 239:	3f                   	aas    	239: R_386_32	.debug_str
 23a:	00 00                	add    %al,(%eax)
 23c:	00 94 08 11 01 f9 03 	add    %dl,0x3f90111(%eax,%ecx,1)
 243:	00 00                	add    %al,(%eax)
 245:	0a 94 00 00 00 08 12 	or     0x12080000(%eax,%eax,1),%dl	246: R_386_32	.debug_str
 24c:	01 4f 00             	add    %ecx,0x0(%edi)
 24f:	00 00                	add    %al,(%eax)
 251:	02 23                	add    (%ebx),%ah
 253:	00 0a                	add    %cl,(%edx)
 255:	6f                   	outsl  %ds:(%esi),(%dx)	255: R_386_32	.debug_str
 256:	02 00                	add    (%eax),%al
 258:	00 08                	add    %cl,(%eax)
 25a:	17                   	pop    %ss
 25b:	01 fc                	add    %edi,%esp
 25d:	00 00                	add    %al,(%eax)
 25f:	00 02                	add    %al,(%edx)
 261:	23 04 0a             	and    (%edx,%ecx,1),%eax
 264:	da 00                	fiaddl (%eax)	264: R_386_32	.debug_str
 266:	00 00                	add    %al,(%eax)
 268:	08 18                	or     %bl,(%eax)
 26a:	01 fc                	add    %edi,%esp
 26c:	00 00                	add    %al,(%eax)
 26e:	00 02                	add    %al,(%edx)
 270:	23 08                	and    (%eax),%ecx
 272:	0a 93 03 00 00 08    	or     0x8000003(%ebx),%dl	273: R_386_32	.debug_str
 278:	19 01                	sbb    %eax,(%ecx)
 27a:	fc                   	cld    
 27b:	00 00                	add    %al,(%eax)
 27d:	00 02                	add    %al,(%edx)
 27f:	23 0c 0a             	and    (%edx,%ecx,1),%ecx
 282:	57                   	push   %edi	282: R_386_32	.debug_str
 283:	02 00                	add    (%eax),%al
 285:	00 08                	add    %cl,(%eax)
 287:	1a 01                	sbb    (%ecx),%al
 289:	fc                   	cld    
 28a:	00 00                	add    %al,(%eax)
 28c:	00 02                	add    %al,(%edx)
 28e:	23 10                	and    (%eax),%edx
 290:	0a 86 00 00 00 08    	or     0x8000000(%esi),%al	291: R_386_32	.debug_str
 296:	1b 01                	sbb    (%ecx),%eax
 298:	fc                   	cld    
 299:	00 00                	add    %al,(%eax)
 29b:	00 02                	add    %al,(%edx)
 29d:	23 14 0a             	and    (%edx,%ecx,1),%edx
 2a0:	2f                   	das    	2a0: R_386_32	.debug_str
 2a1:	03 00                	add    (%eax),%eax
 2a3:	00 08                	add    %cl,(%eax)
 2a5:	1c 01                	sbb    $0x1,%al
 2a7:	fc                   	cld    
 2a8:	00 00                	add    %al,(%eax)
 2aa:	00 02                	add    %al,(%edx)
 2ac:	23 18                	and    (%eax),%ebx
 2ae:	0a b1 00 00 00 08    	or     0x8000000(%ecx),%dh	2af: R_386_32	.debug_str
 2b4:	1d 01 fc 00 00       	sbb    $0xfc01,%eax
 2b9:	00 02                	add    %al,(%edx)
 2bb:	23 1c 0a             	and    (%edx,%ecx,1),%ebx
 2be:	8f 02                	popl   (%edx)	2be: R_386_32	.debug_str
 2c0:	00 00                	add    %al,(%eax)
 2c2:	08 1e                	or     %bl,(%esi)
 2c4:	01 fc                	add    %edi,%esp
 2c6:	00 00                	add    %al,(%eax)
 2c8:	00 02                	add    %al,(%edx)
 2ca:	23 20                	and    (%eax),%esp
 2cc:	0a d1                	or     %cl,%dl	2cd: R_386_32	.debug_str
 2ce:	03 00                	add    (%eax),%eax
 2d0:	00 08                	add    %cl,(%eax)
 2d2:	20 01                	and    %al,(%ecx)
 2d4:	fc                   	cld    
 2d5:	00 00                	add    %al,(%eax)
 2d7:	00 02                	add    %al,(%edx)
 2d9:	23 24 0a             	and    (%edx,%ecx,1),%esp
 2dc:	65 03 00             	add    %gs:(%eax),%eax	2dc: R_386_32	.debug_str
 2df:	00 08                	add    %cl,(%eax)
 2e1:	21 01                	and    %eax,(%ecx)
 2e3:	fc                   	cld    
 2e4:	00 00                	add    %al,(%eax)
 2e6:	00 02                	add    %al,(%edx)
 2e8:	23 28                	and    (%eax),%ebp
 2ea:	0a 4f 00             	or     0x0(%edi),%cl	2eb: R_386_32	.debug_str
 2ed:	00 00                	add    %al,(%eax)
 2ef:	08 22                	or     %ah,(%edx)
 2f1:	01 fc                	add    %edi,%esp
 2f3:	00 00                	add    %al,(%eax)
 2f5:	00 02                	add    %al,(%edx)
 2f7:	23 2c 0a             	and    (%edx,%ecx,1),%ebp
 2fa:	d1 00                	roll   (%eax)	2fa: R_386_32	.debug_str
 2fc:	00 00                	add    %al,(%eax)
 2fe:	08 24 01             	or     %ah,(%ecx,%eax,1)
 301:	37                   	aaa    
 302:	04 00                	add    $0x0,%al
 304:	00 02                	add    %al,(%edx)
 306:	23 30                	and    (%eax),%esi
 308:	0a 4e 03             	or     0x3(%esi),%cl	309: R_386_32	.debug_str
 30b:	00 00                	add    %al,(%eax)
 30d:	08 26                	or     %ah,(%esi)
 30f:	01 3d 04 00 00 02    	add    %edi,0x2000004
 315:	23 34 0a             	and    (%edx,%ecx,1),%esi
 318:	46                   	inc    %esi	318: R_386_32	.debug_str
 319:	03 00                	add    (%eax),%eax
 31b:	00 08                	add    %cl,(%eax)
 31d:	28 01                	sub    %al,(%ecx)
 31f:	4f                   	dec    %edi
 320:	00 00                	add    %al,(%eax)
 322:	00 02                	add    %al,(%edx)
 324:	23 38                	and    (%eax),%edi
 326:	0a 10                	or     (%eax),%dl	327: R_386_32	.debug_str
 328:	00 00                	add    %al,(%eax)
 32a:	00 08                	add    %cl,(%eax)
 32c:	2c 01                	sub    $0x1,%al
 32e:	4f                   	dec    %edi
 32f:	00 00                	add    %al,(%eax)
 331:	00 02                	add    %al,(%edx)
 333:	23 3c 0a             	and    (%edx,%ecx,1),%edi
 336:	18 00                	sbb    %al,(%eax)	336: R_386_32	.debug_str
 338:	00 00                	add    %al,(%eax)
 33a:	08 2e                	or     %ch,(%esi)
 33c:	01 bc 00 00 00 02 23 	add    %edi,0x23020000(%eax,%eax,1)
 343:	40                   	inc    %eax
 344:	0a a2 01 00 00 08    	or     0x8000001(%edx),%ah	345: R_386_32	.debug_str
 34a:	32 01                	xor    (%ecx),%al
 34c:	2c 00                	sub    $0x0,%al
 34e:	00 00                	add    %al,(%eax)
 350:	02 23                	add    (%ebx),%ah
 352:	44                   	inc    %esp
 353:	0a c9                	or     %cl,%cl	354: R_386_32	.debug_str
 355:	01 00                	add    %eax,(%eax)
 357:	00 08                	add    %cl,(%eax)
 359:	33 01                	xor    (%ecx),%eax
 35b:	41                   	inc    %ecx
 35c:	00 00                	add    %al,(%eax)
 35e:	00 02                	add    %al,(%edx)
 360:	23 46 0a             	and    0xa(%esi),%eax
 363:	33 02                	xor    (%edx),%eax	363: R_386_32	.debug_str
 365:	00 00                	add    %al,(%eax)
 367:	08 34 01             	or     %dh,(%ecx,%eax,1)
 36a:	43                   	inc    %ebx
 36b:	04 00                	add    $0x0,%al
 36d:	00 02                	add    %al,(%edx)
 36f:	23 47 0a             	and    0xa(%edi),%eax
 372:	82                   	(bad)  	372: R_386_32	.debug_str
 373:	01 00                	add    %eax,(%eax)
 375:	00 08                	add    %cl,(%eax)
 377:	38 01                	cmp    %al,(%ecx)
 379:	53                   	push   %ebx
 37a:	04 00                	add    $0x0,%al
 37c:	00 02                	add    %al,(%edx)
 37e:	23 48 0a             	and    0xa(%eax),%ecx
 381:	7e 00                	jle    383 <.debug_info+0x383>	381: R_386_32	.debug_str
 383:	00 00                	add    %al,(%eax)
 385:	08 41 01             	or     %al,0x1(%ecx)
 388:	ce                   	into   
 389:	00 00                	add    %al,(%eax)
 38b:	00 02                	add    %al,(%edx)
 38d:	23 4c 0a d8          	and    -0x28(%edx,%ecx,1),%ecx	390: R_386_32	.debug_str
 391:	01 00                	add    %eax,(%eax)
 393:	00 08                	add    %cl,(%eax)
 395:	4a                   	dec    %edx
 396:	01 e4                	add    %esp,%esp
 398:	00 00                	add    %al,(%eax)
 39a:	00 02                	add    %al,(%edx)
 39c:	23 54 0a 50          	and    0x50(%edx,%ecx,1),%edx	39f: R_386_32	.debug_str
 3a0:	02 00                	add    (%eax),%al
 3a2:	00 08                	add    %cl,(%eax)
 3a4:	4b                   	dec    %ebx
 3a5:	01 e4                	add    %esp,%esp
 3a7:	00 00                	add    %al,(%eax)
 3a9:	00 02                	add    %al,(%edx)
 3ab:	23 58 0a             	and    0xa(%eax),%ebx
 3ae:	c7 02 00 00 08 4c    	movl   $0x4c080000,(%edx)	3ae: R_386_32	.debug_str
 3b4:	01 e4                	add    %esp,%esp
 3b6:	00 00                	add    %al,(%eax)
 3b8:	00 02                	add    %al,(%edx)
 3ba:	23 5c 0a ce          	and    -0x32(%edx,%ecx,1),%ebx	3bd: R_386_32	.debug_str
 3be:	02 00                	add    (%eax),%al
 3c0:	00 08                	add    %cl,(%eax)
 3c2:	4d                   	dec    %ebp
 3c3:	01 e4                	add    %esp,%esp
 3c5:	00 00                	add    %al,(%eax)
 3c7:	00 02                	add    %al,(%edx)
 3c9:	23 60 0a             	and    0xa(%eax),%esp
 3cc:	88 02                	mov    %al,(%edx)	3cc: R_386_32	.debug_str
 3ce:	00 00                	add    %al,(%eax)
 3d0:	08 4e 01             	or     %cl,0x1(%esi)
 3d3:	09 01                	or     %eax,(%ecx)
 3d5:	00 00                	add    %al,(%eax)
 3d7:	02 23                	add    (%ebx),%ah
 3d9:	64 0a 8d 03 00 00 08 	or     %fs:0x8000003(%ebp),%cl	3db: R_386_32	.debug_str
 3e0:	50                   	push   %eax
 3e1:	01 4f 00             	add    %ecx,0x0(%edi)
 3e4:	00 00                	add    %al,(%eax)
 3e6:	02 23                	add    (%ebx),%ah
 3e8:	68 0a 66 02 00       	push   $0x2660a	3ea: R_386_32	.debug_str
 3ed:	00 08                	add    %cl,(%eax)
 3ef:	52                   	push   %edx
 3f0:	01 59 04             	add    %ebx,0x4(%ecx)
 3f3:	00 00                	add    %al,(%eax)
 3f5:	02 23                	add    (%ebx),%ah
 3f7:	6c                   	insb   (%dx),%es:(%edi)
 3f8:	00 0b                	add    %cl,(%ebx)
 3fa:	17                   	pop    %ss	3fa: R_386_32	.debug_str
 3fb:	04 00                	add    $0x0,%al
 3fd:	00 08                	add    %cl,(%eax)
 3ff:	b6 07                	mov    $0x7,%dh
 401:	28 02                	sub    %al,(%edx)	401: R_386_32	.debug_str
 403:	00 00                	add    %al,(%eax)
 405:	0c 08                	or     $0x8,%al
 407:	bc 37 04 00 00       	mov    $0x437,%esp
 40c:	08 b0 02 00 00 08    	or     %dh,0x8000002(%eax)	40d: R_386_32	.debug_str
 412:	bd 37 04 00 00       	mov    $0x437,%ebp
 417:	02 23                	add    (%ebx),%ah
 419:	00 08                	add    %cl,(%eax)
 41b:	ec                   	in     (%dx),%al	41b: R_386_32	.debug_str
 41c:	03 00                	add    (%eax),%eax
 41e:	00 08                	add    %cl,(%eax)
 420:	be 3d 04 00 00       	mov    $0x43d,%esi
 425:	02 23                	add    (%ebx),%ah
 427:	04 08                	add    $0x8,%al
 429:	ae                   	scas   %es:(%edi),%al	429: R_386_32	.debug_str
 42a:	01 00                	add    %eax,(%eax)
 42c:	00 08                	add    %cl,(%eax)
 42e:	c2 4f 00             	ret    $0x4f
 431:	00 00                	add    %al,(%eax)
 433:	02 23                	add    (%ebx),%ah
 435:	08 00                	or     %al,(%eax)
 437:	06                   	push   %es
 438:	04 00                	add    $0x0,%al
 43a:	04 00                	add    $0x0,%al
 43c:	00 06                	add    %al,(%esi)
 43e:	04 38                	add    $0x38,%al
 440:	02 00                	add    (%eax),%al
 442:	00 0c 02             	add    %cl,(%edx,%eax,1)
 445:	01 00                	add    %eax,(%eax)
 447:	00 53 04             	add    %dl,0x4(%ebx)
 44a:	00 00                	add    %al,(%eax)
 44c:	0d 33 00 00 00       	or     $0x33,%eax
 451:	00 00                	add    %al,(%eax)
 453:	06                   	push   %es
 454:	04 f9                	add    $0xf9,%al
 456:	03 00                	add    (%eax),%eax
 458:	00 0c 02             	add    %cl,(%edx,%eax,1)
 45b:	01 00                	add    %eax,(%eax)
 45d:	00 69 04             	add    %ch,0x4(%ecx)
 460:	00 00                	add    %al,(%eax)
 462:	0d 33 00 00 00       	or     $0x33,%eax
 467:	27                   	daa    
 468:	00 06                	add    %al,(%esi)
 46a:	04 6f                	add    $0x6f,%al
 46c:	04 00                	add    $0x0,%al
 46e:	00 0e                	add    %cl,(%esi)
 470:	02 01                	add    (%ecx),%al
 472:	00 00                	add    %al,(%eax)
 474:	0f 04                	(bad)  
 476:	0a 31                	or     (%ecx),%dh
 478:	d0 04 00             	rolb   (%eax,%eax,1)
 47b:	00 10                	add    %dl,(%eax)
 47d:	ab                   	stos   %eax,%es:(%edi)	47d: R_386_32	.debug_str
 47e:	03 00                	add    (%eax),%eax
 480:	00 80 02 10 a0 02    	add    %al,0x2a01002(%eax)	484: R_386_32	.debug_str
 486:	00 00                	add    %al,(%eax)
 488:	80 04 10 fc          	addb   $0xfc,(%eax,%edx,1)	48b: R_386_32	.debug_str
 48c:	03 00                	add    (%eax),%eax
 48e:	00 80 08 10 e7 00    	add    %al,0xe71008(%eax)	492: R_386_32	.debug_str
 494:	00 00                	add    %al,(%eax)
 496:	80 10 10             	adcb   $0x10,(%eax)
 499:	bd 02 00 00 80       	mov    $0x80000002,%ebp	499: R_386_32	.debug_str
 49e:	20 10                	and    %dl,(%eax)
 4a0:	64 01 00             	add    %eax,%fs:(%eax)	4a0: R_386_32	.debug_str
 4a3:	00 80 c0 00 10 84    	add    %al,-0x7befff40(%eax)	4a8: R_386_32	.debug_str
 4a9:	03 00                	add    (%eax),%eax
 4ab:	00 80 80 01 10 6c    	add    %al,0x6c100180(%eax)	4b0: R_386_32	.debug_str
 4b1:	00 00                	add    %al,(%eax)
 4b3:	00 80 80 02 10 47    	add    %al,0x47100280(%eax)	4b8: R_386_32	.debug_str
 4b9:	01 00                	add    %eax,(%eax)
 4bb:	00 01                	add    %al,(%ecx)
 4bd:	10 24 00             	adc    %ah,(%eax,%eax,1)	4be: R_386_32	.debug_str
 4c0:	00 00                	add    %al,(%eax)
 4c2:	02 10                	add    (%eax),%dl
 4c4:	75 00                	jne    4c6 <.debug_info+0x4c6>	4c4: R_386_32	.debug_str
 4c6:	00 00                	add    %al,(%eax)
 4c8:	04 10                	add    $0x10,%al
 4ca:	50                   	push   %eax	4ca: R_386_32	.debug_str
 4cb:	01 00                	add    %eax,(%eax)
 4cd:	00 08                	add    %cl,(%eax)
 4cf:	00 11                	add    %dl,(%ecx)
 4d1:	01 b6 02 00 00 02    	add    %esi,0x2000002(%esi)	4d2: R_386_32	.debug_str
 4d7:	67 01 fc             	addr16 add %edi,%esp
 4da:	00 00                	add    %al,(%eax)
 4dc:	00 03                	add    %al,(%ebx)
 4de:	01 fa                	add    %edi,%edx
 4e0:	04 00                	add    $0x0,%al
 4e2:	00 12                	add    %dl,(%edx)
 4e4:	91                   	xchg   %eax,%ecx	4e4: R_386_32	.debug_str
 4e5:	01 00                	add    %eax,(%eax)
 4e7:	00 02                	add    %al,(%edx)
 4e9:	67 fc                	addr16 cld 
 4eb:	00 00                	add    %al,(%eax)
 4ed:	00 12                	add    %dl,(%edx)
 4ef:	e6 01                	out    %al,$0x1	4ef: R_386_32	.debug_str
 4f1:	00 00                	add    %al,(%eax)
 4f3:	02 67 69             	add    0x69(%edi),%ah
 4f6:	04 00                	add    $0x0,%al
 4f8:	00 00                	add    %al,(%eax)
 4fa:	11 01                	adc    %eax,(%ecx)
 4fc:	a9 02 00 00 02       	test   $0x2000002,%eax	4fc: R_386_32	.debug_str
 501:	8e 01                	mov    (%ecx),%es
 503:	fc                   	cld    
 504:	00 00                	add    %al,(%eax)
 506:	00 03                	add    %al,(%ebx)
 508:	01 24 05 00 00 12 91 	add    %esp,-0x6eee0000(,%eax,1)	50e: R_386_32	.debug_str
 50f:	01 00                	add    %eax,(%eax)
 511:	00 02                	add    %al,(%edx)
 513:	8e fc                	mov    %esp,%?
 515:	00 00                	add    %al,(%eax)
 517:	00 12                	add    %dl,(%edx)
 519:	e6 01                	out    %al,$0x1	519: R_386_32	.debug_str
 51b:	00 00                	add    %al,(%eax)
 51d:	02 8e 69 04 00 00    	add    0x469(%esi),%cl
 523:	00 13                	add    %dl,(%ebx)
 525:	01 df                	add    %ebx,%edi	526: R_386_32	.debug_str
 527:	03 00                	add    (%eax),%eax
 529:	00 03                	add    %al,(%ebx)
 52b:	c7 01 01 4f 00 00    	movl   $0x4f01,(%ecx)
 531:	00 03                	add    %al,(%ebx)
 533:	50                   	push   %eax
 534:	05 00 00 14 a3       	add    $0xa3140000,%eax	538: R_386_32	.debug_str
 539:	00 00                	add    %al,(%eax)
 53b:	00 03                	add    %al,(%ebx)
 53d:	c7 01 69 04 00 00    	movl   $0x469,(%ecx)
 543:	14 a1                	adc    $0xa1,%al	544: R_386_32	.debug_str
 545:	03 00                	add    (%eax),%eax
 547:	00 03                	add    %al,(%ebx)
 549:	c7 01 50 05 00 00    	movl   $0x550,(%ecx)
 54f:	00 06                	add    %al,(%esi)
 551:	04 3d                	add    $0x3d,%al
 553:	01 00                	add    %eax,(%eax)
 555:	00 15 01 ec 01 00    	add    %dl,0x1ec01	558: R_386_32	.debug_str
 55b:	00 01                	add    %al,(%ecx)
 55d:	25 01 4f 00 00       	and    $0x4f01,%eax
 562:	00 00                	add    %al,(%eax)	563: R_386_32	.text
 564:	00 00                	add    %al,(%eax)
 566:	00 9d 01 00 00 00    	add    %bl,0x1(%ebp)	567: R_386_32	.text
	56b: R_386_32	.debug_loc
 56c:	00 00                	add    %al,(%eax)
 56e:	00 05 06 00 00 16    	add    %al,0x16000006
 574:	14 03                	adc    $0x3,%al	574: R_386_32	.debug_str
 576:	00 00                	add    %al,(%eax)
 578:	01 25 fc 00 00 00    	add    %esp,0xfc
 57e:	02 91 00 16 33 01    	add    0x1331600(%ecx),%dl	582: R_386_32	.debug_str
 584:	00 00                	add    %al,(%eax)
 586:	01 25 05 06 00 00    	add    %esp,0x605
 58c:	02 91 04 16 3e 01    	add    0x13e1604(%ecx),%dl	590: R_386_32	.debug_str
 592:	00 00                	add    %al,(%eax)
 594:	01 26                	add    %esp,(%esi)
 596:	05 06 00 00 02       	add    $0x2000006,%eax
 59b:	91                   	xchg   %eax,%ecx
 59c:	08 17                	or     %dl,(%edi)
 59e:	66                   	data16
 59f:	6e                   	outsb  %ds:(%esi),(%dx)
 5a0:	00 01                	add    %al,(%ecx)
 5a2:	28 fc                	sub    %bh,%ah
 5a4:	00 00                	add    %al,(%eax)
 5a6:	00 8d 00 00 00 17    	add    %cl,0x17000000(%ebp)	5a7: R_386_32	.debug_loc
 5ac:	73 70                	jae    61e <.debug_info+0x61e>
 5ae:	00 01                	add    %al,(%ecx)
 5b0:	29 fc                	sub    %edi,%esp
 5b2:	00 00                	add    %al,(%eax)
 5b4:	00 c5                	add    %al,%ch	5b5: R_386_32	.debug_loc
 5b6:	00 00                	add    %al,(%eax)
 5b8:	00 18                	add    %bl,(%eax)
 5ba:	62 75 66             	bound  %esi,0x66(%ebp)
 5bd:	00 01                	add    %al,(%ecx)
 5bf:	2a 3d 01 00 00 03    	sub    0x3000001,%bh
 5c5:	91                   	xchg   %eax,%ecx
 5c6:	88 7f 17             	mov    %bh,0x17(%edi)
 5c9:	69 00 01 2b 4f 00    	imul   $0x4f2b01,(%eax),%eax
 5cf:	00 00                	add    %al,(%eax)
 5d1:	ee                   	out    %al,(%dx)	5d1: R_386_32	.debug_loc
 5d2:	00 00                	add    %al,(%eax)
 5d4:	00 17                	add    %dl,(%edi)
 5d6:	6a 00                	push   $0x0
 5d8:	01 2c 4f             	add    %ebp,(%edi,%ecx,2)
 5db:	00 00                	add    %al,(%eax)
 5dd:	00 02                	add    %al,(%edx)	5de: R_386_32	.debug_loc
 5df:	01 00                	add    %eax,(%eax)
 5e1:	00 19                	add    %bl,(%ecx)
 5e3:	24 05                	and    $0x5,%al
 5e5:	00 00                	add    %al,(%eax)
 5e7:	fa                   	cli    	5e7: R_386_32	.text
 5e8:	00 00                	add    %al,(%eax)
 5ea:	00 12                	add    %dl,(%edx)	5eb: R_386_32	.text
 5ec:	01 00                	add    %eax,(%eax)
 5ee:	00 01                	add    %al,(%ecx)
 5f0:	44                   	inc    %esp
 5f1:	1a 43 05             	sbb    0x5(%ebx),%al
 5f4:	00 00                	add    %al,(%eax)
 5f6:	16                   	push   %ss	5f6: R_386_32	.debug_loc
 5f7:	01 00                	add    %eax,(%eax)
 5f9:	00 1a                	add    %bl,(%edx)
 5fb:	37                   	aaa    
 5fc:	05 00 00 3a 01       	add    $0x13a0000,%eax	5ff: R_386_32	.debug_loc
 601:	00 00                	add    %al,(%eax)
 603:	00 00                	add    %al,(%eax)
 605:	06                   	push   %es
 606:	04 69                	add    $0x69,%al
 608:	04 00                	add    $0x0,%al
 60a:	00 1b                	add    %bl,(%ebx)
 60c:	75 03                	jne    611 <.debug_info+0x611>	60c: R_386_32	.debug_str
 60e:	00 00                	add    %al,(%eax)
 610:	09 a9 3d 04 00 00    	or     %ebp,0x43d(%ecx)
 616:	01 01                	add    %eax,(%ecx)
 618:	1b 10                	sbb    (%eax),%edx	619: R_386_32	.debug_str
 61a:	04 00                	add    $0x0,%al
 61c:	00 09                	add    %cl,(%ecx)
 61e:	aa                   	stos   %al,%es:(%edi)
 61f:	3d 04 00 00 01       	cmp    $0x1000004,%eax
 624:	01 00                	add    %eax,(%eax)

Disassembly of section .debug_abbrev:

00000000 <.debug_abbrev>:

#include "conf.h"

int conf_lookup(char * pathname, const char ** searchpath, 
				const char ** filename)
{
   0:	01 11                	add    %edx,(%ecx)
   2:	01 25 0e 13 0b 03    	add    %esp,0x30b130e
   8:	0e                   	push   %cs
   9:	1b 0e                	sbb    (%esi),%ecx
   b:	11 01                	adc    %eax,(%ecx)
   d:	12 01                	adc    (%ecx),%al
   f:	10 06                	adc    %al,(%esi)
	char * sp;
	struct stat buf;
	int i;
	int j;

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
  11:	00 00                	add    %al,(%eax)
  13:	02 24 00             	add    (%eax,%eax,1),%ah
  16:	0b 0b                	or     (%ebx),%ecx
  18:	3e 0b 03             	or     %ds:(%ebx),%eax
  1b:	0e                   	push   %cs
  1c:	00 00                	add    %al,(%eax)
  1e:	03 24 00             	add    (%eax,%eax,1),%esp
  21:	0b 0b                	or     (%ebx),%ecx
  23:	3e 0b 03             	or     %ds:(%ebx),%eax
  26:	08 00                	or     %al,(%eax)
  28:	00 04 16             	add    %al,(%esi,%edx,1)
  2b:	00 03                	add    %al,(%ebx)
  2d:	0e                   	push   %cs
  2e:	3a 0b                	cmp    (%ebx),%cl
  30:	3b 0b                	cmp    (%ebx),%ecx
  32:	49                   	dec    %ecx
  33:	13 00                	adc    (%eax),%eax
		return -1;

	for (i = 0; filename[i] != NULL; i++) {
  35:	00 05 0f 00 0b 0b    	add    %al,0xb0b000f

			}
		}
	}

	return -1;
  3b:	00 00                	add    %al,(%eax)
	int j;

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
		return -1;

	for (i = 0; filename[i] != NULL; i++) {
  3d:	06                   	push   %es
  3e:	0f 00 0b             	str    (%ebx)
  41:	0b 49 13             	or     0x13(%ecx),%ecx
  44:	00 00                	add    %al,(%eax)
  46:	07                   	pop    %es
  47:	13 01                	adc    (%ecx),%eax
  49:	03 0e                	add    (%esi),%ecx
  4b:	0b 0b                	or     (%ebx),%ecx
		for(fn = (char *)filename[i]; (*fn != '\0') && (*fn != '/') 
				&& (isspace(*fn)); fn++);
  4d:	3a 0b                	cmp    (%ebx),%cl
  4f:	3b 0b                	cmp    (%ebx),%ecx

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
		return -1;

	for (i = 0; filename[i] != NULL; i++) {
		for(fn = (char *)filename[i]; (*fn != '\0') && (*fn != '/') 
  51:	01 13                	add    %edx,(%ebx)
  53:	00 00                	add    %al,(%eax)
  55:	08 0d 00 03 0e 3a    	or     %cl,0x3a0e0300
  5b:	0b 3b                	or     (%ebx),%edi
				&& (isspace(*fn)); fn++);
  5d:	0b 49 13             	or     0x13(%ecx),%ecx
  60:	38 0a                	cmp    %cl,(%edx)
  62:	00 00                	add    %al,(%eax)
  64:	09 13                	or     %edx,(%ebx)
  66:	01 03                	add    %eax,(%ebx)
		if (*fn == '\0')
  68:	0e                   	push   %cs
  69:	0b 0b                	or     (%ebx),%ecx
  6b:	3a 0b                	cmp    (%ebx),%cl
  6d:	3b 05 01 13 00 00    	cmp    0x1301,%eax
			continue;

		for (j = 0; searchpath[j] != NULL; j++) {
  73:	0a 0d 00 03 0e 3a    	or     0x3a0e0300,%cl
  79:	0b 3b                	or     (%ebx),%edi
  7b:	05 49 13 38 0a       	add    $0xa381349,%eax
  80:	00 00                	add    %al,(%eax)
  82:	0b 16                	or     (%esi),%edx
  84:	00 03                	add    %al,(%ebx)
  86:	0e                   	push   %cs
  87:	3a 0b                	cmp    (%ebx),%cl
  89:	3b 0b                	cmp    (%ebx),%ecx
  8b:	00 00                	add    %al,(%eax)
  8d:	0c 01                	or     $0x1,%al
  8f:	01 49 13             	add    %ecx,0x13(%ecx)
  92:	01 13                	add    %edx,(%ebx)

			for(sp = (char *)searchpath[j]; (*sp != '\0') && 
				(isspace(*sp)); sp++);
  94:	00 00                	add    %al,(%eax)
  96:	0d 21 00 49 13       	or     $0x13490021,%eax
		if (*fn == '\0')
			continue;

		for (j = 0; searchpath[j] != NULL; j++) {

			for(sp = (char *)searchpath[j]; (*sp != '\0') && 
  9b:	2f                   	das    
  9c:	0b 00                	or     (%eax),%eax
				(isspace(*sp)); sp++);
  9e:	00 0e                	add    %cl,(%esi)
  a0:	26 00 49 13          	add    %cl,%es:0x13(%ecx)
		if (*fn == '\0')
			continue;

		for (j = 0; searchpath[j] != NULL; j++) {

			for(sp = (char *)searchpath[j]; (*sp != '\0') && 
  a4:	00 00                	add    %al,(%eax)
  a6:	0f 04                	(bad)  
				(isspace(*sp)); sp++);

			/* very basic shell expansion */
			if (*sp == '~') {
  a8:	01 0b                	add    %ecx,(%ebx)
  aa:	0b 3a                	or     (%edx),%edi
  ac:	0b 3b                	or     (%ebx),%edi
				strcpy(pathname, getenv("HOME"));
  ae:	0b 01                	or     (%ecx),%eax
  b0:	13 00                	adc    (%eax),%eax
  b2:	00 10                	add    %dl,(%eax)
  b4:	28 00                	sub    %al,(%eax)
  b6:	03 0e                	add    (%esi),%ecx
  b8:	1c 0d                	sbb    $0xd,%al
#endif

__extern_always_inline char *
__NTH (strcpy (char *__restrict __dest, __const char *__restrict __src))
{
  return __builtin___strcpy_chk (__dest, __src, __bos (__dest));
  ba:	00 00                	add    %al,(%eax)
  bc:	11 2e                	adc    %ebp,(%esi)
  be:	01 3f                	add    %edi,(%edi)
  c0:	0c 03                	or     $0x3,%al
  c2:	0e                   	push   %cs
  c3:	3a 0b                	cmp    (%ebx),%cl
  c5:	3b 0b                	cmp    (%ebx),%ecx
  c7:	27                   	daa    
  c8:	0c 49                	or     $0x49,%al
  ca:	13 20                	adc    (%eax),%esp
  cc:	0b 34 0c             	or     (%esp,%ecx,1),%esi
  cf:	01 13                	add    %edx,(%ebx)
  d1:	00 00                	add    %al,(%eax)


__extern_always_inline char *
__NTH (strcat (char *__restrict __dest, __const char *__restrict __src))
{
  return __builtin___strcat_chk (__dest, __src, __bos (__dest));
  d3:	12 05 00 03 0e 3a    	adc    0x3a0e0300,%al
  d9:	0b 3b                	or     (%ebx),%edi
  db:	0b 49 13             	or     0x13(%ecx),%ecx
  de:	00 00                	add    %al,(%eax)
  e0:	13 2e                	adc    (%esi),%ebp
  e2:	01 3f                	add    %edi,(%edi)
  e4:	0c 03                	or     $0x3,%al
  e6:	0e                   	push   %cs
  e7:	3a 0b                	cmp    (%ebx),%cl
  e9:	3b 05 27 0c 49 13    	cmp    0x13490c27,%eax
  ef:	20 0b                	and    %cl,(%ebx)
  f1:	01 13                	add    %edx,(%ebx)
  f3:	00 00                	add    %al,(%eax)
  f5:	14 05                	adc    $0x5,%al
  f7:	00 03                	add    %al,(%ebx)
  f9:	0e                   	push   %cs
			} else 
				strcpy(pathname, sp);
			strcat(pathname, "/");
			strcat(pathname, fn);

			if (stat(pathname, &buf) == 0) {
  fa:	3a 0b                	cmp    (%ebx),%cl
  fc:	3b 05 49 13 00 00    	cmp    0x1349,%eax
 102:	15 2e 01 3f 0c       	adc    $0xc3f012e,%eax
 107:	03 0e                	add    (%esi),%ecx
 109:	3a 0b                	cmp    (%ebx),%cl
 10b:	3b 0b                	cmp    (%ebx),%ecx
 10d:	27                   	daa    
 10e:	0c 49                	or     $0x49,%al
 110:	13 11                	adc    (%ecx),%edx
 112:	01 12                	add    %edx,(%edx)
 114:	01 40 06             	add    %eax,0x6(%eax)

				if (S_ISREG(buf.st_mode))
 117:	01 13                	add    %edx,(%ebx)
 119:	00 00                	add    %al,(%eax)
 11b:	16                   	push   %ss
 11c:	05 00 03 0e 3a       	add    $0x3a0e0300,%eax
 121:	0b 3b                	or     (%ebx),%edi
 123:	0b 49 13             	or     0x13(%ecx),%ecx
 126:	02 0a                	add    (%edx),%cl
 128:	00 00                	add    %al,(%eax)
 12a:	17                   	pop    %ss
		for(fn = (char *)filename[i]; (*fn != '\0') && (*fn != '/') 
				&& (isspace(*fn)); fn++);
		if (*fn == '\0')
			continue;

		for (j = 0; searchpath[j] != NULL; j++) {
 12b:	34 00                	xor    $0x0,%al
 12d:	03 08                	add    (%eax),%ecx
 12f:	3a 0b                	cmp    (%ebx),%cl
 131:	3b 0b                	cmp    (%ebx),%ecx
 133:	49                   	dec    %ecx
 134:	13 02                	adc    (%edx),%eax

			for(sp = (char *)searchpath[j]; (*sp != '\0') && 
 136:	06                   	push   %es
 137:	00 00                	add    %al,(%eax)
 139:	18 34 00             	sbb    %dh,(%eax,%eax,1)
				(isspace(*sp)); sp++);
 13c:	03 08                	add    (%eax),%ecx
 13e:	3a 0b                	cmp    (%ebx),%cl
 140:	3b 0b                	cmp    (%ebx),%ecx
 142:	49                   	dec    %ecx
 143:	13 02                	adc    (%edx),%eax
 145:	0a 00                	or     (%eax),%al
 147:	00 19                	add    %bl,(%ecx)
 149:	1d 01 31 13 11       	sbb    $0x11133101,%eax
	int j;

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
		return -1;

	for (i = 0; filename[i] != NULL; i++) {
 14e:	01 12                	add    %edx,(%edx)
 150:	01 58 0b             	add    %ebx,0xb(%eax)
 153:	59                   	pop    %ecx
 154:	0b 00                	or     (%eax),%eax
 156:	00 1a                	add    %bl,(%edx)
		for(fn = (char *)filename[i]; (*fn != '\0') && (*fn != '/') 
 158:	05 00 31 13 02       	add    $0x2133100,%eax
 15d:	06                   	push   %es
 15e:	00 00                	add    %al,(%eax)
 160:	1b 34 00             	sbb    (%eax,%eax,1),%esi
 163:	03 0e                	add    (%esi),%ecx
 165:	3a 0b                	cmp    (%ebx),%cl
 167:	3b 0b                	cmp    (%ebx),%ecx
 169:	49                   	dec    %ecx
 16a:	13 3f                	adc    (%edi),%edi
				&& (isspace(*fn)); fn++);
 16c:	0c 3c                	or     $0x3c,%al
 16e:	0c 00                	or     $0x0,%al
 170:	00 00                	add    %al,(%eax)

Disassembly of section .debug_loc:

00000000 <.debug_loc>:

#include "conf.h"

int conf_lookup(char * pathname, const char ** searchpath, 
				const char ** filename)
{
   0:	00 00                	add    %al,(%eax)
   2:	00 00                	add    %al,(%eax)
   4:	01 00                	add    %eax,(%eax)
   6:	00 00                	add    %al,(%eax)
   8:	02 00                	add    (%eax),%al
   a:	74 04                	je     10 <.debug_loc+0x10>
   c:	01 00                	add    %eax,(%eax)
   e:	00 00                	add    %al,(%eax)
  10:	02 00                	add    (%eax),%al
	char * sp;
	struct stat buf;
	int i;
	int j;

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
  12:	00 00                	add    %al,(%eax)
  14:	02 00                	add    (%eax),%al
  16:	74 08                	je     20 <.debug_loc+0x20>
  18:	02 00                	add    (%eax),%al
  1a:	00 00                	add    %al,(%eax)
  1c:	03 00                	add    (%eax),%eax
  1e:	00 00                	add    %al,(%eax)
  20:	02 00                	add    (%eax),%al
  22:	74 0c                	je     30 <.debug_loc+0x30>
  24:	03 00                	add    (%eax),%eax
  26:	00 00                	add    %al,(%eax)
  28:	04 00                	add    $0x0,%al
  2a:	00 00                	add    %al,(%eax)
  2c:	02 00                	add    (%eax),%al
  2e:	74 10                	je     40 <.debug_loc+0x40>
  30:	04 00                	add    $0x0,%al
  32:	00 00                	add    %al,(%eax)
  34:	0a 00                	or     (%eax),%al
		return -1;

	for (i = 0; filename[i] != NULL; i++) {
  36:	00 00                	add    %al,(%eax)

			}
		}
	}

	return -1;
  38:	02 00                	add    (%eax),%al
  3a:	74 14                	je     50 <.debug_loc+0x50>
	int j;

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
		return -1;

	for (i = 0; filename[i] != NULL; i++) {
  3c:	0a 00                	or     (%eax),%al
  3e:	00 00                	add    %al,(%eax)
  40:	98                   	cwtl   
  41:	01 00                	add    %eax,(%eax)
  43:	00 03                	add    %al,(%ebx)
  45:	00 74 a0 01          	add    %dh,0x1(%eax,%eiz,4)
  49:	98                   	cwtl   
  4a:	01 00                	add    %eax,(%eax)
  4c:	00 99 01 00 00 02    	add    %bl,0x2000001(%ecx)
		for(fn = (char *)filename[i]; (*fn != '\0') && (*fn != '/') 
  52:	00 74 14 99          	add    %dh,-0x67(%esp,%edx,1)
  56:	01 00                	add    %eax,(%eax)
  58:	00 9a 01 00 00 02    	add    %bl,0x2000001(%edx)
				&& (isspace(*fn)); fn++);
  5e:	00 74 10 9a          	add    %dh,-0x66(%eax,%edx,1)
  62:	01 00                	add    %eax,(%eax)
  64:	00 9b 01 00 00 02    	add    %bl,0x2000001(%ebx)
		if (*fn == '\0')
  6a:	00 74 0c 9b          	add    %dh,-0x65(%esp,%ecx,1)
  6e:	01 00                	add    %eax,(%eax)
			continue;

		for (j = 0; searchpath[j] != NULL; j++) {
  70:	00 9c 01 00 00 02 00 	add    %bl,0x20000(%ecx,%eax,1)
  77:	74 08                	je     81 <.debug_loc+0x81>
  79:	9c                   	pushf  
  7a:	01 00                	add    %eax,(%eax)
  7c:	00 9d 01 00 00 02    	add    %bl,0x2000001(%ebp)
  82:	00 74 04 00          	add    %dh,0x0(%esp,%eax,1)
  86:	00 00                	add    %al,(%eax)
  88:	00 00                	add    %al,(%eax)
  8a:	00 00                	add    %al,(%eax)
  8c:	00 4d 00             	add    %cl,0x0(%ebp)
  8f:	00 00                	add    %al,(%eax)
  91:	8f 00                	popl   (%eax)
  93:	00 00                	add    %al,(%eax)

			for(sp = (char *)searchpath[j]; (*sp != '\0') && 
				(isspace(*sp)); sp++);
  95:	01 00                	add    %eax,(%eax)
		if (*fn == '\0')
			continue;

		for (j = 0; searchpath[j] != NULL; j++) {

			for(sp = (char *)searchpath[j]; (*sp != '\0') && 
  97:	55                   	push   %ebp
  98:	8f 00                	popl   (%eax)
  9a:	00 00                	add    %al,(%eax)
  9c:	48                   	dec    %eax
  9d:	01 00                	add    %eax,(%eax)
				(isspace(*sp)); sp++);
  9f:	00 03                	add    %al,(%ebx)
		if (*fn == '\0')
			continue;

		for (j = 0; searchpath[j] != NULL; j++) {

			for(sp = (char *)searchpath[j]; (*sp != '\0') && 
  a1:	00 91 f8 7e 57 01    	add    %dl,0x1577ef8(%ecx)
  a7:	00 00                	add    %al,(%eax)
				(isspace(*sp)); sp++);

			/* very basic shell expansion */
			if (*sp == '~') {
  a9:	78 01                	js     ac <.debug_loc+0xac>
  ab:	00 00                	add    %al,(%eax)
				strcpy(pathname, getenv("HOME"));
  ad:	01 00                	add    %eax,(%eax)
  af:	55                   	push   %ebp
  b0:	86 01                	xchg   %al,(%ecx)
  b2:	00 00                	add    %al,(%eax)
  b4:	8d 01                	lea    (%ecx),%eax
  b6:	00 00                	add    %al,(%eax)
  b8:	03 00                	add    (%eax),%eax
#endif

__extern_always_inline char *
__NTH (strcpy (char *__restrict __dest, __const char *__restrict __src))
{
  return __builtin___strcpy_chk (__dest, __src, __bos (__dest));
  ba:	91                   	xchg   %eax,%ecx
  bb:	f8                   	clc    
  bc:	7e 00                	jle    be <.debug_loc+0xbe>
  be:	00 00                	add    %al,(%eax)
  c0:	00 00                	add    %al,(%eax)
  c2:	00 00                	add    %al,(%eax)
  c4:	00 94 00 00 00 31 01 	add    %dl,0x1310000(%eax,%eax,1)
  cb:	00 00                	add    %al,(%eax)
  cd:	01 00                	add    %eax,(%eax)
  cf:	56                   	push   %esi
  d0:	35 01 00 00 48       	xor    $0x48000001,%eax


__extern_always_inline char *
__NTH (strcat (char *__restrict __dest, __const char *__restrict __src))
{
  return __builtin___strcat_chk (__dest, __src, __bos (__dest));
  d5:	01 00                	add    %eax,(%eax)
  d7:	00 01                	add    %al,(%ecx)
  d9:	00 56 86             	add    %dl,-0x7a(%esi)
  dc:	01 00                	add    %eax,(%eax)
  de:	00 8d 01 00 00 01    	add    %cl,0x1000001(%ebp)
  e4:	00 56 00             	add    %dl,0x0(%esi)
  e7:	00 00                	add    %al,(%eax)
  e9:	00 00                	add    %al,(%eax)
  eb:	00 00                	add    %al,(%eax)
  ed:	00 35 00 00 00 4d    	add    %dh,0x4d000000
  f3:	00 00                	add    %al,(%eax)
  f5:	00 02                	add    %al,(%edx)
  f7:	00 30                	add    %dh,(%eax)
  f9:	9f                   	lahf   
			} else 
				strcpy(pathname, sp);
			strcat(pathname, "/");
			strcat(pathname, fn);

			if (stat(pathname, &buf) == 0) {
  fa:	00 00                	add    %al,(%eax)
  fc:	00 00                	add    %al,(%eax)
  fe:	00 00                	add    %al,(%eax)
 100:	00 00                	add    %al,(%eax)
 102:	6f                   	outsl  %ds:(%esi),(%dx)
 103:	00 00                	add    %al,(%eax)
 105:	00 94 00 00 00 02 00 	add    %dl,0x20000(%eax,%eax,1)
 10c:	30 9f 00 00 00 00    	xor    %bl,0x0(%edi)
 112:	00 00                	add    %al,(%eax)
 114:	00 00                	add    %al,(%eax)

				if (S_ISREG(buf.st_mode))
 116:	fa                   	cli    
 117:	00 00                	add    %al,(%eax)
 119:	00 35 01 00 00 04    	add    %dh,0x4000001
 11f:	00 91 88 7f 9f 86    	add    %dl,-0x79608078(%ecx)
 125:	01 00                	add    %eax,(%eax)
 127:	00 8d 01 00 00 04    	add    %cl,0x4000001(%ebp)
		for(fn = (char *)filename[i]; (*fn != '\0') && (*fn != '/') 
				&& (isspace(*fn)); fn++);
		if (*fn == '\0')
			continue;

		for (j = 0; searchpath[j] != NULL; j++) {
 12d:	00 91 88 7f 9f 00    	add    %dl,0x9f7f88(%ecx)
 133:	00 00                	add    %al,(%eax)

			for(sp = (char *)searchpath[j]; (*sp != '\0') && 
 135:	00 00                	add    %al,(%eax)
 137:	00 00                	add    %al,(%eax)
 139:	00 fa                	add    %bh,%dl
 13b:	00 00                	add    %al,(%eax)
				(isspace(*sp)); sp++);
 13d:	00 35 01 00 00 02    	add    %dh,0x2000001
 143:	00 91 00 86 01 00    	add    %dl,0x18600(%ecx)
 149:	00 8d 01 00 00 01    	add    %cl,0x1000001(%ebp)
	int j;

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
		return -1;

	for (i = 0; filename[i] != NULL; i++) {
 14f:	00 55 00             	add    %dl,0x0(%ebp)
 152:	00 00                	add    %al,(%eax)
 154:	00 00                	add    %al,(%eax)
 156:	00 00                	add    %al,(%eax)
		for(fn = (char *)filename[i]; (*fn != '\0') && (*fn != '/') 
 158:	00                   	.byte 0x0

Disassembly of section .debug_aranges:

00000000 <.debug_aranges>:

#include "conf.h"

int conf_lookup(char * pathname, const char ** searchpath, 
				const char ** filename)
{
   0:	1c 00                	sbb    $0x0,%al
   2:	00 00                	add    %al,(%eax)
   4:	02 00                	add    (%eax),%al
   6:	00 00                	add    %al,(%eax)	6: R_386_32	.debug_info
   8:	00 00                	add    %al,(%eax)
   a:	04 00                	add    $0x0,%al
   c:	00 00                	add    %al,(%eax)
   e:	00 00                	add    %al,(%eax)
  10:	00 00                	add    %al,(%eax)	10: R_386_32	.text
	char * sp;
	struct stat buf;
	int i;
	int j;

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
  12:	00 00                	add    %al,(%eax)
  14:	9d                   	popf   
  15:	01 00                	add    %eax,(%eax)
  17:	00 00                	add    %al,(%eax)
  19:	00 00                	add    %al,(%eax)
  1b:	00 00                	add    %al,(%eax)
  1d:	00 00                	add    %al,(%eax)
  1f:	00                   	.byte 0x0

Disassembly of section .debug_line:

00000000 <.debug_line>:

#include "conf.h"

int conf_lookup(char * pathname, const char ** searchpath, 
				const char ** filename)
{
   0:	8a 01                	mov    (%ecx),%al
   2:	00 00                	add    %al,(%eax)
   4:	02 00                	add    (%eax),%al
   6:	f8                   	clc    
   7:	00 00                	add    %al,(%eax)
   9:	00 01                	add    %al,(%ecx)
   b:	01 fb                	add    %edi,%ebx
   d:	0e                   	push   %cs
   e:	0d 00 01 01 01       	or     $0x1010100,%eax
	char * sp;
	struct stat buf;
	int i;
	int j;

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
  13:	01 00                	add    %eax,(%eax)
  15:	00 00                	add    %al,(%eax)
  17:	01 00                	add    %eax,(%eax)
  19:	00 01                	add    %al,(%ecx)
  1b:	2f                   	das    
  1c:	75 73                	jne    91 <.debug_line+0x91>
  1e:	72 2f                	jb     4f <.debug_line+0x4f>
  20:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%esi),%ebp
  27:	2f                   	das    
  28:	69 33 38 36 2d 6c    	imul   $0x6c2d3638,(%ebx),%esi
  2e:	69 6e 75 78 2d 67 6e 	imul   $0x6e672d78,0x75(%esi),%ebp
		return -1;

	for (i = 0; filename[i] != NULL; i++) {
  35:	75 2f                	jne    66 <.debug_line+0x66>

			}
		}
	}

	return -1;
  37:	62 69 74             	bound  %ebp,0x74(%ecx)
  3a:	73 00                	jae    3c <.debug_line+0x3c>
	int j;

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
		return -1;

	for (i = 0; filename[i] != NULL; i++) {
  3c:	2f                   	das    
  3d:	75 73                	jne    b2 <.debug_line+0xb2>
  3f:	72 2f                	jb     70 <.debug_line+0x70>
  41:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%esi),%ebp
  48:	2f                   	das    
  49:	69 33 38 36 2d 6c    	imul   $0x6c2d3638,(%ebx),%esi
		for(fn = (char *)filename[i]; (*fn != '\0') && (*fn != '/') 
				&& (isspace(*fn)); fn++);
  4f:	69 6e 75 78 2d 67 6e 	imul   $0x6e672d78,0x75(%esi),%ebp

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
		return -1;

	for (i = 0; filename[i] != NULL; i++) {
		for(fn = (char *)filename[i]; (*fn != '\0') && (*fn != '/') 
  56:	75 2f                	jne    87 <.debug_line+0x87>
  58:	73 79                	jae    d3 <.debug_line+0xd3>
  5a:	73 00                	jae    5c <.debug_line+0x5c>
  5c:	2f                   	das    
				&& (isspace(*fn)); fn++);
  5d:	75 73                	jne    d2 <.debug_line+0xd2>
  5f:	72 2f                	jb     90 <.debug_line+0x90>
  61:	6c                   	insb   (%dx),%es:(%edi)
  62:	69 62 2f 67 63 63 2f 	imul   $0x2f636367,0x2f(%edx),%esp
		if (*fn == '\0')
  69:	69 36 38 36 2d 6c    	imul   $0x6c2d3638,(%esi),%esi
			continue;

		for (j = 0; searchpath[j] != NULL; j++) {
  6f:	69 6e 75 78 2d 67 6e 	imul   $0x6e672d78,0x75(%esi),%ebp
  76:	75 2f                	jne    a7 <.debug_line+0xa7>
  78:	34 2e                	xor    $0x2e,%al
  7a:	36                   	ss
  7b:	2f                   	das    
  7c:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%esi),%ebp
  83:	00 2f                	add    %ch,(%edi)
  85:	75 73                	jne    fa <.debug_line+0xfa>
  87:	72 2f                	jb     b8 <.debug_line+0xb8>
  89:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%esi),%ebp
  90:	00 00                	add    %al,(%eax)
  92:	6c                   	insb   (%dx),%es:(%edi)
  93:	6f                   	outsl  %ds:(%esi),(%dx)

			for(sp = (char *)searchpath[j]; (*sp != '\0') && 
				(isspace(*sp)); sp++);
  94:	6f                   	outsl  %ds:(%esi),(%dx)
  95:	6b 75 70 2e          	imul   $0x2e,0x70(%ebp),%esi
		if (*fn == '\0')
			continue;

		for (j = 0; searchpath[j] != NULL; j++) {

			for(sp = (char *)searchpath[j]; (*sp != '\0') && 
  99:	63 00                	arpl   %ax,(%eax)
  9b:	00 00                	add    %al,(%eax)
  9d:	00 73 74             	add    %dh,0x74(%ebx)
				(isspace(*sp)); sp++);
  a0:	72 69                	jb     10b <.debug_line+0x10b>
		if (*fn == '\0')
			continue;

		for (j = 0; searchpath[j] != NULL; j++) {

			for(sp = (char *)searchpath[j]; (*sp != '\0') && 
  a2:	6e                   	outsb  %ds:(%esi),(%dx)
  a3:	67 33 2e 68 00       	xor    0x68,%ebp
				(isspace(*sp)); sp++);

			/* very basic shell expansion */
			if (*sp == '~') {
  a8:	01 00                	add    %eax,(%eax)
  aa:	00 73 74             	add    %dh,0x74(%ebx)
				strcpy(pathname, getenv("HOME"));
  ad:	61                   	popa   
  ae:	74 2e                	je     de <.debug_line+0xde>
  b0:	68 00 02 00 00       	push   $0x200
  b5:	74 79                	je     130 <.debug_line+0x130>
  b7:	70 65                	jo     11e <.debug_line+0x11e>
#endif

__extern_always_inline char *
__NTH (strcpy (char *__restrict __dest, __const char *__restrict __src))
{
  return __builtin___strcpy_chk (__dest, __src, __bos (__dest));
  b9:	73 2e                	jae    e9 <.debug_line+0xe9>
  bb:	68 00 01 00 00       	push   $0x100
  c0:	73 74                	jae    136 <.debug_line+0x136>
  c2:	64                   	fs
  c3:	64                   	fs
  c4:	65                   	gs
  c5:	66                   	data16
  c6:	2e                   	cs
  c7:	68 00 03 00 00       	push   $0x300
  cc:	74 69                	je     137 <.debug_line+0x137>
  ce:	6d                   	insl   (%dx),%es:(%edi)
  cf:	65                   	gs
  d0:	2e                   	cs
  d1:	68 00 04 00 00       	push   $0x400


__extern_always_inline char *
__NTH (strcat (char *__restrict __dest, __const char *__restrict __src))
{
  return __builtin___strcat_chk (__dest, __src, __bos (__dest));
  d6:	73 74                	jae    14c <.debug_line+0x14c>
  d8:	61                   	popa   
  d9:	74 2e                	je     109 <.debug_line+0x109>
  db:	68 00 01 00 00       	push   $0x100
  e0:	6c                   	insb   (%dx),%es:(%edi)
  e1:	69 62 69 6f 2e 68 00 	imul   $0x682e6f,0x69(%edx),%esp
  e8:	04 00                	add    $0x0,%al
  ea:	00 73 74             	add    %dh,0x74(%ebx)
  ed:	64 69 6f 2e 68 00 04 00 	imul   $0x40068,%fs:0x2e(%edi),%ebp
  f5:	00 63 74             	add    %ah,0x74(%ebx)
  f8:	79 70                	jns    16a <.debug_line+0x16a>
			} else 
				strcpy(pathname, sp);
			strcat(pathname, "/");
			strcat(pathname, fn);

			if (stat(pathname, &buf) == 0) {
  fa:	65                   	gs
  fb:	2e                   	cs
  fc:	68 00 04 00 00       	push   $0x400
 101:	00 00                	add    %al,(%eax)
 103:	05 02 00 00 00       	add    $0x2,%eax	105: R_386_32	.text
 108:	00 03                	add    %al,(%ebx)
 10a:	26 01 08             	add    %ecx,%es:(%eax)
 10d:	19 00                	sbb    %eax,(%eax)
 10f:	02 04 01             	add    (%ecx,%eax,1),%al
 112:	06                   	push   %es
 113:	08 ac 00 02 04 01 06 	or     %ch,0x6010402(%eax,%eax,1)

				if (S_ISREG(buf.st_mode))
 11a:	85 00                	test   %eax,(%eax)
 11c:	02 04 01             	add    (%ecx,%eax,1),%al
 11f:	03 1c 2e             	add    (%esi,%ebp,1),%ebx
 122:	00 02                	add    %al,(%edx)
 124:	04 01                	add    $0x1,%al
 126:	03 64 58 06          	add    0x6(%eax,%ebx,2),%esp
 12a:	82                   	(bad)  
		for(fn = (char *)filename[i]; (*fn != '\0') && (*fn != '/') 
				&& (isspace(*fn)); fn++);
		if (*fn == '\0')
			continue;

		for (j = 0; searchpath[j] != NULL; j++) {
 12b:	00 02                	add    %al,(%edx)
 12d:	04 01                	add    $0x1,%al
 12f:	06                   	push   %es
 130:	92                   	xchg   %eax,%edx
 131:	00 02                	add    %al,(%edx)
 133:	04 01                	add    $0x1,%al

			for(sp = (char *)searchpath[j]; (*sp != '\0') && 
 135:	3b c9                	cmp    %ecx,%ecx
 137:	9f                   	lahf   
 138:	00 02                	add    %al,(%edx)
 13a:	04 01                	add    $0x1,%al
				(isspace(*sp)); sp++);
 13c:	85 06                	test   %eax,(%esi)
 13e:	08 12                	or     %dl,(%edx)
 140:	06                   	push   %es
 141:	08 3f                	or     %bh,(%edi)
 143:	3b 00                	cmp    (%eax),%eax
 145:	02 04 02             	add    (%edx,%eax,1),%al
 148:	75 00                	jne    14a <.debug_line+0x14a>
 14a:	02 04 02             	add    (%edx,%eax,1),%al
	int j;

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
		return -1;

	for (i = 0; filename[i] != NULL; i++) {
 14d:	3b 78 59             	cmp    0x59(%eax),%edi
 150:	04 02                	add    $0x2,%al
 152:	03 2b                	add    (%ebx),%ebp
 154:	ba 03 27 08 90       	mov    $0x90082703,%edx
		for(fn = (char *)filename[i]; (*fn != '\0') && (*fn != '/') 
 159:	04 01                	add    $0x1,%al
 15b:	03 b4 7f 02 27 01 04 	add    0x4012702(%edi,%edi,2),%esi
 162:	03 03                	add    (%ebx),%eax
 164:	85 03                	test   %eax,(%ebx)
 166:	82                   	(bad)  
 167:	04 01                	add    $0x1,%al
 169:	03 fb                	add    %ebx,%edi
 16b:	7c f2                	jl     15f <.debug_line+0x15f>
				&& (isspace(*fn)); fn++);
 16d:	4c                   	dec    %esp
 16e:	03 71 08             	add    0x8(%ecx),%esi
 171:	4a                   	dec    %edx
 172:	00 02                	add    %al,(%edx)
 174:	04 01                	add    $0x1,%al
 176:	a0 75 03 77 08       	mov    0x8770375,%al
	struct stat buf;
	int i;
	int j;

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
		return -1;
 17b:	12 00                	adc    (%eax),%al
 17d:	02 04 01             	add    (%ecx,%eax,1),%al
 180:	9f                   	lahf   
 181:	08 4b b6             	or     %cl,-0x4a(%ebx)
 184:	03 18                	add    (%eax),%ebx
			strcat(pathname, fn);

			if (stat(pathname, &buf) == 0) {

				if (S_ISREG(buf.st_mode))
					return 0;
 186:	d6                   	(bad)  
 187:	7a 59                	jp     1e2 <conf_lookup+0x1e2>
 189:	02 0b                	add    (%ebx),%cl
 18b:	00 01                	add    %al,(%ecx)

			}
		}
	}

	return -1;
 18d:	01                   	.byte 0x1

Disassembly of section .debug_str:

00000000 <.debug_str>:

#include "conf.h"

int conf_lookup(char * pathname, const char ** searchpath, 
				const char ** filename)
{
   0:	73 74                	jae    76 <.debug_str+0x76>
   2:	5f                   	pop    %edi
   3:	72 64                	jb     69 <.debug_str+0x69>
   5:	65                   	gs
   6:	76 00                	jbe    8 <.debug_str+0x8>
   8:	74 76                	je     80 <.debug_str+0x80>
   a:	5f                   	pop    %edi
   b:	6e                   	outsb  %ds:(%esi),(%dx)
   c:	73 65                	jae    73 <.debug_str+0x73>
   e:	63 00                	arpl   %ax,(%eax)
  10:	5f                   	pop    %edi
	char * sp;
	struct stat buf;
	int i;
	int j;

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
  11:	66                   	data16
  12:	6c                   	insb   (%dx),%es:(%edi)
  13:	61                   	popa   
  14:	67 73 32             	addr16 jae 49 <.debug_str+0x49>
  17:	00 5f 6f             	add    %bl,0x6f(%edi)
  1a:	6c                   	insb   (%dx),%es:(%edi)
  1b:	64                   	fs
  1c:	5f                   	pop    %edi
  1d:	6f                   	outsl  %ds:(%esi),(%dx)
  1e:	66                   	data16
  1f:	66                   	data16
  20:	73 65                	jae    87 <.debug_str+0x87>
  22:	74 00                	je     24 <.debug_str+0x24>
  24:	5f                   	pop    %edi
  25:	49                   	dec    %ecx
  26:	53                   	push   %ebx
  27:	63 6e 74             	arpl   %bp,0x74(%esi)
  2a:	72 6c                	jb     98 <.debug_str+0x98>
  2c:	00 5f 5f             	add    %bl,0x5f(%edi)
  2f:	75 6e                	jne    9f <.debug_str+0x9f>
  31:	75 73                	jne    a6 <.debug_str+0xa6>
  33:	65                   	gs
  34:	64                   	fs
		return -1;

	for (i = 0; filename[i] != NULL; i++) {
  35:	35 00 73 74 5f       	xor    $0x5f747300,%eax

			}
		}
	}

	return -1;
  3a:	73 69                	jae    a5 <.debug_str+0xa5>
	int j;

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
		return -1;

	for (i = 0; filename[i] != NULL; i++) {
  3c:	7a 65                	jp     a3 <.debug_str+0xa3>
  3e:	00 5f 49             	add    %bl,0x49(%edi)
  41:	4f                   	dec    %edi
  42:	5f                   	pop    %edi
  43:	46                   	inc    %esi
  44:	49                   	dec    %ecx
  45:	4c                   	dec    %esp
  46:	45                   	inc    %ebp
  47:	00 74 76 5f          	add    %dh,0x5f(%esi,%esi,2)
  4b:	73 65                	jae    b2 <.debug_str+0xb2>
		for(fn = (char *)filename[i]; (*fn != '\0') && (*fn != '/') 
				&& (isspace(*fn)); fn++);
  4d:	63 00                	arpl   %ax,(%eax)
  4f:	5f                   	pop    %edi

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
		return -1;

	for (i = 0; filename[i] != NULL; i++) {
		for(fn = (char *)filename[i]; (*fn != '\0') && (*fn != '/') 
  50:	49                   	dec    %ecx
  51:	4f                   	dec    %edi
  52:	5f                   	pop    %edi
  53:	73 61                	jae    b6 <.debug_str+0xb6>
  55:	76 65                	jbe    bc <.debug_str+0xbc>
  57:	5f                   	pop    %edi
  58:	65 6e                	outsb  %gs:(%esi),(%dx)
  5a:	64 00 5f 5f          	add    %bl,%fs:0x5f(%edi)
				&& (isspace(*fn)); fn++);
  5e:	6d                   	insl   (%dx),%es:(%edi)
  5f:	6f                   	outsl  %ds:(%esi),(%dx)
  60:	64                   	fs
  61:	65                   	gs
  62:	5f                   	pop    %edi
  63:	74 00                	je     65 <.debug_str+0x65>
  65:	73 69                	jae    d0 <.debug_str+0xd0>
		if (*fn == '\0')
  67:	7a 65                	jp     ce <.debug_str+0xce>
  69:	5f                   	pop    %edi
  6a:	74 00                	je     6c <.debug_str+0x6c>
  6c:	5f                   	pop    %edi
  6d:	49                   	dec    %ecx
  6e:	53                   	push   %ebx
			continue;

		for (j = 0; searchpath[j] != NULL; j++) {
  6f:	67 72 61             	addr16 jb d3 <.debug_str+0xd3>
  72:	70 68                	jo     dc <.debug_str+0xdc>
  74:	00 5f 49             	add    %bl,0x49(%edi)
  77:	53                   	push   %ebx
  78:	70 75                	jo     ef <.debug_str+0xef>
  7a:	6e                   	outsb  %ds:(%esi),(%dx)
  7b:	63 74 00 5f          	arpl   %si,0x5f(%eax,%eax,1)
  7f:	6f                   	outsl  %ds:(%esi),(%dx)
  80:	66                   	data16
  81:	66                   	data16
  82:	73 65                	jae    e9 <.debug_str+0xe9>
  84:	74 00                	je     86 <.debug_str+0x86>
  86:	5f                   	pop    %edi
  87:	49                   	dec    %ecx
  88:	4f                   	dec    %edi
  89:	5f                   	pop    %edi
  8a:	77 72                	ja     fe <.debug_str+0xfe>
  8c:	69 74 65 5f 70 74 72 00 	imul   $0x727470,0x5f(%ebp,%eiz,2),%esi

			for(sp = (char *)searchpath[j]; (*sp != '\0') && 
				(isspace(*sp)); sp++);
  94:	5f                   	pop    %edi
  95:	66                   	data16
  96:	6c                   	insb   (%dx),%es:(%edi)
		if (*fn == '\0')
			continue;

		for (j = 0; searchpath[j] != NULL; j++) {

			for(sp = (char *)searchpath[j]; (*sp != '\0') && 
  97:	61                   	popa   
  98:	67 73 00             	addr16 jae 9b <.debug_str+0x9b>
  9b:	73 74                	jae    111 <.debug_str+0x111>
  9d:	5f                   	pop    %edi
				(isspace(*sp)); sp++);
  9e:	61                   	popa   
  9f:	74 69                	je     10a <.debug_str+0x10a>
		if (*fn == '\0')
			continue;

		for (j = 0; searchpath[j] != NULL; j++) {

			for(sp = (char *)searchpath[j]; (*sp != '\0') && 
  a1:	6d                   	insl   (%dx),%es:(%edi)
  a2:	00 5f 5f             	add    %bl,0x5f(%edi)
  a5:	70 61                	jo     108 <.debug_str+0x108>
  a7:	74 68                	je     111 <.debug_str+0x111>
				(isspace(*sp)); sp++);

			/* very basic shell expansion */
			if (*sp == '~') {
  a9:	00 73 74             	add    %dh,0x74(%ebx)
  ac:	5f                   	pop    %edi
				strcpy(pathname, getenv("HOME"));
  ad:	64                   	fs
  ae:	65                   	gs
  af:	76 00                	jbe    b1 <.debug_str+0xb1>
  b1:	5f                   	pop    %edi
  b2:	49                   	dec    %ecx
  b3:	4f                   	dec    %edi
  b4:	5f                   	pop    %edi
  b5:	62 75 66             	bound  %esi,0x66(%ebp)
  b8:	5f                   	pop    %edi
#endif

__extern_always_inline char *
__NTH (strcpy (char *__restrict __dest, __const char *__restrict __src))
{
  return __builtin___strcpy_chk (__dest, __src, __bos (__dest));
  b9:	62 61 73             	bound  %esp,0x73(%ecx)
  bc:	65 00 73 74          	add    %dh,%gs:0x74(%ebx)
  c0:	5f                   	pop    %edi
  c1:	6e                   	outsb  %ds:(%esi),(%dx)
  c2:	6c                   	insb   (%dx),%es:(%edi)
  c3:	69 6e 6b 00 73 68 6f 	imul   $0x6f687300,0x6b(%esi),%ebp
  ca:	72 74                	jb     140 <.debug_str+0x140>
  cc:	20 69 6e             	and    %ch,0x6e(%ecx)
  cf:	74 00                	je     d1 <.debug_str+0xd1>
  d1:	5f                   	pop    %edi
  d2:	6d                   	insl   (%dx),%es:(%edi)


__extern_always_inline char *
__NTH (strcat (char *__restrict __dest, __const char *__restrict __src))
{
  return __builtin___strcat_chk (__dest, __src, __bos (__dest));
  d3:	61                   	popa   
  d4:	72 6b                	jb     141 <.debug_str+0x141>
  d6:	65                   	gs
  d7:	72 73                	jb     14c <.debug_str+0x14c>
  d9:	00 5f 49             	add    %bl,0x49(%edi)
  dc:	4f                   	dec    %edi
  dd:	5f                   	pop    %edi
  de:	72 65                	jb     145 <.debug_str+0x145>
  e0:	61                   	popa   
  e1:	64                   	fs
  e2:	5f                   	pop    %edi
  e3:	65 6e                	outsb  %gs:(%esi),(%dx)
  e5:	64 00 5f 49          	add    %bl,%fs:0x49(%edi)
  e9:	53                   	push   %ebx
  ea:	64 69 67 69 74 00 2f 68 	imul   $0x682f0074,%fs:0x69(%edi),%esp
  f2:	6f                   	outsl  %ds:(%esi),(%dx)
  f3:	6d                   	insl   (%dx),%es:(%edi)
  f4:	65                   	gs
  f5:	2f                   	das    
  f6:	6a 6f                	push   $0x6f
  f8:	6e                   	outsb  %ds:(%esi),(%dx)
  f9:	61                   	popa   
			} else 
				strcpy(pathname, sp);
			strcat(pathname, "/");
			strcat(pathname, fn);

			if (stat(pathname, &buf) == 0) {
  fa:	73 2f                	jae    12b <.debug_str+0x12b>
  fc:	44                   	inc    %esp
  fd:	6f                   	outsl  %ds:(%esi),(%dx)
  fe:	63 75 6d             	arpl   %si,0x6d(%ebp)
 101:	65 6e                	outsb  %gs:(%esi),(%dx)
 103:	74 6f                	je     174 <.debug_str+0x174>
 105:	73 2f                	jae    136 <.debug_str+0x136>
 107:	72 65                	jb     16e <.debug_str+0x16e>
 109:	66                   	data16
 10a:	65                   	gs
 10b:	72 65                	jb     172 <.debug_str+0x172>
 10d:	6e                   	outsb  %ds:(%esi),(%dx)
 10e:	63 69 61             	arpl   %bp,0x61(%ecx)
 111:	73 2f                	jae    142 <.debug_str+0x142>
 113:	70 72                	jo     187 <.debug_str+0x187>
 115:	6f                   	outsl  %ds:(%esi),(%dx)

				if (S_ISREG(buf.st_mode))
 116:	6a 65                	push   $0x65
 118:	74 6f                	je     189 <.debug_str+0x189>
 11a:	73 2d                	jae    149 <.debug_str+0x149>
 11c:	64                   	fs
 11d:	65                   	gs
 11e:	6d                   	insl   (%dx),%es:(%edi)
 11f:	6f                   	outsl  %ds:(%esi),(%dx)
 120:	2f                   	das    
 121:	61                   	popa   
 122:	70 70                	jo     194 <.debug_str+0x194>
 124:	2d 74 65 6d 70       	sub    $0x706d6574,%eax
 129:	6c                   	insb   (%dx),%es:(%edi)
 12a:	61                   	popa   
		for(fn = (char *)filename[i]; (*fn != '\0') && (*fn != '/') 
				&& (isspace(*fn)); fn++);
		if (*fn == '\0')
			continue;

		for (j = 0; searchpath[j] != NULL; j++) {
 12b:	74 65                	je     192 <.debug_str+0x192>
 12d:	2f                   	das    
 12e:	63 6f 6e             	arpl   %bp,0x6e(%edi)
 131:	66                   	data16
 132:	00 73 65             	add    %dh,0x65(%ebx)

			for(sp = (char *)searchpath[j]; (*sp != '\0') && 
 135:	61                   	popa   
 136:	72 63                	jb     19b <.debug_str+0x19b>
 138:	68 70 61 74 68       	push   $0x68746170
				(isspace(*sp)); sp++);
 13d:	00 66 69             	add    %ah,0x69(%esi)
 140:	6c                   	insb   (%dx),%es:(%edi)
 141:	65 6e                	outsb  %gs:(%esi),(%dx)
 143:	61                   	popa   
 144:	6d                   	insl   (%dx),%es:(%edi)
 145:	65 00 5f 49          	add    %bl,%gs:0x49(%edi)
 149:	53                   	push   %ebx
 14a:	62 6c 61 6e          	bound  %ebp,0x6e(%ecx,%eiz,2)
	int j;

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
		return -1;

	for (i = 0; filename[i] != NULL; i++) {
 14e:	6b 00 5f             	imul   $0x5f,(%eax),%eax
 151:	49                   	dec    %ecx
 152:	53                   	push   %ebx
 153:	61                   	popa   
 154:	6c                   	insb   (%dx),%es:(%edi)
 155:	6e                   	outsb  %ds:(%esi),(%dx)
 156:	75 6d                	jne    1c5 <.debug_str+0x1c5>
		for(fn = (char *)filename[i]; (*fn != '\0') && (*fn != '/') 
 158:	00 73 74             	add    %dh,0x74(%ebx)
 15b:	5f                   	pop    %edi
 15c:	62 6c 6b 73          	bound  %ebp,0x73(%ebx,%ebp,2)
 160:	69 7a 65 00 5f 49 53 	imul   $0x53495f00,0x65(%edx),%edi
 167:	73 70                	jae    1d9 <.debug_str+0x1d9>
 169:	61                   	popa   
 16a:	63 65 00             	arpl   %sp,0x0(%ebp)
				&& (isspace(*fn)); fn++);
 16d:	6c                   	insb   (%dx),%es:(%edi)
 16e:	6f                   	outsl  %ds:(%esi),(%dx)
 16f:	6e                   	outsb  %ds:(%esi),(%dx)
 170:	67 20 6c 6f          	and    %ch,0x6f(%si)
 174:	6e                   	outsb  %ds:(%esi),(%dx)
 175:	67 20 69 6e          	and    %ch,0x6e(%bx,%di)
	struct stat buf;
	int i;
	int j;

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
		return -1;
 179:	74 00                	je     17b <.debug_str+0x17b>
 17b:	73 74                	jae    1f1 <.debug_str+0x1f1>
 17d:	5f                   	pop    %edi
 17e:	67 69 64 00 5f 6c 6f 63 	imul   $0x636f6c5f,0x0(%si),%esp
			strcat(pathname, fn);

			if (stat(pathname, &buf) == 0) {

				if (S_ISREG(buf.st_mode))
					return 0;
 186:	6b 00 6c             	imul   $0x6c,(%eax),%eax
 189:	6f                   	outsl  %ds:(%esi),(%dx)
 18a:	6e                   	outsb  %ds:(%esi),(%dx)
 18b:	67 20 69 6e          	and    %ch,0x6e(%bx,%di)

			}
		}
	}

	return -1;
 18f:	74 00                	je     191 <.debug_str+0x191>
 191:	5f                   	pop    %edi
}
 192:	5f                   	pop    %edi
 193:	64                   	fs
 194:	65                   	gs
 195:	73 74                	jae    20b <.debug_str+0x20b>
 197:	00 5f 5f             	add    %bl,0x5f(%edi)
 19a:	6e                   	outsb  %ds:(%esi),(%dx)
 19b:	6c                   	insb   (%dx),%es:(%edi)
 19c:	69 6e 6b 5f 74 00 5f 	imul   $0x5f00745f,0x6b(%esi),%ebp
 1a3:	63 75 72             	arpl   %si,0x72(%ebp)
 1a6:	5f                   	pop    %edi
 1a7:	63 6f 6c             	arpl   %bp,0x6c(%edi)
 1aa:	75 6d                	jne    219 <.debug_str+0x219>
 1ac:	6e                   	outsb  %ds:(%esi),(%dx)
 1ad:	00 5f 70             	add    %bl,0x70(%edi)
 1b0:	6f                   	outsl  %ds:(%esi),(%dx)
 1b1:	73 00                	jae    1b3 <.debug_str+0x1b3>
 1b3:	73 74                	jae    229 <.debug_str+0x229>
 1b5:	5f                   	pop    %edi
 1b6:	63 74 69 6d          	arpl   %si,0x6d(%ecx,%ebp,2)
 1ba:	00 75 6e             	add    %dh,0x6e(%ebp)
 1bd:	73 69                	jae    228 <.debug_str+0x228>
 1bf:	67 6e                	outsb  %ds:(%si),(%dx)
 1c1:	65 64 20 63 68       	gs and %ah,%fs:%gs:0x68(%ebx)
 1c6:	61                   	popa   
 1c7:	72 00                	jb     1c9 <.debug_str+0x1c9>
 1c9:	5f                   	pop    %edi
 1ca:	76 74                	jbe    240 <.debug_str+0x240>
 1cc:	61                   	popa   
 1cd:	62 6c 65 5f          	bound  %ebp,0x5f(%ebp,%eiz,2)
 1d1:	6f                   	outsl  %ds:(%esi),(%dx)
 1d2:	66                   	data16
 1d3:	66                   	data16
 1d4:	73 65                	jae    23b <.debug_str+0x23b>
 1d6:	74 00                	je     1d8 <.debug_str+0x1d8>
 1d8:	5f                   	pop    %edi
 1d9:	5f                   	pop    %edi
 1da:	70 61                	jo     23d <.debug_str+0x23d>
 1dc:	64 31 00             	xor    %eax,%fs:(%eax)
 1df:	73 74                	jae    255 <.debug_str+0x255>
 1e1:	5f                   	pop    %edi
 1e2:	69 6e 6f 00 5f 5f 73 	imul   $0x735f5f00,0x6f(%esi),%ebp
 1e9:	72 63                	jb     24e <.debug_str+0x24e>
 1eb:	00 63 6f             	add    %ah,0x6f(%ebx)
 1ee:	6e                   	outsb  %ds:(%esi),(%dx)
 1ef:	66 5f                	pop    %di
 1f1:	6c                   	insb   (%dx),%es:(%edi)
 1f2:	6f                   	outsl  %ds:(%esi),(%dx)
 1f3:	6f                   	outsl  %ds:(%esi),(%dx)
 1f4:	6b 75 70 00          	imul   $0x0,0x70(%ebp),%esi
 1f8:	73 69                	jae    263 <.debug_str+0x263>
 1fa:	67 6e                	outsb  %ds:(%si),(%dx)
 1fc:	65 64 20 63 68       	gs and %ah,%fs:%gs:0x68(%ebx)
 201:	61                   	popa   
 202:	72 00                	jb     204 <.debug_str+0x204>
 204:	6c                   	insb   (%dx),%es:(%edi)
 205:	6f                   	outsl  %ds:(%esi),(%dx)
 206:	6e                   	outsb  %ds:(%esi),(%dx)
 207:	67 20 6c 6f          	and    %ch,0x6f(%si)
 20b:	6e                   	outsb  %ds:(%esi),(%dx)
 20c:	67 20 75 6e          	and    %dh,0x6e(%di)
 210:	73 69                	jae    27b <.debug_str+0x27b>
 212:	67 6e                	outsb  %ds:(%si),(%dx)
 214:	65 64 20 69 6e       	gs and %ch,%fs:%gs:0x6e(%ecx)
 219:	74 00                	je     21b <.debug_str+0x21b>
 21b:	75 6e                	jne    28b <.debug_str+0x28b>
 21d:	73 69                	jae    288 <.debug_str+0x288>
 21f:	67 6e                	outsb  %ds:(%si),(%dx)
 221:	65 64 20 69 6e       	gs and %ch,%fs:%gs:0x6e(%ecx)
 226:	74 00                	je     228 <.debug_str+0x228>
 228:	5f                   	pop    %edi
 229:	49                   	dec    %ecx
 22a:	4f                   	dec    %edi
 22b:	5f                   	pop    %edi
 22c:	6d                   	insl   (%dx),%es:(%edi)
 22d:	61                   	popa   
 22e:	72 6b                	jb     29b <.debug_str+0x29b>
 230:	65                   	gs
 231:	72 00                	jb     233 <.debug_str+0x233>
 233:	5f                   	pop    %edi
 234:	73 68                	jae    29e <.debug_str+0x29e>
 236:	6f                   	outsl  %ds:(%esi),(%dx)
 237:	72 74                	jb     2ad <.debug_str+0x2ad>
 239:	62 75 66             	bound  %esi,0x66(%ebp)
 23c:	00 6c 6f 6f          	add    %ch,0x6f(%edi,%ebp,2)
 240:	6b 75 70 2e          	imul   $0x2e,0x70(%ebp),%esi
 244:	63 00                	arpl   %ax,(%eax)
 246:	5f                   	pop    %edi
 247:	5f                   	pop    %edi
 248:	6f                   	outsl  %ds:(%esi),(%dx)
 249:	66                   	data16
 24a:	66                   	data16
 24b:	36                   	ss
 24c:	34 5f                	xor    $0x5f,%al
 24e:	74 00                	je     250 <.debug_str+0x250>
 250:	5f                   	pop    %edi
 251:	5f                   	pop    %edi
 252:	70 61                	jo     2b5 <.debug_str+0x2b5>
 254:	64 32 00             	xor    %fs:(%eax),%al
 257:	5f                   	pop    %edi
 258:	49                   	dec    %ecx
 259:	4f                   	dec    %edi
 25a:	5f                   	pop    %edi
 25b:	77 72                	ja     2cf <.debug_str+0x2cf>
 25d:	69 74 65 5f 62 61 73 65 	imul   $0x65736162,0x5f(%ebp,%eiz,2),%esi
 265:	00 5f 75             	add    %bl,0x75(%edi)
 268:	6e                   	outsb  %ds:(%esi),(%dx)
 269:	75 73                	jne    2de <.debug_str+0x2de>
 26b:	65 64 32 00          	gs xor %fs:%gs:(%eax),%al
 26f:	5f                   	pop    %edi
 270:	49                   	dec    %ecx
 271:	4f                   	dec    %edi
 272:	5f                   	pop    %edi
 273:	72 65                	jb     2da <.debug_str+0x2da>
 275:	61                   	popa   
 276:	64                   	fs
 277:	5f                   	pop    %edi
 278:	70 74                	jo     2ee <.debug_str+0x2ee>
 27a:	72 00                	jb     27c <.debug_str+0x27c>
 27c:	5f                   	pop    %edi
 27d:	5f                   	pop    %edi
 27e:	62 6c 6b 73          	bound  %ebp,0x73(%ebx,%ebp,2)
 282:	69 7a 65 5f 74 00 5f 	imul   $0x5f00745f,0x65(%edx),%edi
 289:	5f                   	pop    %edi
 28a:	70 61                	jo     2ed <.debug_str+0x2ed>
 28c:	64                   	fs
 28d:	35 00 5f 49 4f       	xor    $0x4f495f00,%eax
 292:	5f                   	pop    %edi
 293:	62 75 66             	bound  %esi,0x66(%ebp)
 296:	5f                   	pop    %edi
 297:	65 6e                	outsb  %gs:(%esi),(%dx)
 299:	64 00 63 68          	add    %ah,%fs:0x68(%ebx)
 29d:	61                   	popa   
 29e:	72 00                	jb     2a0 <.debug_str+0x2a0>
 2a0:	5f                   	pop    %edi
 2a1:	49                   	dec    %ecx
 2a2:	53                   	push   %ebx
 2a3:	6c                   	insb   (%dx),%es:(%edi)
 2a4:	6f                   	outsl  %ds:(%esi),(%dx)
 2a5:	77 65                	ja     30c <.debug_str+0x30c>
 2a7:	72 00                	jb     2a9 <.debug_str+0x2a9>
 2a9:	73 74                	jae    31f <.debug_str+0x31f>
 2ab:	72 63                	jb     310 <.debug_str+0x310>
 2ad:	61                   	popa   
 2ae:	74 00                	je     2b0 <.debug_str+0x2b0>
 2b0:	5f                   	pop    %edi
 2b1:	6e                   	outsb  %ds:(%esi),(%dx)
 2b2:	65                   	gs
 2b3:	78 74                	js     329 <.debug_str+0x329>
 2b5:	00 73 74             	add    %dh,0x74(%ebx)
 2b8:	72 63                	jb     31d <.debug_str+0x31d>
 2ba:	70 79                	jo     335 <.debug_str+0x335>
 2bc:	00 5f 49             	add    %bl,0x49(%edi)
 2bf:	53                   	push   %ebx
 2c0:	78 64                	js     326 <.debug_str+0x326>
 2c2:	69 67 69 74 00 5f 5f 	imul   $0x5f5f0074,0x69(%edi),%esp
 2c9:	70 61                	jo     32c <.debug_str+0x32c>
 2cb:	64 33 00             	xor    %fs:(%eax),%eax
 2ce:	5f                   	pop    %edi
 2cf:	5f                   	pop    %edi
 2d0:	70 61                	jo     333 <.debug_str+0x333>
 2d2:	64                   	fs
 2d3:	34 00                	xor    $0x0,%al
 2d5:	73 74                	jae    34b <.debug_str+0x34b>
 2d7:	5f                   	pop    %edi
 2d8:	62 6c 6f 63          	bound  %ebp,0x63(%edi,%ebp,2)
 2dc:	6b 73 00 5f          	imul   $0x5f,0x0(%ebx),%esi
 2e0:	5f                   	pop    %edi
 2e1:	75 5f                	jne    342 <.debug_str+0x342>
 2e3:	71 75                	jno    35a <.debug_str+0x35a>
 2e5:	61                   	popa   
 2e6:	64                   	fs
 2e7:	5f                   	pop    %edi
 2e8:	74 00                	je     2ea <.debug_str+0x2ea>
 2ea:	73 74                	jae    360 <.debug_str+0x360>
 2ec:	5f                   	pop    %edi
 2ed:	6d                   	insl   (%dx),%es:(%edi)
 2ee:	74 69                	je     359 <.debug_str+0x359>
 2f0:	6d                   	insl   (%dx),%es:(%edi)
 2f1:	00 5f 5f             	add    %bl,0x5f(%edi)
 2f4:	69 6e 6f 5f 74 00 73 	imul   $0x7300745f,0x6f(%esi),%ebp
 2fb:	74 5f                	je     35c <.debug_str+0x35c>
 2fd:	75 69                	jne    368 <.debug_str+0x368>
 2ff:	64 00 73 68          	add    %dh,%fs:0x68(%ebx)
 303:	6f                   	outsl  %ds:(%esi),(%dx)
 304:	72 74                	jb     37a <.debug_str+0x37a>
 306:	20 75 6e             	and    %dh,0x6e(%ebp)
 309:	73 69                	jae    374 <.debug_str+0x374>
 30b:	67 6e                	outsb  %ds:(%si),(%dx)
 30d:	65 64 20 69 6e       	gs and %ch,%fs:%gs:0x6e(%ecx)
 312:	74 00                	je     314 <.debug_str+0x314>
 314:	70 61                	jo     377 <.debug_str+0x377>
 316:	74 68                	je     380 <.debug_str+0x380>
 318:	6e                   	outsb  %ds:(%esi),(%dx)
 319:	61                   	popa   
 31a:	6d                   	insl   (%dx),%es:(%edi)
 31b:	65 00 6c 6f 6e       	add    %ch,%gs:0x6e(%edi,%ebp,2)
 320:	67 20 75 6e          	and    %dh,0x6e(%di)
 324:	73 69                	jae    38f <.debug_str+0x38f>
 326:	67 6e                	outsb  %ds:(%si),(%dx)
 328:	65 64 20 69 6e       	gs and %ch,%fs:%gs:0x6e(%ecx)
 32d:	74 00                	je     32f <.debug_str+0x32f>
 32f:	5f                   	pop    %edi
 330:	49                   	dec    %ecx
 331:	4f                   	dec    %edi
 332:	5f                   	pop    %edi
 333:	77 72                	ja     3a7 <.debug_str+0x3a7>
 335:	69 74 65 5f 65 6e 64 00 	imul   $0x646e65,0x5f(%ebp,%eiz,2),%esi
 33d:	5f                   	pop    %edi
 33e:	5f                   	pop    %edi
 33f:	74 69                	je     3aa <.debug_str+0x3aa>
 341:	6d                   	insl   (%dx),%es:(%edi)
 342:	65                   	gs
 343:	5f                   	pop    %edi
 344:	74 00                	je     346 <.debug_str+0x346>
 346:	5f                   	pop    %edi
 347:	66 69 6c 65 6e 6f 00 	imul   $0x6f,0x6e(%ebp,%eiz,2),%bp
 34e:	5f                   	pop    %edi
 34f:	63 68 61             	arpl   %bp,0x61(%eax)
 352:	69 6e 00 5f 5f 6f 66 	imul   $0x666f5f5f,0x0(%esi),%ebp
 359:	66 5f                	pop    %di
 35b:	74 00                	je     35d <.debug_str+0x35d>
 35d:	5f                   	pop    %edi
 35e:	5f                   	pop    %edi
 35f:	64                   	fs
 360:	65                   	gs
 361:	76 5f                	jbe    3c2 <.debug_str+0x3c2>
 363:	74 00                	je     365 <.debug_str+0x365>
 365:	5f                   	pop    %edi
 366:	49                   	dec    %ecx
 367:	4f                   	dec    %edi
 368:	5f                   	pop    %edi
 369:	62 61 63             	bound  %esp,0x63(%ecx)
 36c:	6b 75 70 5f          	imul   $0x5f,0x70(%ebp),%esi
 370:	62 61 73             	bound  %esp,0x73(%ecx)
 373:	65 00 73 74          	add    %dh,%gs:0x74(%ebx)
 377:	64 69 6e 00 5f 5f 71 75 	imul   $0x75715f5f,%fs:0x0(%esi),%ebp
 37f:	61                   	popa   
 380:	64                   	fs
 381:	5f                   	pop    %edi
 382:	74 00                	je     384 <.debug_str+0x384>
 384:	5f                   	pop    %edi
 385:	49                   	dec    %ecx
 386:	53                   	push   %ebx
 387:	70 72                	jo     3fb <.debug_str+0x3fb>
 389:	69 6e 74 00 5f 6d 6f 	imul   $0x6f6d5f00,0x74(%esi),%ebp
 390:	64 65 00 5f 49       	fs add %bl,%fs:%gs:0x49(%edi)
 395:	4f                   	dec    %edi
 396:	5f                   	pop    %edi
 397:	72 65                	jb     3fe <.debug_str+0x3fe>
 399:	61                   	popa   
 39a:	64                   	fs
 39b:	5f                   	pop    %edi
 39c:	62 61 73             	bound  %esp,0x73(%ecx)
 39f:	65 00 5f 5f          	add    %bl,%gs:0x5f(%edi)
 3a3:	73 74                	jae    419 <.debug_str+0x419>
 3a5:	61                   	popa   
 3a6:	74 62                	je     40a <.debug_str+0x40a>
 3a8:	75 66                	jne    410 <.debug_str+0x410>
 3aa:	00 5f 49             	add    %bl,0x49(%edi)
 3ad:	53                   	push   %ebx
 3ae:	75 70                	jne    420 <.debug_str+0x420>
 3b0:	70 65                	jo     417 <.debug_str+0x417>
 3b2:	72 00                	jb     3b4 <.debug_str+0x3b4>
 3b4:	74 69                	je     41f <.debug_str+0x41f>
 3b6:	6d                   	insl   (%dx),%es:(%edi)
 3b7:	65                   	gs
 3b8:	73 70                	jae    42a <conf_lookup+0x42a>
 3ba:	65 63 00             	arpl   %ax,%gs:(%eax)
 3bd:	5f                   	pop    %edi
 3be:	5f                   	pop    %edi
 3bf:	75 69                	jne    42a <conf_lookup+0x42a>
 3c1:	64                   	fs
 3c2:	5f                   	pop    %edi
 3c3:	74 00                	je     3c5 <.debug_str+0x3c5>
 3c5:	47                   	inc    %edi
 3c6:	4e                   	dec    %esi
 3c7:	55                   	push   %ebp
 3c8:	20 43 20             	and    %al,0x20(%ebx)
 3cb:	34 2e                	xor    $0x2e,%al
 3cd:	36 2e 33 00          	ss xor %cs:%ss:(%eax),%eax
 3d1:	5f                   	pop    %edi
 3d2:	49                   	dec    %ecx
 3d3:	4f                   	dec    %edi
 3d4:	5f                   	pop    %edi
 3d5:	73 61                	jae    438 <conf_lookup+0x438>
 3d7:	76 65                	jbe    43e <conf_lookup+0x43e>
 3d9:	5f                   	pop    %edi
 3da:	62 61 73             	bound  %esp,0x73(%ecx)
 3dd:	65 00 73 74          	add    %dh,%gs:0x74(%ebx)
 3e1:	61                   	popa   
 3e2:	74 00                	je     3e4 <.debug_str+0x3e4>
 3e4:	73 74                	jae    45a <conf_lookup+0x45a>
 3e6:	5f                   	pop    %edi
 3e7:	6d                   	insl   (%dx),%es:(%edi)
 3e8:	6f                   	outsl  %ds:(%esi),(%dx)
 3e9:	64 65 00 5f 73       	fs add %bl,%fs:%gs:0x73(%edi)
 3ee:	62 75 66             	bound  %esi,0x66(%ebp)
 3f1:	00 5f 5f             	add    %bl,0x5f(%edi)
 3f4:	75 6e                	jne    464 <conf_lookup+0x464>
 3f6:	75 73                	jne    46b <conf_lookup+0x46b>
 3f8:	65                   	gs
 3f9:	64                   	fs
 3fa:	34 00                	xor    $0x0,%al
 3fc:	5f                   	pop    %edi
 3fd:	49                   	dec    %ecx
 3fe:	53                   	push   %ebx
 3ff:	61                   	popa   
 400:	6c                   	insb   (%dx),%es:(%edi)
 401:	70 68                	jo     46b <conf_lookup+0x46b>
 403:	61                   	popa   
 404:	00 5f 5f             	add    %bl,0x5f(%edi)
 407:	62 6c 6b 63          	bound  %ebp,0x63(%ebx,%ebp,2)
 40b:	6e                   	outsb  %ds:(%esi),(%dx)
 40c:	74 5f                	je     46d <conf_lookup+0x46d>
 40e:	74 00                	je     410 <.debug_str+0x410>
 410:	73 74                	jae    486 <conf_lookup+0x486>
 412:	64 6f                	outsl  %fs:(%esi),(%dx)
 414:	75 74                	jne    48a <conf_lookup+0x48a>
 416:	00 5f 49             	add    %bl,0x49(%edi)
 419:	4f                   	dec    %edi
 41a:	5f                   	pop    %edi
 41b:	6c                   	insb   (%dx),%es:(%edi)
 41c:	6f                   	outsl  %ds:(%esi),(%dx)
 41d:	63 6b 5f             	arpl   %bp,0x5f(%ebx)
 420:	74 00                	je     422 <.debug_str+0x422>
 422:	5f                   	pop    %edi
 423:	5f                   	pop    %edi
 424:	67                   	addr16
 425:	69                   	.byte 0x69
 426:	64                   	fs
 427:	5f                   	pop    %edi
 428:	74 00                	je     42a <conf_lookup+0x42a>

Disassembly of section .comment:

00000000 <.comment>:

#include "conf.h"

int conf_lookup(char * pathname, const char ** searchpath, 
				const char ** filename)
{
   0:	00 47 43             	add    %al,0x43(%edi)
   3:	43                   	inc    %ebx
   4:	3a 20                	cmp    (%eax),%ah
   6:	28 55 62             	sub    %dl,0x62(%ebp)
   9:	75 6e                	jne    79 <conf_lookup+0x79>
   b:	74 75                	je     82 <conf_lookup+0x82>
   d:	2f                   	das    
   e:	4c                   	dec    %esp
   f:	69 6e 61 72 6f 20 34 	imul   $0x34206f72,0x61(%esi),%ebp
	char * sp;
	struct stat buf;
	int i;
	int j;

	if ((pathname == NULL) || (searchpath == NULL) || (filename == NULL))
  16:	2e 36 2e 33 2d 31 75 62 75 	cs ss xor %cs:%ss:0x75627531,%ebp
  1f:	6e                   	outsb  %ds:(%esi),(%dx)
  20:	74 75                	je     97 <conf_lookup+0x97>
  22:	35 29 20 34 2e       	xor    $0x2e342029,%eax
  27:	36 2e 33 00          	ss xor %cs:%ss:(%eax),%eax

Disassembly of section .eh_frame:

00000000 <.eh_frame>:
   0:	14 00                	adc    $0x0,%al
   2:	00 00                	add    %al,(%eax)
   4:	00 00                	add    %al,(%eax)
   6:	00 00                	add    %al,(%eax)
   8:	01 7a 52             	add    %edi,0x52(%edx)
   b:	00 01                	add    %al,(%ecx)
   d:	7c 08                	jl     17 <.eh_frame+0x17>
   f:	01 1b                	add    %ebx,(%ebx)
  11:	0c 04                	or     $0x4,%al
  13:	04 88                	add    $0x88,%al
  15:	01 00                	add    %eax,(%eax)
  17:	00 3c 00             	add    %bh,(%eax,%eax,1)
  1a:	00 00                	add    %al,(%eax)
  1c:	1c 00                	sbb    $0x0,%al
  1e:	00 00                	add    %al,(%eax)
  20:	00 00                	add    %al,(%eax)	20: R_386_PC32	.text
  22:	00 00                	add    %al,(%eax)
  24:	9d                   	popf   
  25:	01 00                	add    %eax,(%eax)
  27:	00 00                	add    %al,(%eax)
  29:	41                   	inc    %ecx
  2a:	0e                   	push   %cs
  2b:	08 85 02 41 0e 0c    	or     %al,0xc0e4102(%ebp)
  31:	87 03                	xchg   %eax,(%ebx)
  33:	41                   	inc    %ecx
  34:	0e                   	push   %cs
  35:	10 86 04 41 0e 14    	adc    %al,0x140e4104(%esi)
  3b:	83 05 46 0e a0 01 03 	addl   $0x3,0x1a00e46
  42:	8e 01                	mov    (%ecx),%es
  44:	0e                   	push   %cs
  45:	14 41                	adc    $0x41,%al
  47:	0e                   	push   %cs
  48:	10 c3                	adc    %al,%bl
  4a:	41                   	inc    %ecx
  4b:	0e                   	push   %cs
  4c:	0c c6                	or     $0xc6,%al
  4e:	41                   	inc    %ecx
  4f:	0e                   	push   %cs
  50:	08 c7                	or     %al,%bh
  52:	41                   	inc    %ecx
  53:	0e                   	push   %cs
  54:	04 c5                	add    $0xc5,%al
  56:	00 00                	add    %al,(%eax)
